CCS PCM C Compiler, Version 5.025, 26966               06-Jul-24 22:50

               Filename:   E:\1. Phenikaa University\AML\1. Code\VDK (PIC16)\0. BTL\1. Code\V1.2\main.lst

               ROM used:   2408 words (29%)
                           Largest free fragment is 2048
               RAM used:   49 (13%) at main() level
                           74 (20%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   579
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   15F
.................... #include <main.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDLW  58
0055:  BTFSC  03.0
0056:  INCF   0A,F
0057:  MOVWF  02
0058:  RETLW  2E
0059:  RETLW  2D
005A:  RETLW  00
005B:  RETLW  00
005C:  RETLW  00
005D:  RETLW  00
005E:  RETLW  41
005F:  RETLW  2D
0060:  RETLW  2E
0061:  RETLW  2E
0062:  RETLW  2E
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  2D
0067:  RETLW  2E
0068:  RETLW  2D
0069:  RETLW  2E
006A:  RETLW  00
006B:  RETLW  00
006C:  RETLW  43
006D:  RETLW  2D
006E:  RETLW  2E
006F:  RETLW  2E
0070:  RETLW  00
0071:  RETLW  00
0072:  RETLW  00
0073:  RETLW  44
0074:  RETLW  2E
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  00
0079:  RETLW  00
007A:  RETLW  45
007B:  RETLW  2E
007C:  RETLW  2E
007D:  RETLW  2D
007E:  RETLW  2E
007F:  RETLW  00
0080:  RETLW  00
0081:  RETLW  46
0082:  RETLW  2D
0083:  RETLW  2D
0084:  RETLW  2E
0085:  RETLW  00
0086:  RETLW  00
0087:  RETLW  00
0088:  RETLW  47
0089:  RETLW  2E
008A:  RETLW  2E
008B:  RETLW  2E
008C:  RETLW  2E
008D:  RETLW  00
008E:  RETLW  00
008F:  RETLW  48
0090:  RETLW  2E
0091:  RETLW  2E
0092:  RETLW  00
0093:  RETLW  00
0094:  RETLW  00
0095:  RETLW  00
0096:  RETLW  49
0097:  RETLW  2E
0098:  RETLW  2D
0099:  RETLW  2D
009A:  RETLW  2D
009B:  RETLW  00
009C:  RETLW  00
009D:  RETLW  4A
009E:  RETLW  2D
009F:  RETLW  2E
00A0:  RETLW  2D
00A1:  RETLW  00
00A2:  RETLW  00
00A3:  RETLW  00
00A4:  RETLW  4B
00A5:  RETLW  2E
00A6:  RETLW  2D
00A7:  RETLW  2E
00A8:  RETLW  2E
00A9:  RETLW  00
00AA:  RETLW  00
00AB:  RETLW  4C
00AC:  RETLW  2D
00AD:  RETLW  2D
00AE:  RETLW  00
00AF:  RETLW  00
00B0:  RETLW  00
00B1:  RETLW  00
00B2:  RETLW  4D
00B3:  RETLW  2D
00B4:  RETLW  2E
00B5:  RETLW  00
00B6:  RETLW  00
00B7:  RETLW  00
00B8:  RETLW  00
00B9:  RETLW  4E
00BA:  RETLW  2D
00BB:  RETLW  2D
00BC:  RETLW  2D
00BD:  RETLW  00
00BE:  RETLW  00
00BF:  RETLW  00
00C0:  RETLW  4F
00C1:  RETLW  2E
00C2:  RETLW  2D
00C3:  RETLW  2D
00C4:  RETLW  2E
00C5:  RETLW  00
00C6:  RETLW  00
00C7:  RETLW  50
00C8:  RETLW  2D
00C9:  RETLW  2D
00CA:  RETLW  2E
00CB:  RETLW  2D
00CC:  RETLW  00
00CD:  RETLW  00
00CE:  RETLW  51
00CF:  RETLW  2E
00D0:  RETLW  2D
00D1:  RETLW  2E
00D2:  RETLW  00
00D3:  RETLW  00
00D4:  RETLW  00
00D5:  RETLW  52
00D6:  RETLW  2E
00D7:  RETLW  2E
00D8:  RETLW  2E
00D9:  RETLW  00
00DA:  RETLW  00
00DB:  RETLW  00
00DC:  RETLW  53
00DD:  RETLW  2D
00DE:  RETLW  00
00DF:  RETLW  00
00E0:  RETLW  00
00E1:  RETLW  00
00E2:  RETLW  00
00E3:  RETLW  54
00E4:  RETLW  2E
00E5:  RETLW  2E
00E6:  RETLW  2D
00E7:  RETLW  00
00E8:  RETLW  00
00E9:  RETLW  00
00EA:  RETLW  55
00EB:  RETLW  2E
00EC:  RETLW  2E
00ED:  RETLW  2E
00EE:  RETLW  2D
00EF:  RETLW  00
00F0:  RETLW  00
00F1:  RETLW  56
00F2:  RETLW  2E
00F3:  RETLW  2D
00F4:  RETLW  2D
00F5:  RETLW  00
00F6:  RETLW  00
00F7:  RETLW  00
00F8:  RETLW  57
00F9:  RETLW  2D
00FA:  RETLW  2E
00FB:  RETLW  2E
00FC:  RETLW  2D
00FD:  RETLW  00
00FE:  RETLW  00
00FF:  RETLW  58
0100:  RETLW  2D
0101:  RETLW  2E
0102:  RETLW  2D
0103:  RETLW  2D
0104:  RETLW  00
0105:  RETLW  00
0106:  RETLW  59
0107:  RETLW  2D
0108:  RETLW  2D
0109:  RETLW  2E
010A:  RETLW  2E
010B:  RETLW  00
010C:  RETLW  00
010D:  RETLW  5A
010E:  RETLW  2D
010F:  RETLW  2D
0110:  RETLW  2D
0111:  RETLW  2D
0112:  RETLW  2D
0113:  RETLW  00
0114:  RETLW  30
0115:  RETLW  2E
0116:  RETLW  2D
0117:  RETLW  2D
0118:  RETLW  2D
0119:  RETLW  2D
011A:  RETLW  00
011B:  RETLW  31
011C:  RETLW  2E
011D:  RETLW  2E
011E:  RETLW  2D
011F:  RETLW  2D
0120:  RETLW  2D
0121:  RETLW  00
0122:  RETLW  32
0123:  RETLW  2E
0124:  RETLW  2E
0125:  RETLW  2E
0126:  RETLW  2D
0127:  RETLW  2D
0128:  RETLW  00
0129:  RETLW  33
012A:  RETLW  2E
012B:  RETLW  2E
012C:  RETLW  2E
012D:  RETLW  2E
012E:  RETLW  2D
012F:  RETLW  00
0130:  RETLW  34
0131:  RETLW  2E
0132:  RETLW  2E
0133:  RETLW  2E
0134:  RETLW  2E
0135:  RETLW  2E
0136:  RETLW  00
0137:  RETLW  35
0138:  RETLW  2D
0139:  RETLW  2E
013A:  RETLW  2E
013B:  RETLW  2E
013C:  RETLW  2E
013D:  RETLW  00
013E:  RETLW  36
013F:  RETLW  2D
0140:  RETLW  2D
0141:  RETLW  2E
0142:  RETLW  2E
0143:  RETLW  2E
0144:  RETLW  00
0145:  RETLW  37
0146:  RETLW  2D
0147:  RETLW  2D
0148:  RETLW  2D
0149:  RETLW  2E
014A:  RETLW  2E
014B:  RETLW  00
014C:  RETLW  38
014D:  RETLW  2D
014E:  RETLW  2D
014F:  RETLW  2D
0150:  RETLW  2D
0151:  RETLW  2E
0152:  RETLW  00
0153:  RETLW  39
0154:  BSF    0A.0
0155:  BCF    0A.1
0156:  BCF    0A.2
0157:  ADDWF  02,F
0158:  RETLW  42
0159:  RETLW  75
015A:  RETLW  74
015B:  RETLW  74
015C:  RETLW  6F
015D:  RETLW  6E
015E:  RETLW  00
*
016C:  DATA 20,10
016D:  DATA 20,10
016E:  DATA 20,10
016F:  DATA 20,10
0170:  DATA 20,10
0171:  DATA 20,10
0172:  DATA 20,10
0173:  DATA 20,10
0174:  DATA 00,00
0175:  DATA 20,10
0176:  DATA 20,10
0177:  DATA 20,10
0178:  DATA 20,10
0179:  DATA 20,10
017A:  DATA 20,10
017B:  DATA 20,10
017C:  DATA 20,10
017D:  DATA 00,00
017E:  DATA CD,37
017F:  DATA E4,32
0180:  DATA 3A,10
0181:  DATA A5,39
0182:  DATA 00,01
0183:  DATA 31,17
0184:  DATA 20,26
0185:  DATA 45,10
0186:  DATA 54,29
0187:  DATA 4F,27
0188:  DATA 47,10
0189:  DATA 41,27
018A:  DATA 00,01
018B:  DATA 32,17
018C:  DATA 20,27
018D:  DATA 2E,24
018E:  DATA 20,2B
018F:  DATA C9,22
0190:  DATA 54,10
0191:  DATA 41,27
0192:  DATA 48,00
*
024D:  MOVF   78,W
024E:  BTFSC  03.2
024F:  GOTO   255
0250:  MOVF   77,W
0251:  MOVWF  00
0252:  INCF   04,F
0253:  DECFSZ 78,F
0254:  GOTO   250
0255:  RETURN
*
048D:  MOVF   0B,W
048E:  MOVWF  53
048F:  BCF    0B.7
0490:  BSF    03.5
0491:  BSF    03.6
0492:  BSF    0C.7
0493:  BSF    0C.0
0494:  NOP
0495:  NOP
0496:  BCF    03.5
0497:  BCF    03.6
0498:  BTFSC  53.7
0499:  BSF    0B.7
049A:  BSF    03.6
049B:  MOVF   0C,W
049C:  ANDLW  7F
049D:  BTFSC  03.2
049E:  GOTO   4E1
049F:  BCF    03.6
04A0:  MOVWF  53
04A1:  BSF    03.6
04A2:  MOVF   0D,W
04A3:  BCF    03.6
04A4:  MOVWF  54
04A5:  BSF    03.6
04A6:  MOVF   0F,W
04A7:  BCF    03.6
04A8:  MOVWF  55
04A9:  MOVF   53,W
04AA:  MOVWF  5D
04AB:  CALL   324
04AC:  MOVF   54,W
04AD:  BSF    03.6
04AE:  MOVWF  0D
04AF:  BCF    03.6
04B0:  MOVF   55,W
04B1:  BSF    03.6
04B2:  MOVWF  0F
04B3:  BCF    03.6
04B4:  MOVF   0B,W
04B5:  MOVWF  56
04B6:  BCF    0B.7
04B7:  BSF    03.5
04B8:  BSF    03.6
04B9:  BSF    0C.7
04BA:  BSF    0C.0
04BB:  NOP
04BC:  NOP
04BD:  BCF    03.5
04BE:  BCF    03.6
04BF:  BTFSC  56.7
04C0:  BSF    0B.7
04C1:  BSF    03.6
04C2:  RLF    0C,W
04C3:  RLF    0E,W
04C4:  ANDLW  7F
04C5:  BTFSC  03.2
04C6:  GOTO   4E1
04C7:  BCF    03.6
04C8:  MOVWF  53
04C9:  BSF    03.6
04CA:  MOVF   0D,W
04CB:  BCF    03.6
04CC:  MOVWF  54
04CD:  BSF    03.6
04CE:  MOVF   0F,W
04CF:  BCF    03.6
04D0:  MOVWF  55
04D1:  MOVF   53,W
04D2:  MOVWF  5D
04D3:  CALL   324
04D4:  MOVF   54,W
04D5:  BSF    03.6
04D6:  MOVWF  0D
04D7:  BCF    03.6
04D8:  MOVF   55,W
04D9:  BSF    03.6
04DA:  MOVWF  0F
04DB:  INCF   0D,F
04DC:  BTFSC  03.2
04DD:  INCF   0F,F
04DE:  BCF    03.6
04DF:  GOTO   48D
04E0:  BSF    03.6
04E1:  BCF    03.6
04E2:  RETURN
*
04FE:  MOVF   00,F
04FF:  BTFSC  03.2
0500:  GOTO   513
0501:  CLRF   5A
0502:  MOVF   04,W
0503:  MOVWF  59
0504:  BCF    5A.0
0505:  BTFSC  03.7
0506:  BSF    5A.0
0507:  MOVF   00,W
0508:  MOVWF  5D
0509:  CALL   324
050A:  MOVF   59,W
050B:  MOVWF  04
050C:  BCF    03.7
050D:  BTFSC  5A.0
050E:  BSF    03.7
050F:  INCF   04,F
0510:  BTFSC  03.2
0511:  INCF   05,F
0512:  GOTO   4FE
0513:  RETURN
0514:  CLRF   77
0515:  CLRF   78
0516:  MOVF   56,W
0517:  BCF    03.0
0518:  BTFSC  57.0
0519:  ADDWF  77,F
051A:  RRF    77,F
051B:  RRF    78,F
051C:  BTFSC  57.1
051D:  ADDWF  77,F
051E:  RRF    77,F
051F:  RRF    78,F
0520:  BTFSC  57.2
0521:  ADDWF  77,F
0522:  RRF    77,F
0523:  RRF    78,F
0524:  BTFSC  57.3
0525:  ADDWF  77,F
0526:  RRF    77,F
0527:  RRF    78,F
0528:  BTFSC  57.4
0529:  ADDWF  77,F
052A:  RRF    77,F
052B:  RRF    78,F
052C:  BTFSC  57.5
052D:  ADDWF  77,F
052E:  RRF    77,F
052F:  RRF    78,F
0530:  BTFSC  57.6
0531:  ADDWF  77,F
0532:  RRF    77,F
0533:  RRF    78,F
0534:  BTFSC  57.7
0535:  ADDWF  77,F
0536:  RRF    77,F
0537:  RRF    78,F
0538:  RETURN
*
0542:  MOVF   0B,W
0543:  MOVWF  54
0544:  BCF    0B.7
0545:  BSF    03.5
0546:  BSF    03.6
0547:  BSF    0C.7
0548:  BSF    0C.0
0549:  NOP
054A:  NOP
054B:  BCF    03.5
054C:  BCF    03.6
054D:  BTFSC  54.7
054E:  BSF    0B.7
054F:  BSF    03.6
0550:  MOVF   0C,F
0551:  BTFSC  03.2
0552:  GOTO   56C
0553:  MOVF   0D,W
0554:  BCF    03.6
0555:  MOVWF  54
0556:  BSF    03.6
0557:  MOVF   0F,W
0558:  BCF    03.6
0559:  MOVWF  55
055A:  BSF    03.6
055B:  MOVF   0C,W
055C:  BCF    03.6
055D:  MOVWF  5D
055E:  CALL   324
055F:  MOVF   54,W
0560:  BSF    03.6
0561:  MOVWF  0D
0562:  BCF    03.6
0563:  MOVF   55,W
0564:  BSF    03.6
0565:  MOVWF  0F
0566:  INCF   0D,F
0567:  BTFSC  03.2
0568:  INCF   0F,F
0569:  BCF    03.6
056A:  GOTO   542
056B:  BSF    03.6
056C:  BCF    03.6
056D:  RETURN
*
0B12:  MOVF   0B,W
0B13:  MOVWF  5A
0B14:  BCF    0B.7
0B15:  BSF    03.5
0B16:  BSF    03.6
0B17:  BSF    0C.7
0B18:  BSF    0C.0
0B19:  NOP
0B1A:  NOP
0B1B:  BCF    03.5
0B1C:  BCF    03.6
0B1D:  BTFSC  5A.7
0B1E:  BSF    0B.7
0B1F:  BTFSC  03.0
0B20:  GOTO   34B
0B21:  BSF    03.6
0B22:  MOVF   0C,W
0B23:  ANDLW  7F
0B24:  BCF    03.6
0B25:  MOVWF  5A
0B26:  BSF    03.6
0B27:  MOVF   0D,W
0B28:  BCF    03.6
0B29:  MOVWF  5B
0B2A:  BSF    03.6
0B2B:  MOVF   0F,W
0B2C:  BCF    03.6
0B2D:  MOVWF  5C
0B2E:  MOVF   5A,W
0B2F:  MOVWF  5D
0B30:  BCF    0A.3
0B31:  CALL   324
0B32:  BSF    0A.3
0B33:  MOVF   5B,W
0B34:  BSF    03.6
0B35:  MOVWF  0D
0B36:  BCF    03.6
0B37:  MOVF   5C,W
0B38:  BSF    03.6
0B39:  MOVWF  0F
0B3A:  BCF    03.6
0B3B:  MOVF   0B,W
0B3C:  MOVWF  5D
0B3D:  BCF    0B.7
0B3E:  BSF    03.5
0B3F:  BSF    03.6
0B40:  BSF    0C.7
0B41:  BSF    0C.0
0B42:  NOP
0B43:  NOP
0B44:  BCF    03.5
0B45:  BCF    03.6
0B46:  BTFSC  5D.7
0B47:  BSF    0B.7
0B48:  DECFSZ 59,F
0B49:  GOTO   34B
0B4A:  GOTO   36C
0B4B:  BSF    03.6
0B4C:  RLF    0C,W
0B4D:  RLF    0E,W
0B4E:  ANDLW  7F
0B4F:  BCF    03.6
0B50:  MOVWF  5A
0B51:  BSF    03.6
0B52:  MOVF   0D,W
0B53:  BCF    03.6
0B54:  MOVWF  5B
0B55:  BSF    03.6
0B56:  MOVF   0F,W
0B57:  BCF    03.6
0B58:  MOVWF  5C
0B59:  MOVF   5A,W
0B5A:  MOVWF  5D
0B5B:  BCF    0A.3
0B5C:  CALL   324
0B5D:  BSF    0A.3
0B5E:  MOVF   5B,W
0B5F:  BSF    03.6
0B60:  MOVWF  0D
0B61:  BCF    03.6
0B62:  MOVF   5C,W
0B63:  BSF    03.6
0B64:  MOVWF  0F
0B65:  INCF   0D,F
0B66:  BTFSC  03.2
0B67:  INCF   0F,F
0B68:  BCF    03.0
0B69:  BCF    03.6
0B6A:  DECFSZ 59,F
0B6B:  GOTO   312
....................  
.................... #list 
....................  
.................... #device ADC = 16 
....................  
.................... #FUSES NOWDT      // No Watch Dog Timer 
.................... #FUSES PUT        // Power Up Timer 
.................... #FUSES NOBROWNOUT // No brownout reset 
.................... #FUSES NOLVP      // No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
....................  
.................... #use delay(crystal = 12000000) 
*
02AB:  MOVLW  55
02AC:  MOVWF  04
02AD:  BCF    03.7
02AE:  MOVF   00,W
02AF:  BTFSC  03.2
02B0:  GOTO   2BF
02B1:  MOVLW  03
02B2:  MOVWF  78
02B3:  CLRF   77
02B4:  DECFSZ 77,F
02B5:  GOTO   2B4
02B6:  DECFSZ 78,F
02B7:  GOTO   2B3
02B8:  MOVLW  E3
02B9:  MOVWF  77
02BA:  DECFSZ 77,F
02BB:  GOTO   2BA
02BC:  NOP
02BD:  DECFSZ 00,F
02BE:  GOTO   2B1
02BF:  RETURN
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PORT1) 
.................... #use i2c(Master, Fast = 400000, sda = PIN_C4, scl = PIN_C3, force_sw) 
*
0193:  MOVLW  08
0194:  MOVWF  78
0195:  NOP
0196:  BCF    07.3
0197:  BCF    2B.3
0198:  MOVF   2B,W
0199:  BSF    03.5
019A:  MOVWF  07
019B:  NOP
019C:  BCF    03.5
019D:  RLF    64,F
019E:  BCF    07.4
019F:  BTFSS  03.0
01A0:  GOTO   1A7
01A1:  BSF    2B.4
01A2:  MOVF   2B,W
01A3:  BSF    03.5
01A4:  MOVWF  07
01A5:  GOTO   1AB
01A6:  BCF    03.5
01A7:  BCF    2B.4
01A8:  MOVF   2B,W
01A9:  BSF    03.5
01AA:  MOVWF  07
01AB:  NOP
01AC:  BCF    03.5
01AD:  BSF    2B.3
01AE:  MOVF   2B,W
01AF:  BSF    03.5
01B0:  MOVWF  07
01B1:  BCF    03.5
01B2:  BTFSS  07.3
01B3:  GOTO   1B2
01B4:  DECFSZ 78,F
01B5:  GOTO   195
01B6:  NOP
01B7:  BCF    07.3
01B8:  BCF    2B.3
01B9:  MOVF   2B,W
01BA:  BSF    03.5
01BB:  MOVWF  07
01BC:  NOP
01BD:  BCF    03.5
01BE:  BSF    2B.4
01BF:  MOVF   2B,W
01C0:  BSF    03.5
01C1:  MOVWF  07
01C2:  NOP
01C3:  NOP
01C4:  BCF    03.5
01C5:  BSF    2B.3
01C6:  MOVF   2B,W
01C7:  BSF    03.5
01C8:  MOVWF  07
01C9:  BCF    03.5
01CA:  BTFSS  07.3
01CB:  GOTO   1CA
01CC:  CLRF   78
01CD:  NOP
01CE:  BTFSC  07.4
01CF:  BSF    78.0
01D0:  BCF    07.3
01D1:  BCF    2B.3
01D2:  MOVF   2B,W
01D3:  BSF    03.5
01D4:  MOVWF  07
01D5:  BCF    03.5
01D6:  BCF    07.4
01D7:  BCF    2B.4
01D8:  MOVF   2B,W
01D9:  BSF    03.5
01DA:  MOVWF  07
01DB:  BCF    03.5
01DC:  RETURN
*
02DF:  MOVLW  08
02E0:  MOVWF  63
02E1:  MOVF   77,W
02E2:  MOVWF  64
02E3:  BSF    2B.4
02E4:  MOVF   2B,W
02E5:  BSF    03.5
02E6:  MOVWF  07
02E7:  NOP
02E8:  BCF    03.5
02E9:  BSF    2B.3
02EA:  MOVF   2B,W
02EB:  BSF    03.5
02EC:  MOVWF  07
02ED:  BCF    03.5
02EE:  BTFSS  07.3
02EF:  GOTO   2EE
02F0:  BTFSC  07.4
02F1:  BSF    03.0
02F2:  BTFSS  07.4
02F3:  BCF    03.0
02F4:  RLF    78,F
02F5:  NOP
02F6:  BCF    2B.3
02F7:  MOVF   2B,W
02F8:  BSF    03.5
02F9:  MOVWF  07
02FA:  BCF    03.5
02FB:  BCF    07.3
02FC:  DECFSZ 63,F
02FD:  GOTO   2E3
02FE:  BSF    2B.4
02FF:  MOVF   2B,W
0300:  BSF    03.5
0301:  MOVWF  07
0302:  NOP
0303:  BCF    03.5
0304:  BCF    07.4
0305:  MOVF   64,W
0306:  BTFSC  03.2
0307:  GOTO   30D
0308:  BCF    2B.4
0309:  MOVF   2B,W
030A:  BSF    03.5
030B:  MOVWF  07
030C:  BCF    03.5
030D:  NOP
030E:  BSF    2B.3
030F:  MOVF   2B,W
0310:  BSF    03.5
0311:  MOVWF  07
0312:  BCF    03.5
0313:  BTFSS  07.3
0314:  GOTO   313
0315:  NOP
0316:  BCF    07.3
0317:  BCF    2B.3
0318:  MOVF   2B,W
0319:  BSF    03.5
031A:  MOVWF  07
031B:  NOP
031C:  BCF    03.5
031D:  BCF    07.4
031E:  BCF    2B.4
031F:  MOVF   2B,W
0320:  BSF    03.5
0321:  MOVWF  07
0322:  BCF    03.5
0323:  RETURN
....................  
....................  
.................... #define PCF8574A       // Comment for modules using PCF8574 
.................... #define A2_A1_A0 0B111 // Address pin states (A2 A1 A0) of PCF8574A/PCF8574. 
.................... #define LCD16X2        // Comment this line to use 16x2 LCD 
....................  
.................... #include <global_variables.h> 
.................... #ifndef VAR_H 
.................... #define VAR_H 
....................  
.................... #include <lcd_i2c.c> 
.................... #define RIGHT 0x1C 
.................... #define LEFT 0x18 
....................  
.................... #define CURSOR_ON 2 
.................... #define CURSOR_OFF 0 
....................  
.................... #define BLINK_ON 1 
.................... #define BLINK_OFF 0 
....................  
.................... #define BL_ON 0x08 
.................... #define BL_OFF 0x00 
....................  
.................... #ifdef PCF8574A 
.................... #define pcf_address_write 0x70 | (A2_A1_A0 << 1) 
.................... #define pcf_address_read 0x71 | (A2_A1_A0 << 1) 
.................... #else // PCF8574 
.................... #define pcf_address_write 0x40 | (A2_A1_A0 << 1) 
.................... #define pcf_address_read 0x41 | (A2_A1_A0 << 1) 
.................... #endif 
....................  
.................... #ifdef LCD20X4 
.................... #define line1_start 0x00 
.................... #define line1_end 0x13 
....................  
.................... #define line2_start 0x40 
.................... #define line2_end 0x53 
....................  
.................... #define line3_start 0x14 
.................... #define line3_end 0x27 
....................  
.................... #define line4_start 0x54 
.................... #define line4_end 0x67 
....................  
.................... #define line1_start_command 0x80 
.................... #define line2_start_command 0xC0 
.................... #define line3_start_command 0x94 
.................... #define line4_start_command 0xD4 
.................... #else LCD16X2 
.................... #define line1_start 0x00 
.................... #define line1_end 0x27 
....................  
.................... #define line2_start 0x40 
.................... #define line2_end 0x67 
....................  
.................... #define line1_start_command 0x80 
.................... #define line2_start_command 0xC0 
.................... #endif 
....................  
.................... int backlight_lcd_i2c = 0x08, lcd_i2c_line = 1; 
....................  
.................... void initialize_lcd_i2c() 
.................... { 
....................     i2c_start();                  // Start communication 
*
01DD:  BSF    2B.4
01DE:  MOVF   2B,W
01DF:  BSF    03.5
01E0:  MOVWF  07
01E1:  NOP
01E2:  BCF    03.5
01E3:  BSF    2B.3
01E4:  MOVF   2B,W
01E5:  BSF    03.5
01E6:  MOVWF  07
01E7:  NOP
01E8:  BCF    03.5
01E9:  BCF    07.4
01EA:  BCF    2B.4
01EB:  MOVF   2B,W
01EC:  BSF    03.5
01ED:  MOVWF  07
01EE:  NOP
01EF:  BCF    03.5
01F0:  BCF    07.3
01F1:  BCF    2B.3
01F2:  MOVF   2B,W
01F3:  BSF    03.5
01F4:  MOVWF  07
....................     i2c_write(pcf_address_write); // Send PCF address + WRITE bit 
01F5:  MOVLW  7E
01F6:  BCF    03.5
01F7:  MOVWF  64
01F8:  CALL   193
....................     i2c_write(0x2C);              // Configure LCD for 4 bits/BL ON/En 1 
01F9:  MOVLW  2C
01FA:  MOVWF  64
01FB:  CALL   193
....................     i2c_write(0x28);              // En 0 to execute instruction 
01FC:  MOVLW  28
01FD:  MOVWF  64
01FE:  CALL   193
....................  
....................     delay_us(40);    // Verify the delay for bits to be sent 
01FF:  MOVLW  27
0200:  MOVWF  77
0201:  DECFSZ 77,F
0202:  GOTO   201
0203:  GOTO   204
....................     i2c_write(0x2C); // Send first nibble of 
0204:  MOVLW  2C
0205:  MOVWF  64
0206:  CALL   193
....................     i2c_write(0x28); // the "Function Set" instruction. 
0207:  MOVLW  28
0208:  MOVWF  64
0209:  CALL   193
....................     i2c_write(0x8C); // Send second nibble of the instruction. 
020A:  MOVLW  8C
020B:  MOVWF  64
020C:  CALL   193
....................     i2c_write(0x88); // 4 bits, 2 lines, font 5*8. 
020D:  MOVLW  88
020E:  MOVWF  64
020F:  CALL   193
....................  
....................     delay_us(40); 
0210:  MOVLW  27
0211:  MOVWF  77
0212:  DECFSZ 77,F
0213:  GOTO   212
0214:  GOTO   215
....................  
....................     i2c_write(0x0C); // Send first nibble of 
0215:  MOVLW  0C
0216:  MOVWF  64
0217:  CALL   193
....................     i2c_write(0x08); // "Display ON/OFF control" instruction. 
0218:  MOVLW  08
0219:  MOVWF  64
021A:  CALL   193
....................     i2c_write(0xCC); // Send second nibble of the instruction. 
021B:  MOVLW  CC
021C:  MOVWF  64
021D:  CALL   193
....................     i2c_write(0xC8); // Display on, cursor off, blink off. 
021E:  MOVLW  C8
021F:  MOVWF  64
0220:  CALL   193
....................     delay_us(1); 
0221:  GOTO   222
0222:  NOP
....................  
....................     i2c_write(0x0C); // Send first nibble of 
0223:  MOVLW  0C
0224:  MOVWF  64
0225:  CALL   193
....................     i2c_write(0x08); // "Entry Mode Set" instruction. 
0226:  MOVLW  08
0227:  MOVWF  64
0228:  CALL   193
....................     i2c_write(0x6C); // Send second nibble of the instruction. 
0229:  MOVLW  6C
022A:  MOVWF  64
022B:  CALL   193
....................     i2c_write(0x68); // Increment cursor with each write 
022C:  MOVLW  68
022D:  MOVWF  64
022E:  CALL   193
....................                      // (position+=1), LCD scroll disabled; 
....................                      // if enabled, display scrolls with each character. 
....................     delay_us(40); 
022F:  MOVLW  27
0230:  MOVWF  77
0231:  DECFSZ 77,F
0232:  GOTO   231
0233:  GOTO   234
....................  
....................     i2c_stop(); 
0234:  BCF    2B.4
0235:  MOVF   2B,W
0236:  BSF    03.5
0237:  MOVWF  07
0238:  NOP
0239:  BCF    03.5
023A:  BSF    2B.3
023B:  MOVF   2B,W
023C:  BSF    03.5
023D:  MOVWF  07
023E:  BCF    03.5
023F:  BTFSS  07.3
0240:  GOTO   23F
0241:  NOP
0242:  GOTO   243
0243:  NOP
0244:  BSF    2B.4
0245:  MOVF   2B,W
0246:  BSF    03.5
0247:  MOVWF  07
0248:  NOP
0249:  BCF    03.5
024A:  BCF    0A.3
024B:  BCF    0A.4
024C:  GOTO   5A6 (RETURN)
.................... } 
.................... void send_lcd_i2c_command(char character) 
.................... { 
....................     int ms_nibble_e, ls_nibble_e, ms_nibble, ls_nibble; 
....................  
....................     ms_nibble = character & 0xF0;   // Most significant nibble of the character. 
*
0256:  MOVF   5F,W
0257:  ANDLW  F0
0258:  MOVWF  62
....................     ls_nibble = character & 0x0F;   // Least significant nibble of the character. 
0259:  MOVF   5F,W
025A:  ANDLW  0F
025B:  MOVWF  63
....................     swap(ls_nibble);                // Swap as the most significant bits are used (D7: D4). 
025C:  SWAPF  63,F
....................     ms_nibble |= backlight_lcd_i2c; // Add BL to the most significant nibble 
025D:  MOVF   2C,W
025E:  IORWF  62,F
....................     ls_nibble |= backlight_lcd_i2c; // Add BL to the least significant nibble 
025F:  MOVF   2C,W
0260:  IORWF  63,F
....................  
....................     ms_nibble_e = ms_nibble | 0x04; // Most significant nibble En 1 
0261:  MOVF   62,W
0262:  IORLW  04
0263:  MOVWF  60
....................     ls_nibble_e = ls_nibble | 0x04; // Least significant nibble En 1 
0264:  MOVF   63,W
0265:  IORLW  04
0266:  MOVWF  61
....................  
....................     i2c_start(); 
0267:  BSF    2B.4
0268:  MOVF   2B,W
0269:  BSF    03.5
026A:  MOVWF  07
026B:  NOP
026C:  BCF    03.5
026D:  BSF    2B.3
026E:  MOVF   2B,W
026F:  BSF    03.5
0270:  MOVWF  07
0271:  NOP
0272:  BCF    03.5
0273:  BCF    07.4
0274:  BCF    2B.4
0275:  MOVF   2B,W
0276:  BSF    03.5
0277:  MOVWF  07
0278:  NOP
0279:  BCF    03.5
027A:  BCF    07.3
027B:  BCF    2B.3
027C:  MOVF   2B,W
027D:  BSF    03.5
027E:  MOVWF  07
....................     i2c_write(pcf_address_write); 
027F:  MOVLW  7E
0280:  BCF    03.5
0281:  MOVWF  64
0282:  CALL   193
....................  
....................     i2c_write(ms_nibble_e); // Send 1st nibble with "E" set 
0283:  MOVF   60,W
0284:  MOVWF  64
0285:  CALL   193
....................     i2c_write(ms_nibble);   // Send 1st nibble with "E" cleared 
0286:  MOVF   62,W
0287:  MOVWF  64
0288:  CALL   193
....................  
....................     i2c_write(ls_nibble_e); // Send 2nd nibble with "E" set 
0289:  MOVF   61,W
028A:  MOVWF  64
028B:  CALL   193
....................     i2c_write(ls_nibble);   // Send 2nd nibble with "E" cleared 
028C:  MOVF   63,W
028D:  MOVWF  64
028E:  CALL   193
....................  
....................     i2c_stop(); 
028F:  BCF    2B.4
0290:  MOVF   2B,W
0291:  BSF    03.5
0292:  MOVWF  07
0293:  NOP
0294:  BCF    03.5
0295:  BSF    2B.3
0296:  MOVF   2B,W
0297:  BSF    03.5
0298:  MOVWF  07
0299:  BCF    03.5
029A:  BTFSS  07.3
029B:  GOTO   29A
029C:  NOP
029D:  GOTO   29E
029E:  NOP
029F:  BSF    2B.4
02A0:  MOVF   2B,W
02A1:  BSF    03.5
02A2:  MOVWF  07
02A3:  NOP
....................     delay_us(44); 
02A4:  MOVLW  2B
02A5:  MOVWF  77
02A6:  DECFSZ 77,F
02A7:  GOTO   2A6
02A8:  GOTO   2A9
02A9:  BCF    03.5
02AA:  RETURN
.................... } 
.................... void send_lcd_i2c_character(int character) 
.................... { 
....................     int ms_nibble_e, ls_nibble_e, ms_nibble, ls_nibble; 
....................  
....................     ms_nibble = character & 0xF0; // Most significant nibble of the character. 
*
041B:  MOVF   5F,W
041C:  ANDLW  F0
041D:  MOVWF  62
....................     ls_nibble = character & 0x0F; // Least significant nibble of the character. 
041E:  MOVF   5F,W
041F:  ANDLW  0F
0420:  MOVWF  63
....................     swap(ls_nibble);              // Swap as the most significant bits are used (D7: D4). 
0421:  SWAPF  63,F
....................  
....................     ms_nibble |= backlight_lcd_i2c; // Add BL to the most significant nibble 
0422:  MOVF   2C,W
0423:  IORWF  62,F
....................     ls_nibble |= backlight_lcd_i2c; // Add BL to the least significant nibble 
0424:  MOVF   2C,W
0425:  IORWF  63,F
....................     ms_nibble++;                    // Set RS bit 
0426:  INCF   62,F
....................     ls_nibble++;                    // Set RS bit 
0427:  INCF   63,F
....................  
....................     ms_nibble_e = ms_nibble | 0x05; // Most significant nibble En and RS = 1 
0428:  MOVF   62,W
0429:  IORLW  05
042A:  MOVWF  60
....................     ls_nibble_e = ls_nibble | 0x05; // Least significant nibble En and RS = 1 
042B:  MOVF   63,W
042C:  IORLW  05
042D:  MOVWF  61
....................  
....................     i2c_start(); 
042E:  BSF    2B.4
042F:  MOVF   2B,W
0430:  BSF    03.5
0431:  MOVWF  07
0432:  NOP
0433:  BCF    03.5
0434:  BSF    2B.3
0435:  MOVF   2B,W
0436:  BSF    03.5
0437:  MOVWF  07
0438:  NOP
0439:  BCF    03.5
043A:  BCF    07.4
043B:  BCF    2B.4
043C:  MOVF   2B,W
043D:  BSF    03.5
043E:  MOVWF  07
043F:  NOP
0440:  BCF    03.5
0441:  BCF    07.3
0442:  BCF    2B.3
0443:  MOVF   2B,W
0444:  BSF    03.5
0445:  MOVWF  07
....................     i2c_write(pcf_address_write); 
0446:  MOVLW  7E
0447:  BCF    03.5
0448:  MOVWF  64
0449:  CALL   193
....................  
....................     i2c_write(ms_nibble_e); // Send 1st nibble with RS and En 1 
044A:  MOVF   60,W
044B:  MOVWF  64
044C:  CALL   193
....................     i2c_write(ms_nibble);   // Send 1st nibble with RS 1 and E 0 
044D:  MOVF   62,W
044E:  MOVWF  64
044F:  CALL   193
....................  
....................     i2c_write(ls_nibble_e); // Send 2nd nibble with RS and E 1 
0450:  MOVF   61,W
0451:  MOVWF  64
0452:  CALL   193
....................     i2c_write(ls_nibble);   // Send 2nd nibble with RS 0 and E 0 
0453:  MOVF   63,W
0454:  MOVWF  64
0455:  CALL   193
....................  
....................     i2c_stop(); 
0456:  BCF    2B.4
0457:  MOVF   2B,W
0458:  BSF    03.5
0459:  MOVWF  07
045A:  NOP
045B:  BCF    03.5
045C:  BSF    2B.3
045D:  MOVF   2B,W
045E:  BSF    03.5
045F:  MOVWF  07
0460:  BCF    03.5
0461:  BTFSS  07.3
0462:  GOTO   461
0463:  NOP
0464:  GOTO   465
0465:  NOP
0466:  BSF    2B.4
0467:  MOVF   2B,W
0468:  BSF    03.5
0469:  MOVWF  07
046A:  NOP
....................     delay_us(44); 
046B:  MOVLW  2B
046C:  MOVWF  77
046D:  DECFSZ 77,F
046E:  GOTO   46D
046F:  GOTO   470
.................... } 
.................... void clear_lcd_i2c() 
.................... { 
....................     send_lcd_i2c_command(0x01); 
*
02C0:  MOVLW  01
02C1:  MOVWF  5F
02C2:  CALL   256
....................     delay_ms(2); 
02C3:  MOVLW  02
02C4:  MOVWF  55
02C5:  CALL   2AB
02C6:  RETURN
.................... } 
.................... int read_cursor_address() 
.................... { 
....................     int aux, aux2, address; 
....................  
....................     aux = 0xF2 | backlight_lcd_i2c; // Set PCF pins for D7:D4 of LCD E=0 | RW=1 | RS=0. 
*
033C:  MOVF   2C,W
033D:  IORLW  F2
033E:  MOVWF  5F
....................     aux2 = aux;                     // Copy aux value 
033F:  MOVF   5F,W
0340:  MOVWF  60
....................  
....................     i2c_start(); 
0341:  BSF    2B.4
0342:  MOVF   2B,W
0343:  BSF    03.5
0344:  MOVWF  07
0345:  NOP
0346:  BCF    03.5
0347:  BSF    2B.3
0348:  MOVF   2B,W
0349:  BSF    03.5
034A:  MOVWF  07
034B:  NOP
034C:  BCF    03.5
034D:  BCF    07.4
034E:  BCF    2B.4
034F:  MOVF   2B,W
0350:  BSF    03.5
0351:  MOVWF  07
0352:  NOP
0353:  BCF    03.5
0354:  BCF    07.3
0355:  BCF    2B.3
0356:  MOVF   2B,W
0357:  BSF    03.5
0358:  MOVWF  07
....................     i2c_write(pcf_address_write); 
0359:  MOVLW  7E
035A:  BCF    03.5
035B:  MOVWF  64
035C:  CALL   193
....................     i2c_write(aux);        // Set PCF pins for D7:D4 of LCD E=0 | RW=1 | RS=0. 
035D:  MOVF   5F,W
035E:  MOVWF  64
035F:  CALL   193
....................     i2c_write(aux | 0x04); // En=1 for LCD to provide most significant nibble. 
0360:  MOVF   5F,W
0361:  IORLW  04
0362:  MOVWF  62
0363:  MOVWF  64
0364:  CALL   193
....................     i2c_start(); 
0365:  BSF    2B.4
0366:  MOVF   2B,W
0367:  BSF    03.5
0368:  MOVWF  07
0369:  NOP
036A:  BCF    03.5
036B:  BSF    2B.3
036C:  MOVF   2B,W
036D:  BSF    03.5
036E:  MOVWF  07
036F:  NOP
0370:  BCF    03.5
0371:  BTFSS  07.3
0372:  GOTO   371
0373:  BCF    07.4
0374:  BCF    2B.4
0375:  MOVF   2B,W
0376:  BSF    03.5
0377:  MOVWF  07
0378:  NOP
0379:  BCF    03.5
037A:  BCF    07.3
037B:  BCF    2B.3
037C:  MOVF   2B,W
037D:  BSF    03.5
037E:  MOVWF  07
....................     i2c_write(pcf_address_read); 
037F:  MOVLW  7F
0380:  BCF    03.5
0381:  MOVWF  64
0382:  CALL   193
....................     address = 0x70 & i2c_read(0); // Read most significant nibble with mask 0x70. 
0383:  CLRF   77
0384:  CALL   2DF
0385:  MOVF   78,W
0386:  ANDLW  70
0387:  MOVWF  61
....................     i2c_start(); 
0388:  BSF    2B.4
0389:  MOVF   2B,W
038A:  BSF    03.5
038B:  MOVWF  07
038C:  NOP
038D:  BCF    03.5
038E:  BSF    2B.3
038F:  MOVF   2B,W
0390:  BSF    03.5
0391:  MOVWF  07
0392:  NOP
0393:  BCF    03.5
0394:  BTFSS  07.3
0395:  GOTO   394
0396:  BCF    07.4
0397:  BCF    2B.4
0398:  MOVF   2B,W
0399:  BSF    03.5
039A:  MOVWF  07
039B:  NOP
039C:  BCF    03.5
039D:  BCF    07.3
039E:  BCF    2B.3
039F:  MOVF   2B,W
03A0:  BSF    03.5
03A1:  MOVWF  07
....................     i2c_write(pcf_address_write); 
03A2:  MOVLW  7E
03A3:  BCF    03.5
03A4:  MOVWF  64
03A5:  CALL   193
....................     i2c_write(aux);        // Clear Enable pin of LCD 
03A6:  MOVF   5F,W
03A7:  MOVWF  64
03A8:  CALL   193
....................     i2c_write(aux | 0x04); // Set Enable pin of LCD to provide least significant nibble. 
03A9:  MOVF   5F,W
03AA:  IORLW  04
03AB:  MOVWF  62
03AC:  MOVWF  64
03AD:  CALL   193
....................     i2c_start(); 
03AE:  BSF    2B.4
03AF:  MOVF   2B,W
03B0:  BSF    03.5
03B1:  MOVWF  07
03B2:  NOP
03B3:  BCF    03.5
03B4:  BSF    2B.3
03B5:  MOVF   2B,W
03B6:  BSF    03.5
03B7:  MOVWF  07
03B8:  NOP
03B9:  BCF    03.5
03BA:  BTFSS  07.3
03BB:  GOTO   3BA
03BC:  BCF    07.4
03BD:  BCF    2B.4
03BE:  MOVF   2B,W
03BF:  BSF    03.5
03C0:  MOVWF  07
03C1:  NOP
03C2:  BCF    03.5
03C3:  BCF    07.3
03C4:  BCF    2B.3
03C5:  MOVF   2B,W
03C6:  BSF    03.5
03C7:  MOVWF  07
....................     i2c_write(pcf_address_read); 
03C8:  MOVLW  7F
03C9:  BCF    03.5
03CA:  MOVWF  64
03CB:  CALL   193
....................     aux = 0xF0 & i2c_read(0); // Read least significant nibble with mask 0xF0. 
03CC:  CLRF   77
03CD:  CALL   2DF
03CE:  MOVF   78,W
03CF:  ANDLW  F0
03D0:  MOVWF  5F
....................     i2c_start(); 
03D1:  BSF    2B.4
03D2:  MOVF   2B,W
03D3:  BSF    03.5
03D4:  MOVWF  07
03D5:  NOP
03D6:  BCF    03.5
03D7:  BSF    2B.3
03D8:  MOVF   2B,W
03D9:  BSF    03.5
03DA:  MOVWF  07
03DB:  NOP
03DC:  BCF    03.5
03DD:  BTFSS  07.3
03DE:  GOTO   3DD
03DF:  BCF    07.4
03E0:  BCF    2B.4
03E1:  MOVF   2B,W
03E2:  BSF    03.5
03E3:  MOVWF  07
03E4:  NOP
03E5:  BCF    03.5
03E6:  BCF    07.3
03E7:  BCF    2B.3
03E8:  MOVF   2B,W
03E9:  BSF    03.5
03EA:  MOVWF  07
....................     i2c_write(pcf_address_write); 
03EB:  MOVLW  7E
03EC:  BCF    03.5
03ED:  MOVWF  64
03EE:  CALL   193
....................     i2c_write(aux2); // Clear Enable pin first 
03EF:  MOVF   60,W
03F0:  MOVWF  64
03F1:  CALL   193
....................     aux2 &= 0xF8; 
03F2:  MOVLW  F8
03F3:  ANDWF  60,F
....................     i2c_write(aux2); // Clear RW pin to exit read mode. 
03F4:  MOVF   60,W
03F5:  MOVWF  64
03F6:  CALL   193
....................     i2c_stop(); 
03F7:  BCF    2B.4
03F8:  MOVF   2B,W
03F9:  BSF    03.5
03FA:  MOVWF  07
03FB:  NOP
03FC:  BCF    03.5
03FD:  BSF    2B.3
03FE:  MOVF   2B,W
03FF:  BSF    03.5
0400:  MOVWF  07
0401:  BCF    03.5
0402:  BTFSS  07.3
0403:  GOTO   402
0404:  NOP
0405:  GOTO   406
0406:  NOP
0407:  BSF    2B.4
0408:  MOVF   2B,W
0409:  BSF    03.5
040A:  MOVWF  07
040B:  NOP
....................  
....................     swap(aux);      // Position least significant nibble correctly. 
040C:  BCF    03.5
040D:  SWAPF  5F,F
....................     address |= aux; // OR operation between least and most significant nibble. 
040E:  MOVF   5F,W
040F:  IORWF  61,F
....................     delay_us(45); 
0410:  MOVLW  2C
0411:  MOVWF  77
0412:  DECFSZ 77,F
0413:  GOTO   412
0414:  GOTO   415
....................     return (address); // Return current cursor address. 
0415:  MOVF   61,W
0416:  MOVWF  78
.................... } 
.................... void write_lcd_i2c(char character) 
.................... { 
....................     int cursor_address; 
....................  
....................     if (character == '\n') 
*
0324:  MOVF   5D,W
0325:  SUBLW  0A
0326:  BTFSS  03.2
0327:  GOTO   33C
....................     {          // Position cursor at the start of the next line. 
.................... #ifdef LCD20X4 // Using LCD 20 x 4 
....................         switch (lcd_i2c_line) 
....................         { 
....................         case 1: 
....................             send_lcd_i2c_command(line2_start_command); 
....................             lcd_i2c_line = 2; 
....................             break; 
....................         case 2: 
....................             send_lcd_i2c_command(line3_start_command); 
....................             lcd_i2c_line = 3; 
....................             break; 
....................         case 3: 
....................             send_lcd_i2c_command(line4_start_command); 
....................             lcd_i2c_line = 4; 
....................             break; 
....................         case 4: 
....................             send_lcd_i2c_command(line1_start_command); 
....................             lcd_i2c_line = 1; 
....................             break; 
....................         } 
.................... #else // Using LCD 16 x 2 
....................         switch (lcd_i2c_line) 
0328:  MOVF   2D,W
0329:  XORLW  01
032A:  BTFSC  03.2
032B:  GOTO   330
032C:  XORLW  03
032D:  BTFSC  03.2
032E:  GOTO   336
032F:  GOTO   33B
....................         { 
....................         case 1: 
....................             send_lcd_i2c_command(line2_start_command); 
0330:  MOVLW  C0
0331:  MOVWF  5F
0332:  CALL   256
....................             lcd_i2c_line = 2; 
0333:  MOVLW  02
0334:  MOVWF  2D
....................             break; 
0335:  GOTO   33B
....................         case 2: 
....................             send_lcd_i2c_command(line1_start_command); 
0336:  MOVLW  80
0337:  MOVWF  5F
0338:  CALL   256
....................             lcd_i2c_line = 1; 
0339:  MOVLW  01
033A:  MOVWF  2D
....................             break; 
....................         } 
.................... #endif 
....................     } 
033B:  GOTO   48C
....................     else 
....................     { 
....................         cursor_address = read_cursor_address(); 
*
0417:  MOVF   78,W
0418:  MOVWF  5E
....................         send_lcd_i2c_character(character); 
0419:  MOVF   5D,W
041A:  MOVWF  5F
.................... #ifdef LCD20X4 // Using LCD 20 x 4 
....................         switch (lcd_i2c_line) 
....................         { 
....................         case 1: 
....................             if (cursor_address == line1_end) 
....................             { 
....................                 send_lcd_i2c_command(line2_start_command); 
....................                 lcd_i2c_line = 2; 
....................             } 
....................             break; 
....................         case 2: 
....................             if (cursor_address == line2_end) 
....................             { 
....................                 send_lcd_i2c_command(line3_start_command); 
....................                 lcd_i2c_line = 3; 
....................             } 
....................             break; 
....................         case 3: 
....................             if (cursor_address == line3_end) 
....................             { 
....................                 send_lcd_i2c_command(line4_start_command); 
....................                 lcd_i2c_line = 4; 
....................             } 
....................             break; 
....................         case 4: 
....................             if (cursor_address == line4_end) 
....................             { 
....................                 send_lcd_i2c_command(line1_start_command); 
....................                 lcd_i2c_line = 1; 
....................             } 
....................             break; 
....................         } 
.................... #else // Using LCD 16 x 2 
....................         switch (lcd_i2c_line) 
*
0470:  BCF    03.5
0471:  MOVF   2D,W
0472:  XORLW  01
0473:  BTFSC  03.2
0474:  GOTO   479
0475:  XORLW  03
0476:  BTFSC  03.2
0477:  GOTO   483
0478:  GOTO   48C
....................         { 
....................         case 1: 
....................             if (cursor_address == line1_end) 
0479:  MOVF   5E,W
047A:  SUBLW  27
047B:  BTFSS  03.2
047C:  GOTO   482
....................             { 
....................                 send_lcd_i2c_command(line2_start_command); 
047D:  MOVLW  C0
047E:  MOVWF  5F
047F:  CALL   256
....................                 lcd_i2c_line = 2; 
0480:  MOVLW  02
0481:  MOVWF  2D
....................             } 
....................             break; 
0482:  GOTO   48C
....................         case 2: 
....................             if (cursor_address == line2_end) 
0483:  MOVF   5E,W
0484:  SUBLW  67
0485:  BTFSS  03.2
0486:  GOTO   48C
....................             { 
....................                 send_lcd_i2c_command(line1_start_command); 
0487:  MOVLW  80
0488:  MOVWF  5F
0489:  CALL   256
....................                 lcd_i2c_line = 1; 
048A:  MOVLW  01
048B:  MOVWF  2D
....................             } 
....................             break; 
....................         } 
.................... #endif 
....................     } 
048C:  RETURN
.................... } 
.................... void send_lcd_i2c_string(char *string) 
.................... { 
....................     while (*string) 
....................         write_lcd_i2c(*string++); 
.................... } 
.................... void set_lcd_i2c_cursor_position(char x, char y) 
.................... { 
....................     switch (x) 
*
02C7:  MOVF   54,W
02C8:  XORLW  01
02C9:  BTFSC  03.2
02CA:  GOTO   2CF
02CB:  XORLW  03
02CC:  BTFSC  03.2
02CD:  GOTO   2D7
02CE:  GOTO   2DE
....................     { 
....................     case 1:                                            // Line 1 
....................         send_lcd_i2c_command(line1_start_command + y); // Position command. 
02CF:  MOVLW  80
02D0:  ADDWF  55,W
02D1:  MOVWF  56
02D2:  MOVWF  5F
02D3:  CALL   256
....................         lcd_i2c_line = 1;                              // Assign current line for write control. 
02D4:  MOVLW  01
02D5:  MOVWF  2D
....................         break; 
02D6:  GOTO   2DE
....................     case 2:                                            // Line 2 
....................         send_lcd_i2c_command(line2_start_command + y); // Position command. 
02D7:  MOVLW  C0
02D8:  ADDWF  55,W
02D9:  MOVWF  56
02DA:  MOVWF  5F
02DB:  CALL   256
....................         lcd_i2c_line = 2;                              // Assign current line for write control. 
02DC:  MOVLW  02
02DD:  MOVWF  2D
....................         break; 
.................... #ifdef LCD20X4                                 // Using LCD 20 x 4 
....................     case 3:                                    // Line 3 
....................         send_lcd_i2c_command(line3_start + y); // Position command. 
....................         lcd_i2c_line = 3;                      // Assign current line for write control. 
....................         break; 
....................     case 4:                                    // Line 4 
....................         send_lcd_i2c_command(line4_start + y); // Position command. 
....................         lcd_i2c_line = 4;                      // Assign current line for write control. 
....................         break; 
.................... #endif 
....................     } 
02DE:  RETURN
.................... } 
.................... void configure_lcd_i2c(int cursor, int blink, int backlight) 
.................... { 
....................     int aux; 
....................     backlight_lcd_i2c = 0x08 * backlight; // Set backlight status. 
....................  
....................     aux = 0x08 | (cursor << 1) | blink; // Combine bits to form the control byte 
....................     send_lcd_i2c_command(aux);          // Send control command to the LCD 
.................... } 
....................  
....................  
.................... const unsigned int16 DOT_DURATION = 200; 
.................... const unsigned int16 DASH_DURATION = 600; 
....................  
.................... const int8 SW_Pin[] = {Pin_B0, Pin_B1, Pin_B2, Pin_B3, Pin_B4}; 
.................... // int8 SW_Pin = Pin_B0; // Assuming only one button for Morse code input 
....................  
.................... const int8 LED_Pin = Pin_D0; 
.................... const int8 Buzzer_Pin = Pin_D1; 
....................  
.................... unsigned int16 elapsedTime = 0; 
....................  
.................... unsigned int8 morseCodeBufferString[6]; 
.................... unsigned int8 morseCodeBufferIndex = 0; 
....................  
.................... unsigned int8 morseCodeString[16]; 
.................... unsigned int8 morseCodeStringIndex = 0; 
....................  
.................... typedef struct 
.................... { 
....................     char morseCode[6]; 
....................     char character; 
.................... } MorseCode; 
....................  
.................... const MorseCode morseCodeTable[] = { 
....................     {".-", 'A'}, // 
....................     {"-...", 'B'}, 
....................     {"-.-.", 'C'}, 
....................     {"-..", 'D'}, 
....................     {".", 'E'}, 
....................     {"..-.", 'F'}, 
....................     {"--.", 'G'}, 
....................     {"....", 'H'}, 
....................     {"..", 'I'}, 
....................     {".---", 'J'}, 
....................     {"-.-", 'K'}, 
....................     {".-..", 'L'}, 
....................     {"--", 'M'}, 
....................     {"-.", 'N'}, 
....................     {"---", 'O'}, 
....................     {".--.", 'P'}, 
....................     {"--.-", 'Q'}, 
....................     {".-.", 'R'}, 
....................     {"...", 'S'}, 
....................     {"-", 'T'}, 
....................     {"..-", 'U'}, 
....................     {"...-", 'V'}, 
....................     {".--", 'W'}, 
....................     {"-..-", 'X'}, 
....................     {"-.--", 'Y'}, 
....................     {"--..", 'Z'}, 
....................     {"-----", '0'}, 
....................     {".----", '1'}, 
....................     {"..---", '2'}, 
....................     {"...--", '3'}, 
....................     {"....-", '4'}, 
....................     {".....", '5'}, 
....................     {"-....", '6'}, 
....................     {"--...", '7'}, 
....................     {"---..", '8'}, 
....................     {"----.", '9'}}; 
....................  
.................... typedef enum 
.................... { 
....................     BUTTON_MODE, 
....................     UART_MODE 
.................... } Mode; 
....................  
.................... Mode inputMode = BUTTON_MODE; 
....................  
.................... #INT_TIMER1 
.................... void An389_Interrupt() 
.................... { 
....................     elapsedTime++; 
*
015F:  INCF   2E,F
0160:  BTFSC  03.2
0161:  INCF   2F,F
....................     set_timer1(65036); 
0162:  CLRF   0E
0163:  MOVLW  FE
0164:  MOVWF  0F
0165:  MOVLW  0C
0166:  MOVWF  0E
....................     clear_interrupt(INT_TIMER1); 
0167:  BCF    0C.0
0168:  BCF    0C.0
0169:  BCF    0A.3
016A:  BCF    0A.4
016B:  GOTO   02D
.................... } 
....................  
.................... void startTimer() 
.................... { 
....................     elapsedTime = 0; 
*
04E3:  CLRF   2F
04E4:  CLRF   2E
....................  
....................     // setup timer1, 1ms interrupt, 16MHz, timer1 16 bit, prescaler 1:8 
....................     // 16MHz / 4 = 4MHz 
....................     // 4MHz / 8 = 500KHz 
....................     // 1 / 500KHz = 2us 
....................     // 1ms / 2us = 500 
....................     // 65536 - 500 = 65036 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
04E5:  MOVLW  35
04E6:  MOVWF  10
....................     set_timer1(65036); 
04E7:  CLRF   0E
04E8:  MOVLW  FE
04E9:  MOVWF  0F
04EA:  MOVLW  0C
04EB:  MOVWF  0E
....................     enable_interrupts(INT_TIMER1); 
04EC:  BSF    03.5
04ED:  BSF    0C.0
....................     enable_interrupts(GLOBAL); 
04EE:  MOVLW  C0
04EF:  BCF    03.5
04F0:  IORWF  0B,F
04F1:  RETURN
.................... } 
....................  
.................... unsigned int16 getTimerValue() 
.................... { 
....................     return elapsedTime; 
*
0AB9:  MOVF   2E,W
0ABA:  MOVWF  78
0ABB:  MOVF   2F,W
0ABC:  MOVWF  79
.................... } 
....................  
.................... unsigned int16 stopAndReadTimer() 
.................... { 
....................     disable_interrupts(INT_TIMER1); 
*
04F2:  BSF    03.5
04F3:  BCF    0C.0
....................     disable_interrupts(GLOBAL); 
04F4:  BCF    03.5
04F5:  BCF    0B.6
04F6:  BCF    0B.7
04F7:  BTFSC  0B.7
04F8:  GOTO   4F6
....................     return elapsedTime; 
04F9:  MOVF   2E,W
04FA:  MOVWF  78
04FB:  MOVF   2F,W
04FC:  MOVWF  79
04FD:  RETURN
.................... } 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
089F:  MOVF   55,W
08A0:  MOVWF  7A
08A1:  MOVF   54,W
08A2:  MOVWF  04
08A3:  BCF    03.7
08A4:  BTFSC  7A.0
08A5:  BSF    03.7
08A6:  MOVF   00,W
08A7:  MOVWF  58
08A8:  MOVF   57,W
08A9:  MOVWF  7A
08AA:  MOVF   56,W
08AB:  MOVWF  04
08AC:  BCF    03.7
08AD:  BTFSC  7A.0
08AE:  BSF    03.7
08AF:  MOVF   00,W
08B0:  SUBWF  58,W
08B1:  BTFSS  03.2
08B2:  GOTO   0CA
....................       if (*s1 == '\0') 
08B3:  MOVF   55,W
08B4:  MOVWF  7A
08B5:  MOVF   54,W
08B6:  MOVWF  04
08B7:  BCF    03.7
08B8:  BTFSC  7A.0
08B9:  BSF    03.7
08BA:  MOVF   00,F
08BB:  BTFSS  03.2
08BC:  GOTO   0C0
....................          return(0); 
08BD:  MOVLW  00
08BE:  MOVWF  78
08BF:  GOTO   0E2
08C0:  MOVF   55,W
08C1:  MOVWF  7A
08C2:  MOVF   54,W
08C3:  INCF   54,F
08C4:  BTFSC  03.2
08C5:  INCF   55,F
08C6:  INCF   56,F
08C7:  BTFSC  03.2
08C8:  INCF   57,F
08C9:  GOTO   09F
....................    return((*s1 < *s2) ? -1: 1); 
08CA:  MOVF   55,W
08CB:  MOVWF  7A
08CC:  MOVF   54,W
08CD:  MOVWF  04
08CE:  BCF    03.7
08CF:  BTFSC  55.0
08D0:  BSF    03.7
08D1:  MOVF   00,W
08D2:  MOVWF  58
08D3:  MOVF   57,W
08D4:  MOVWF  7A
08D5:  MOVF   56,W
08D6:  MOVWF  04
08D7:  BCF    03.7
08D8:  BTFSC  57.0
08D9:  BSF    03.7
08DA:  MOVF   00,W
08DB:  SUBWF  58,W
08DC:  BTFSC  03.0
08DD:  GOTO   0E0
08DE:  MOVLW  FF
08DF:  GOTO   0E1
08E0:  MOVLW  01
08E1:  MOVWF  78
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
05A2:  BCF    03.6
05A3:  CLRF   49
05A4:  CLRF   4A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <morseCodeReader.c> 
.................... #include <global_variables.h> 
.................... #ifndef VAR_H 
.................... #define VAR_H 
....................  
.................... #include <lcd_i2c.c> 
....................  
.................... const unsigned int16 DOT_DURATION = 200; 
.................... const unsigned int16 DASH_DURATION = 600; 
....................  
.................... const int8 SW_Pin[] = {Pin_B0, Pin_B1, Pin_B2, Pin_B3, Pin_B4}; 
.................... // int8 SW_Pin = Pin_B0; // Assuming only one button for Morse code input 
....................  
.................... const int8 LED_Pin = Pin_D0; 
.................... const int8 Buzzer_Pin = Pin_D1; 
....................  
.................... unsigned int16 elapsedTime = 0; 
....................  
.................... unsigned int8 morseCodeBufferString[6]; 
.................... unsigned int8 morseCodeBufferIndex = 0; 
....................  
.................... unsigned int8 morseCodeString[16]; 
.................... unsigned int8 morseCodeStringIndex = 0; 
....................  
.................... typedef struct 
.................... { 
....................     char morseCode[6]; 
....................     char character; 
.................... } MorseCode; 
....................  
.................... const MorseCode morseCodeTable[] = { 
....................     {".-", 'A'}, // 
....................     {"-...", 'B'}, 
....................     {"-.-.", 'C'}, 
....................     {"-..", 'D'}, 
....................     {".", 'E'}, 
....................     {"..-.", 'F'}, 
....................     {"--.", 'G'}, 
....................     {"....", 'H'}, 
....................     {"..", 'I'}, 
....................     {".---", 'J'}, 
....................     {"-.-", 'K'}, 
....................     {".-..", 'L'}, 
....................     {"--", 'M'}, 
....................     {"-.", 'N'}, 
....................     {"---", 'O'}, 
....................     {".--.", 'P'}, 
....................     {"--.-", 'Q'}, 
....................     {".-.", 'R'}, 
....................     {"...", 'S'}, 
....................     {"-", 'T'}, 
....................     {"..-", 'U'}, 
....................     {"...-", 'V'}, 
....................     {".--", 'W'}, 
....................     {"-..-", 'X'}, 
....................     {"-.--", 'Y'}, 
....................     {"--..", 'Z'}, 
....................     {"-----", '0'}, 
....................     {".----", '1'}, 
....................     {"..---", '2'}, 
....................     {"...--", '3'}, 
....................     {"....-", '4'}, 
....................     {".....", '5'}, 
....................     {"-....", '6'}, 
....................     {"--...", '7'}, 
....................     {"---..", '8'}, 
....................     {"----.", '9'}}; 
....................  
.................... typedef enum 
.................... { 
....................     BUTTON_MODE, 
....................     UART_MODE 
.................... } Mode; 
....................  
.................... Mode inputMode = BUTTON_MODE; 
....................  
.................... #INT_TIMER1 
.................... void An389_Interrupt() 
.................... { 
....................     elapsedTime++; 
....................     set_timer1(65036); 
....................     clear_interrupt(INT_TIMER1); 
.................... } 
....................  
.................... void startTimer() 
.................... { 
....................     elapsedTime = 0; 
....................  
....................     // setup timer1, 1ms interrupt, 16MHz, timer1 16 bit, prescaler 1:8 
....................     // 16MHz / 4 = 4MHz 
....................     // 4MHz / 8 = 500KHz 
....................     // 1 / 500KHz = 2us 
....................     // 1ms / 2us = 500 
....................     // 65536 - 500 = 65036 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
....................     set_timer1(65036); 
....................     enable_interrupts(INT_TIMER1); 
....................     enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... unsigned int16 getTimerValue() 
.................... { 
....................     return elapsedTime; 
.................... } 
....................  
.................... unsigned int16 stopAndReadTimer() 
.................... { 
....................     disable_interrupts(INT_TIMER1); 
....................     disable_interrupts(GLOBAL); 
....................     return elapsedTime; 
.................... } 
....................  
.................... #endif 
....................  
.................... // #include <lcd_i2c.c> 
....................  
....................  
.................... void appendMorseCode(char morseChar) 
.................... { 
....................    morseCodeBufferString[morseCodeBufferIndex++] = morseChar; 
*
0850:  MOVF   36,W
0851:  INCF   36,F
0852:  ADDLW  30
0853:  MOVWF  04
0854:  BCF    03.7
0855:  MOVF   50,W
0856:  MOVWF  00
....................    morseCodeBufferString[morseCodeBufferIndex] = '\0'; // Null-terminate the string 
0857:  MOVLW  30
0858:  ADDWF  36,W
0859:  MOVWF  04
085A:  BCF    03.7
085B:  CLRF   00
.................... } 
....................  
.................... void clearMorseCodeBuffer() 
.................... { 
....................    memset(morseCodeBufferString, 0, sizeof(morseCodeBufferString)); 
*
0539:  MOVLW  30
053A:  MOVWF  04
053B:  BCF    03.7
053C:  CLRF   77
053D:  MOVLW  06
053E:  MOVWF  78
053F:  CALL   24D
....................    morseCodeBufferIndex = 0; 
0540:  CLRF   36
0541:  RETURN
.................... } 
....................  
.................... void clearMorseCodeString() 
.................... { 
....................    memset(morseCodeString, 0, sizeof(morseCodeString)); 
*
056F:  MOVLW  37
0570:  MOVWF  04
0571:  BCF    03.7
0572:  CLRF   77
0573:  MOVLW  10
0574:  MOVWF  78
0575:  CALL   24D
....................    morseCodeStringIndex = 0; 
0576:  CLRF   47
.................... } 
....................  
.................... void clearAll() 
.................... { 
....................    clearMorseCodeBuffer(); 
*
056E:  CALL   539
....................    clearMorseCodeString(); 
....................    clear_lcd_i2c(); 
*
0577:  CALL   2C0
0578:  RETURN
.................... } 
....................  
.................... void translateMorseCode() 
.................... { 
....................    for (int i = 0; i < sizeof(morseCodeTable) / sizeof(MorseCode); ++i) 
*
0878:  CLRF   4D
0879:  MOVF   4D,W
087A:  SUBLW  23
087B:  BTFSS  03.0
087C:  GOTO   0FE
....................    { 
....................       char temp[6]; 
....................       strcpy(temp, morseCodeTable[i].morseCode); 
087D:  MOVF   4D,W
087E:  MOVWF  56
087F:  MOVLW  07
0880:  MOVWF  57
0881:  BCF    0A.3
0882:  CALL   514
0883:  BSF    0A.3
0884:  MOVF   78,W
0885:  MOVWF  54
0886:  CLRF   55
0887:  MOVF   54,W
0888:  MOVWF  56
0889:  MOVLW  4E
088A:  MOVWF  04
088B:  BCF    03.7
088C:  MOVF   55,W
088D:  ADDWF  04,F
088E:  MOVF   56,W
088F:  BCF    0A.3
0890:  CALL   051
0891:  BSF    0A.3
0892:  MOVWF  00
0893:  IORLW  00
0894:  BTFSC  03.2
0895:  GOTO   099
0896:  INCF   56,F
0897:  INCF   55,F
0898:  GOTO   089
....................  
....................       if (strcmp(morseCodeBufferString, temp) == 0) 
0899:  CLRF   55
089A:  MOVLW  30
089B:  MOVWF  54
089C:  CLRF   57
089D:  MOVLW  4E
089E:  MOVWF  56
*
08E2:  MOVF   78,F
08E3:  BTFSS  03.2
08E4:  GOTO   0FC
....................       { 
....................          morseCodeString[morseCodeStringIndex++] = morseCodeTable[i].character; 
08E5:  MOVF   47,W
08E6:  INCF   47,F
08E7:  ADDLW  37
08E8:  MOVWF  04
08E9:  BCF    03.7
08EA:  MOVF   4D,W
08EB:  MOVWF  56
08EC:  MOVLW  07
08ED:  MOVWF  57
08EE:  BCF    0A.3
08EF:  CALL   514
08F0:  BSF    0A.3
08F1:  MOVLW  06
08F2:  ADDWF  78,W
08F3:  BCF    0A.3
08F4:  CALL   051
08F5:  BSF    0A.3
08F6:  MOVWF  78
08F7:  MOVWF  00
....................          clearMorseCodeBuffer(); 
08F8:  BCF    0A.3
08F9:  CALL   539
08FA:  BSF    0A.3
....................          return; 
08FB:  GOTO   108
....................       } 
08FC:  INCF   4D,F
08FD:  GOTO   079
....................    } 
....................    morseCodeString[morseCodeStringIndex++] = '?'; 
08FE:  MOVF   47,W
08FF:  INCF   47,F
0900:  ADDLW  37
0901:  MOVWF  04
0902:  BCF    03.7
0903:  MOVLW  3F
0904:  MOVWF  00
....................    clearMorseCodeBuffer(); 
0905:  BCF    0A.3
0906:  CALL   539
0907:  BSF    0A.3
.................... } 
....................  
.................... void recordMorseCode() 
.................... { 
....................    startTimer(); 
*
0807:  BCF    0A.3
0808:  CALL   4E3
0809:  BSF    0A.3
....................    delay_ms(50);           // Debounce 
080A:  MOVLW  32
080B:  MOVWF  55
080C:  BCF    0A.3
080D:  CALL   2AB
080E:  BSF    0A.3
....................    output_high(LED_Pin);   // Turn on LED 
080F:  BSF    03.5
0810:  BCF    08.0
0811:  BCF    03.5
0812:  BSF    08.0
....................    output_low(Buzzer_Pin); // Turn on buzzer 
0813:  BSF    03.5
0814:  BCF    08.1
0815:  BCF    03.5
0816:  BCF    08.1
....................  
....................    while (input(SW_Pin[0]) == 0) 
0817:  BSF    03.5
0818:  BSF    06.0
0819:  BCF    03.5
081A:  BTFSC  06.0
081B:  GOTO   030
....................    { 
....................       if (elapsedTime > DASH_DURATION) 
081C:  MOVF   2F,W
081D:  SUBLW  01
081E:  BTFSC  03.0
081F:  GOTO   02F
0820:  XORLW  FF
0821:  BTFSS  03.2
0822:  GOTO   027
0823:  MOVF   2E,W
0824:  SUBLW  58
0825:  BTFSC  03.0
0826:  GOTO   02F
....................       { 
....................          output_low(LED_Pin);     // Turn off led 
0827:  BSF    03.5
0828:  BCF    08.0
0829:  BCF    03.5
082A:  BCF    08.0
....................          output_high(Buzzer_Pin); // Turn off buzzer 
082B:  BSF    03.5
082C:  BCF    08.1
082D:  BCF    03.5
082E:  BSF    08.1
....................       } 
082F:  GOTO   017
....................    } 
....................  
....................    output_low(LED_Pin);     // Turn off LED 
0830:  BSF    03.5
0831:  BCF    08.0
0832:  BCF    03.5
0833:  BCF    08.0
....................    output_high(Buzzer_Pin); // Turn off buzzer 
0834:  BSF    03.5
0835:  BCF    08.1
0836:  BCF    03.5
0837:  BSF    08.1
....................  
....................    unsigned int16 duration = stopAndReadTimer(); 
0838:  BCF    0A.3
0839:  CALL   4F2
083A:  BSF    0A.3
083B:  MOVF   79,W
083C:  MOVWF  4E
083D:  MOVF   78,W
083E:  MOVWF  4D
....................    appendMorseCode(duration > DASH_DURATION ? '-' : '.'); 
083F:  MOVF   4E,W
0840:  SUBLW  01
0841:  BTFSC  03.0
0842:  GOTO   04C
0843:  XORLW  FF
0844:  BTFSS  03.2
0845:  GOTO   04A
0846:  MOVF   4D,W
0847:  SUBLW  58
0848:  BTFSC  03.0
0849:  GOTO   04C
084A:  MOVLW  2D
084B:  GOTO   04D
084C:  MOVLW  2E
084D:  MOVWF  4F
084E:  MOVF   4F,W
084F:  MOVWF  50
....................  
....................    set_lcd_i2c_cursor_position(2, 0); 
*
085C:  MOVLW  02
085D:  MOVWF  54
085E:  CLRF   55
085F:  BCF    0A.3
0860:  CALL   2C7
0861:  BSF    0A.3
....................    printf(write_lcd_i2c, "%s", morseCodeBufferString); 
0862:  MOVLW  30
0863:  MOVWF  04
0864:  BCF    03.7
0865:  BCF    0A.3
0866:  CALL   4FE
0867:  BSF    0A.3
.................... } 
....................  
.................... void completeMorseCode() 
.................... { 
....................    if (morseCodeBufferIndex > 0) 
*
0875:  MOVF   36,F
0876:  BTFSC  03.2
0877:  GOTO   117
....................    { 
....................       translateMorseCode(); 
....................       clear_lcd_i2c(); 
*
0908:  BCF    0A.3
0909:  CALL   2C0
090A:  BSF    0A.3
....................       set_lcd_i2c_cursor_position(1, 0); 
090B:  MOVLW  01
090C:  MOVWF  54
090D:  CLRF   55
090E:  BCF    0A.3
090F:  CALL   2C7
0910:  BSF    0A.3
....................       printf(write_lcd_i2c, "%s", morseCodeString); 
0911:  MOVLW  37
0912:  MOVWF  04
0913:  BCF    03.7
0914:  BCF    0A.3
0915:  CALL   4FE
0916:  BSF    0A.3
....................    } 
.................... } 
....................  
.................... #include <morseCodeSpeaker.c> 
.................... #include <global_variables.h> 
.................... #ifndef VAR_H 
.................... #define VAR_H 
....................  
.................... #include <lcd_i2c.c> 
....................  
.................... const unsigned int16 DOT_DURATION = 200; 
.................... const unsigned int16 DASH_DURATION = 600; 
....................  
.................... const int8 SW_Pin[] = {Pin_B0, Pin_B1, Pin_B2, Pin_B3, Pin_B4}; 
.................... // int8 SW_Pin = Pin_B0; // Assuming only one button for Morse code input 
....................  
.................... const int8 LED_Pin = Pin_D0; 
.................... const int8 Buzzer_Pin = Pin_D1; 
....................  
.................... unsigned int16 elapsedTime = 0; 
....................  
.................... unsigned int8 morseCodeBufferString[6]; 
.................... unsigned int8 morseCodeBufferIndex = 0; 
....................  
.................... unsigned int8 morseCodeString[16]; 
.................... unsigned int8 morseCodeStringIndex = 0; 
....................  
.................... typedef struct 
.................... { 
....................     char morseCode[6]; 
....................     char character; 
.................... } MorseCode; 
....................  
.................... const MorseCode morseCodeTable[] = { 
....................     {".-", 'A'}, // 
....................     {"-...", 'B'}, 
....................     {"-.-.", 'C'}, 
....................     {"-..", 'D'}, 
....................     {".", 'E'}, 
....................     {"..-.", 'F'}, 
....................     {"--.", 'G'}, 
....................     {"....", 'H'}, 
....................     {"..", 'I'}, 
....................     {".---", 'J'}, 
....................     {"-.-", 'K'}, 
....................     {".-..", 'L'}, 
....................     {"--", 'M'}, 
....................     {"-.", 'N'}, 
....................     {"---", 'O'}, 
....................     {".--.", 'P'}, 
....................     {"--.-", 'Q'}, 
....................     {".-.", 'R'}, 
....................     {"...", 'S'}, 
....................     {"-", 'T'}, 
....................     {"..-", 'U'}, 
....................     {"...-", 'V'}, 
....................     {".--", 'W'}, 
....................     {"-..-", 'X'}, 
....................     {"-.--", 'Y'}, 
....................     {"--..", 'Z'}, 
....................     {"-----", '0'}, 
....................     {".----", '1'}, 
....................     {"..---", '2'}, 
....................     {"...--", '3'}, 
....................     {"....-", '4'}, 
....................     {".....", '5'}, 
....................     {"-....", '6'}, 
....................     {"--...", '7'}, 
....................     {"---..", '8'}, 
....................     {"----.", '9'}}; 
....................  
.................... typedef enum 
.................... { 
....................     BUTTON_MODE, 
....................     UART_MODE 
.................... } Mode; 
....................  
.................... Mode inputMode = BUTTON_MODE; 
....................  
.................... #INT_TIMER1 
.................... void An389_Interrupt() 
.................... { 
....................     elapsedTime++; 
....................     set_timer1(65036); 
....................     clear_interrupt(INT_TIMER1); 
.................... } 
....................  
.................... void startTimer() 
.................... { 
....................     elapsedTime = 0; 
....................  
....................     // setup timer1, 1ms interrupt, 16MHz, timer1 16 bit, prescaler 1:8 
....................     // 16MHz / 4 = 4MHz 
....................     // 4MHz / 8 = 500KHz 
....................     // 1 / 500KHz = 2us 
....................     // 1ms / 2us = 500 
....................     // 65536 - 500 = 65036 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
....................     set_timer1(65036); 
....................     enable_interrupts(INT_TIMER1); 
....................     enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... unsigned int16 getTimerValue() 
.................... { 
....................     return elapsedTime; 
.................... } 
....................  
.................... unsigned int16 stopAndReadTimer() 
.................... { 
....................     disable_interrupts(INT_TIMER1); 
....................     disable_interrupts(GLOBAL); 
....................     return elapsedTime; 
.................... } 
....................  
.................... #endif 
....................  
.................... // #include <lcd_i2c.c> 
....................  
.................... void playMorseCodeWithBuzzer() 
.................... { 
....................     for (int i = 0; i < morseCodeStringIndex; ++i) 
*
0927:  CLRF   4D
0928:  MOVF   47,W
0929:  SUBWF  4D,W
092A:  BTFSC  03.0
092B:  GOTO   1DC
....................     { 
....................         char c = morseCodeString[i]; 
092C:  MOVLW  37
092D:  ADDWF  4D,W
092E:  MOVWF  04
092F:  BCF    03.7
0930:  MOVF   00,W
0931:  MOVWF  4E
....................         for (int j = 0; j < sizeof(morseCodeTable) / sizeof(MorseCode); ++j) 
0932:  CLRF   4F
0933:  MOVF   4F,W
0934:  SUBLW  23
0935:  BTFSS  03.0
0936:  GOTO   1DA
....................         { 
....................             if (c == morseCodeTable[j].character) 
0937:  MOVF   4F,W
0938:  MOVWF  56
0939:  MOVLW  07
093A:  MOVWF  57
093B:  BCF    0A.3
093C:  CALL   514
093D:  BSF    0A.3
093E:  MOVLW  06
093F:  ADDWF  78,W
0940:  BCF    0A.3
0941:  CALL   051
0942:  BSF    0A.3
0943:  MOVWF  78
0944:  SUBWF  4E,W
0945:  BTFSS  03.2
0946:  GOTO   1D8
....................             { 
....................                 set_lcd_i2c_cursor_position(2, 0); 
0947:  MOVLW  02
0948:  MOVWF  54
0949:  CLRF   55
094A:  BCF    0A.3
094B:  CALL   2C7
094C:  BSF    0A.3
....................                 printf(write_lcd_i2c, "%c: %s", c, morseCodeTable[j].morseCode); 
094D:  MOVF   4F,W
094E:  MOVWF  56
094F:  MOVLW  07
0950:  MOVWF  57
0951:  BCF    0A.3
0952:  CALL   514
0953:  BSF    0A.3
0954:  MOVF   78,W
0955:  MOVWF  53
0956:  MOVF   4E,W
0957:  MOVWF  5D
0958:  BCF    0A.3
0959:  CALL   324
095A:  BSF    0A.3
095B:  MOVLW  3A
095C:  MOVWF  5D
095D:  BCF    0A.3
095E:  CALL   324
095F:  BSF    0A.3
0960:  MOVLW  20
0961:  MOVWF  5D
0962:  BCF    0A.3
0963:  CALL   324
0964:  BSF    0A.3
0965:  MOVLW  58
0966:  BSF    03.6
0967:  MOVWF  0D
0968:  MOVLW  00
0969:  MOVWF  0F
096A:  BCF    03.6
096B:  MOVF   53,W
096C:  BSF    03.6
096D:  ADDWF  0D,F
096E:  BTFSC  03.0
096F:  INCF   0F,F
0970:  BCF    0A.3
0971:  BCF    03.6
0972:  CALL   542
0973:  BSF    0A.3
....................  
....................                 unsigned int8 k = 0; 
0974:  CLRF   50
....................                 while (morseCodeTable[j].morseCode[k] != '\0') 
0975:  MOVF   4F,W
0976:  MOVWF  56
0977:  MOVLW  07
0978:  MOVWF  57
0979:  BCF    0A.3
097A:  CALL   514
097B:  BSF    0A.3
097C:  MOVF   50,W
097D:  ADDWF  78,W
097E:  BCF    0A.3
097F:  CALL   051
0980:  BSF    0A.3
0981:  XORLW  00
0982:  BTFSC  03.2
0983:  GOTO   1C0
....................                 { 
....................                     output_low(Buzzer_Pin); 
0984:  BSF    03.5
0985:  BCF    08.1
0986:  BCF    03.5
0987:  BCF    08.1
....................                     unsigned int16 duration = morseCodeTable[j].morseCode[k] == '-' ? DASH_DURATION : DOT_DURATION; 
0988:  MOVF   4F,W
0989:  MOVWF  56
098A:  MOVLW  07
098B:  MOVWF  57
098C:  BCF    0A.3
098D:  CALL   514
098E:  BSF    0A.3
098F:  MOVF   50,W
0990:  ADDWF  78,W
0991:  BCF    0A.3
0992:  CALL   051
0993:  BSF    0A.3
0994:  SUBLW  2D
0995:  BTFSS  03.2
0996:  GOTO   19B
0997:  MOVLW  02
0998:  MOVWF  7A
0999:  MOVLW  58
099A:  GOTO   19D
099B:  CLRF   7A
099C:  MOVLW  C8
099D:  MOVWF  51
099E:  MOVF   7A,W
099F:  MOVWF  52
....................                     delay_ms(duration); 
09A0:  MOVF   52,W
09A1:  MOVWF  53
09A2:  INCF   53,F
09A3:  DECF   53,F
09A4:  BTFSC  03.2
09A5:  GOTO   1AC
09A6:  MOVLW  FF
09A7:  MOVWF  55
09A8:  BCF    0A.3
09A9:  CALL   2AB
09AA:  BSF    0A.3
09AB:  GOTO   1A3
09AC:  MOVF   51,W
09AD:  MOVWF  55
09AE:  BCF    0A.3
09AF:  CALL   2AB
09B0:  BSF    0A.3
....................                     output_high(Buzzer_Pin); 
09B1:  BSF    03.5
09B2:  BCF    08.1
09B3:  BCF    03.5
09B4:  BSF    08.1
....................  
....................                     delay_ms(400); 
09B5:  MOVLW  02
09B6:  MOVWF  53
09B7:  MOVLW  C8
09B8:  MOVWF  55
09B9:  BCF    0A.3
09BA:  CALL   2AB
09BB:  BSF    0A.3
09BC:  DECFSZ 53,F
09BD:  GOTO   1B7
....................  
....................                     k++; 
09BE:  INCF   50,F
09BF:  GOTO   175
....................                 } 
....................  
....................                 set_lcd_i2c_cursor_position(2, 0); 
09C0:  MOVLW  02
09C1:  MOVWF  54
09C2:  CLRF   55
09C3:  BCF    0A.3
09C4:  CALL   2C7
09C5:  BSF    0A.3
....................                 printf(write_lcd_i2c, "                "); 
09C6:  MOVLW  6C
09C7:  BSF    03.6
09C8:  MOVWF  0D
09C9:  MOVLW  01
09CA:  MOVWF  0F
09CB:  BCF    0A.3
09CC:  BCF    03.6
09CD:  CALL   48D
09CE:  BSF    0A.3
....................  
....................                 delay_ms(800); 
09CF:  MOVLW  04
09D0:  MOVWF  53
09D1:  MOVLW  C8
09D2:  MOVWF  55
09D3:  BCF    0A.3
09D4:  CALL   2AB
09D5:  BSF    0A.3
09D6:  DECFSZ 53,F
09D7:  GOTO   1D1
....................             } 
09D8:  INCF   4F,F
09D9:  GOTO   133
....................         } 
09DA:  INCF   4D,F
09DB:  GOTO   128
....................     } 
.................... } 
....................  
.................... void playMorseCodeWithLED() 
.................... { 
....................     for (int i = 0; i < morseCodeStringIndex; ++i) 
*
09EC:  CLRF   4D
09ED:  MOVF   47,W
09EE:  SUBWF  4D,W
09EF:  BTFSC  03.0
09F0:  GOTO   2A1
....................     { 
....................         char c = morseCodeString[i]; 
09F1:  MOVLW  37
09F2:  ADDWF  4D,W
09F3:  MOVWF  04
09F4:  BCF    03.7
09F5:  MOVF   00,W
09F6:  MOVWF  4E
....................         for (int j = 0; j < sizeof(morseCodeTable) / sizeof(MorseCode); ++j) 
09F7:  CLRF   4F
09F8:  MOVF   4F,W
09F9:  SUBLW  23
09FA:  BTFSS  03.0
09FB:  GOTO   29F
....................         { 
....................             if (c == morseCodeTable[j].character) 
09FC:  MOVF   4F,W
09FD:  MOVWF  56
09FE:  MOVLW  07
09FF:  MOVWF  57
0A00:  BCF    0A.3
0A01:  CALL   514
0A02:  BSF    0A.3
0A03:  MOVLW  06
0A04:  ADDWF  78,W
0A05:  BCF    0A.3
0A06:  CALL   051
0A07:  BSF    0A.3
0A08:  MOVWF  78
0A09:  SUBWF  4E,W
0A0A:  BTFSS  03.2
0A0B:  GOTO   29D
....................             { 
....................                 set_lcd_i2c_cursor_position(2, 0); 
0A0C:  MOVLW  02
0A0D:  MOVWF  54
0A0E:  CLRF   55
0A0F:  BCF    0A.3
0A10:  CALL   2C7
0A11:  BSF    0A.3
....................                 printf(write_lcd_i2c, "%c: %s", c, morseCodeTable[j].morseCode); 
0A12:  MOVF   4F,W
0A13:  MOVWF  56
0A14:  MOVLW  07
0A15:  MOVWF  57
0A16:  BCF    0A.3
0A17:  CALL   514
0A18:  BSF    0A.3
0A19:  MOVF   78,W
0A1A:  MOVWF  53
0A1B:  MOVF   4E,W
0A1C:  MOVWF  5D
0A1D:  BCF    0A.3
0A1E:  CALL   324
0A1F:  BSF    0A.3
0A20:  MOVLW  3A
0A21:  MOVWF  5D
0A22:  BCF    0A.3
0A23:  CALL   324
0A24:  BSF    0A.3
0A25:  MOVLW  20
0A26:  MOVWF  5D
0A27:  BCF    0A.3
0A28:  CALL   324
0A29:  BSF    0A.3
0A2A:  MOVLW  58
0A2B:  BSF    03.6
0A2C:  MOVWF  0D
0A2D:  MOVLW  00
0A2E:  MOVWF  0F
0A2F:  BCF    03.6
0A30:  MOVF   53,W
0A31:  BSF    03.6
0A32:  ADDWF  0D,F
0A33:  BTFSC  03.0
0A34:  INCF   0F,F
0A35:  BCF    0A.3
0A36:  BCF    03.6
0A37:  CALL   542
0A38:  BSF    0A.3
....................  
....................                 unsigned int8 k = 0; 
0A39:  CLRF   50
....................                 while (morseCodeTable[j].morseCode[k] != '\0') 
0A3A:  MOVF   4F,W
0A3B:  MOVWF  56
0A3C:  MOVLW  07
0A3D:  MOVWF  57
0A3E:  BCF    0A.3
0A3F:  CALL   514
0A40:  BSF    0A.3
0A41:  MOVF   50,W
0A42:  ADDWF  78,W
0A43:  BCF    0A.3
0A44:  CALL   051
0A45:  BSF    0A.3
0A46:  XORLW  00
0A47:  BTFSC  03.2
0A48:  GOTO   285
....................                 { 
....................                     output_high(LED_Pin); 
0A49:  BSF    03.5
0A4A:  BCF    08.0
0A4B:  BCF    03.5
0A4C:  BSF    08.0
....................                     unsigned int16 duration = morseCodeTable[j].morseCode[k] == '-' ? DASH_DURATION : DOT_DURATION; 
0A4D:  MOVF   4F,W
0A4E:  MOVWF  56
0A4F:  MOVLW  07
0A50:  MOVWF  57
0A51:  BCF    0A.3
0A52:  CALL   514
0A53:  BSF    0A.3
0A54:  MOVF   50,W
0A55:  ADDWF  78,W
0A56:  BCF    0A.3
0A57:  CALL   051
0A58:  BSF    0A.3
0A59:  SUBLW  2D
0A5A:  BTFSS  03.2
0A5B:  GOTO   260
0A5C:  MOVLW  02
0A5D:  MOVWF  7A
0A5E:  MOVLW  58
0A5F:  GOTO   262
0A60:  CLRF   7A
0A61:  MOVLW  C8
0A62:  MOVWF  51
0A63:  MOVF   7A,W
0A64:  MOVWF  52
....................                     delay_ms(duration); 
0A65:  MOVF   52,W
0A66:  MOVWF  53
0A67:  INCF   53,F
0A68:  DECF   53,F
0A69:  BTFSC  03.2
0A6A:  GOTO   271
0A6B:  MOVLW  FF
0A6C:  MOVWF  55
0A6D:  BCF    0A.3
0A6E:  CALL   2AB
0A6F:  BSF    0A.3
0A70:  GOTO   268
0A71:  MOVF   51,W
0A72:  MOVWF  55
0A73:  BCF    0A.3
0A74:  CALL   2AB
0A75:  BSF    0A.3
....................                     output_low(LED_Pin); 
0A76:  BSF    03.5
0A77:  BCF    08.0
0A78:  BCF    03.5
0A79:  BCF    08.0
....................  
....................                     delay_ms(400); 
0A7A:  MOVLW  02
0A7B:  MOVWF  53
0A7C:  MOVLW  C8
0A7D:  MOVWF  55
0A7E:  BCF    0A.3
0A7F:  CALL   2AB
0A80:  BSF    0A.3
0A81:  DECFSZ 53,F
0A82:  GOTO   27C
....................  
....................                     k++; 
0A83:  INCF   50,F
0A84:  GOTO   23A
....................                 } 
....................  
....................                 set_lcd_i2c_cursor_position(2, 0); 
0A85:  MOVLW  02
0A86:  MOVWF  54
0A87:  CLRF   55
0A88:  BCF    0A.3
0A89:  CALL   2C7
0A8A:  BSF    0A.3
....................                 printf(write_lcd_i2c, "                "); 
0A8B:  MOVLW  75
0A8C:  BSF    03.6
0A8D:  MOVWF  0D
0A8E:  MOVLW  01
0A8F:  MOVWF  0F
0A90:  BCF    0A.3
0A91:  BCF    03.6
0A92:  CALL   48D
0A93:  BSF    0A.3
....................  
....................                 delay_ms(800); 
0A94:  MOVLW  04
0A95:  MOVWF  53
0A96:  MOVLW  C8
0A97:  MOVWF  55
0A98:  BCF    0A.3
0A99:  CALL   2AB
0A9A:  BSF    0A.3
0A9B:  DECFSZ 53,F
0A9C:  GOTO   296
....................             } 
0A9D:  INCF   4F,F
0A9E:  GOTO   1F8
....................         } 
0A9F:  INCF   4D,F
0AA0:  GOTO   1ED
....................     } 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void switchMode() 
.................... { 
....................     inputMode = !inputMode; 
*
0ADD:  MOVLW  01
0ADE:  XORWF  48,F
....................  
....................     clearAll(); 
0ADF:  BCF    0A.3
0AE0:  CALL   56E
0AE1:  BSF    0A.3
....................  
....................     clear_lcd_i2c(); 
0AE2:  BCF    0A.3
0AE3:  CALL   2C0
0AE4:  BSF    0A.3
....................     set_lcd_i2c_cursor_position(1, 0); 
0AE5:  MOVLW  01
0AE6:  MOVWF  54
0AE7:  CLRF   55
0AE8:  BCF    0A.3
0AE9:  CALL   2C7
0AEA:  BSF    0A.3
....................     printf(write_lcd_i2c, "Mode: %s", inputMode == BUTTON_MODE ? (char *)"Button" : (char *)"UART"); 
0AEB:  BTFSC  48.0
0AEC:  GOTO   2FE
0AED:  CLRF   78
0AEE:  MOVLW  07
0AEF:  MOVWF  77
0AF0:  MOVLW  4D
0AF1:  MOVWF  04
0AF2:  BCF    03.7
0AF3:  MOVF   78,W
0AF4:  BCF    0A.3
0AF5:  CALL   154
0AF6:  BSF    0A.3
0AF7:  MOVWF  00
0AF8:  INCF   78,F
0AF9:  INCF   04,F
0AFA:  DECFSZ 77,F
0AFB:  GOTO   2F3
0AFC:  MOVLW  4D
0AFD:  GOTO   308
0AFE:  MOVLW  55
0AFF:  MOVWF  4D
0B00:  MOVLW  41
0B01:  MOVWF  4E
0B02:  MOVLW  52
0B03:  MOVWF  4F
0B04:  MOVLW  54
0B05:  MOVWF  50
0B06:  CLRF   51
0B07:  MOVLW  4D
0B08:  MOVWF  55
0B09:  MOVLW  7E
0B0A:  BSF    03.6
0B0B:  MOVWF  0D
0B0C:  MOVLW  01
0B0D:  MOVWF  0F
0B0E:  BCF    03.0
0B0F:  MOVLW  06
0B10:  BCF    03.6
0B11:  MOVWF  59
*
0B6C:  MOVF   55,W
0B6D:  MOVWF  04
0B6E:  BCF    03.7
0B6F:  BTFSC  56.0
0B70:  BSF    03.7
0B71:  BCF    0A.3
0B72:  CALL   4FE
0B73:  BSF    0A.3
....................  
....................     delay_ms(1500); 
0B74:  MOVLW  06
0B75:  MOVWF  54
0B76:  MOVLW  FA
0B77:  MOVWF  55
0B78:  BCF    0A.3
0B79:  CALL   2AB
0B7A:  BSF    0A.3
0B7B:  DECFSZ 54,F
0B7C:  GOTO   376
....................  
....................     clear_lcd_i2c(); 
0B7D:  BCF    0A.3
0B7E:  CALL   2C0
0B7F:  BSF    0A.3
.................... } 
....................  
.................... void handleButtonPress() 
.................... { 
....................     if (input(SW_Pin[0]) == 0 && inputMode == BUTTON_MODE) // create morse code character 
*
0800:  BSF    03.5
0801:  BSF    06.0
0802:  BCF    03.5
0803:  BTFSC  06.0
0804:  GOTO   069
0805:  BTFSC  48.0
0806:  GOTO   069
....................     { 
....................         recordMorseCode(); 
....................     } 
*
0868:  GOTO   384
....................  
....................     else if (input(SW_Pin[1]) == 0 && inputMode == BUTTON_MODE) // append character to string and lcd 
0869:  BSF    03.5
086A:  BSF    06.1
086B:  BCF    03.5
086C:  BTFSC  06.1
086D:  GOTO   11D
086E:  BTFSC  48.0
086F:  GOTO   11D
....................     { 
....................         delay_ms(100); // Debounce 
0870:  MOVLW  64
0871:  MOVWF  55
0872:  BCF    0A.3
0873:  CALL   2AB
0874:  BSF    0A.3
....................  
....................         completeMorseCode(); 
....................  
....................         while (input(SW_Pin[1]) == 0) 
*
0917:  BSF    03.5
0918:  BSF    06.1
0919:  BCF    03.5
091A:  BTFSS  06.1
091B:  GOTO   117
....................             ; // Wait for button release 
....................     } 
091C:  GOTO   384
....................  
....................     else if (input(SW_Pin[2]) == 0) // play morse code with buzzer 
091D:  BSF    03.5
091E:  BSF    06.2
091F:  BCF    03.5
0920:  BTFSC  06.2
0921:  GOTO   1E2
....................     { 
....................         delay_ms(50); // Debounce 
0922:  MOVLW  32
0923:  MOVWF  55
0924:  BCF    0A.3
0925:  CALL   2AB
0926:  BSF    0A.3
....................  
....................         playMorseCodeWithBuzzer(); 
....................  
....................         while (input(SW_Pin[2]) == 0) 
*
09DC:  BSF    03.5
09DD:  BSF    06.2
09DE:  BCF    03.5
09DF:  BTFSS  06.2
09E0:  GOTO   1DC
....................             ; // Wait for button release 
....................     } 
09E1:  GOTO   384
....................  
....................     else if (input(SW_Pin[3]) == 0) // play morse code with LED 
09E2:  BSF    03.5
09E3:  BSF    06.3
09E4:  BCF    03.5
09E5:  BTFSC  06.3
09E6:  GOTO   2A7
....................     { 
....................         delay_ms(50); // Debounce 
09E7:  MOVLW  32
09E8:  MOVWF  55
09E9:  BCF    0A.3
09EA:  CALL   2AB
09EB:  BSF    0A.3
....................  
....................         playMorseCodeWithLED(); 
....................  
....................         while (input(SW_Pin[3]) == 0) 
*
0AA1:  BSF    03.5
0AA2:  BSF    06.3
0AA3:  BCF    03.5
0AA4:  BTFSS  06.3
0AA5:  GOTO   2A1
....................             ; // Wait for button release 
....................     } 
0AA6:  GOTO   384
....................  
....................     else if (input(SW_Pin[4]) == 0) // clear all 
0AA7:  BSF    03.5
0AA8:  BSF    06.4
0AA9:  BCF    03.5
0AAA:  BTFSC  06.4
0AAB:  GOTO   384
....................     { 
....................         startTimer(); 
0AAC:  BCF    0A.3
0AAD:  CALL   4E3
0AAE:  BSF    0A.3
....................  
....................         delay_ms(50); // Debounce 
0AAF:  MOVLW  32
0AB0:  MOVWF  55
0AB1:  BCF    0A.3
0AB2:  CALL   2AB
0AB3:  BSF    0A.3
....................  
....................         while (input(SW_Pin[4]) == 0 && getTimerValue() < 1000) 
0AB4:  BSF    03.5
0AB5:  BSF    06.4
0AB6:  BCF    03.5
0AB7:  BTFSC  06.4
0AB8:  GOTO   2CB
*
0ABD:  MOVF   79,W
0ABE:  MOVWF  4F
0ABF:  MOVF   78,W
0AC0:  MOVWF  4E
0AC1:  MOVF   4F,W
0AC2:  SUBLW  03
0AC3:  BTFSS  03.0
0AC4:  GOTO   2CB
0AC5:  BTFSS  03.2
0AC6:  GOTO   2B4
0AC7:  MOVF   4E,W
0AC8:  SUBLW  E7
0AC9:  BTFSC  03.0
0ACA:  GOTO   2B4
....................             ; // Wait for button release 
....................  
....................         unsigned int16 duration = stopAndReadTimer(); 
0ACB:  BCF    0A.3
0ACC:  CALL   4F2
0ACD:  BSF    0A.3
0ACE:  MOVF   79,W
0ACF:  MOVWF  4C
0AD0:  MOVF   78,W
0AD1:  MOVWF  4B
....................  
....................         if (duration >= 1000) 
0AD2:  MOVF   4C,W
0AD3:  SUBLW  02
0AD4:  BTFSC  03.0
0AD5:  GOTO   381
0AD6:  XORLW  FF
0AD7:  BTFSS  03.2
0AD8:  GOTO   2DD
0AD9:  MOVF   4B,W
0ADA:  SUBLW  E7
0ADB:  BTFSC  03.0
0ADC:  GOTO   381
....................         { 
....................             switchMode(); 
....................         } 
*
0B80:  GOTO   384
....................         else 
....................         { 
....................             clearAll(); 
0B81:  BCF    0A.3
0B82:  CALL   56E
0B83:  BSF    0A.3
....................         } 
....................     } 
0B84:  BCF    0A.3
0B85:  BCF    0A.4
0B86:  GOTO   5DE (RETURN)
.................... } 
....................  
.................... void main() 
*
0579:  MOVF   03,W
057A:  ANDLW  1F
057B:  MOVWF  03
057C:  BSF    03.5
057D:  BSF    03.6
057E:  BCF    07.3
057F:  MOVLW  4D
0580:  BCF    03.6
0581:  MOVWF  19
0582:  MOVLW  A6
0583:  MOVWF  18
0584:  MOVLW  90
0585:  BCF    03.5
0586:  MOVWF  18
0587:  MOVLW  FF
0588:  MOVWF  2B
0589:  MOVLW  08
058A:  MOVWF  2C
058B:  MOVLW  01
058C:  MOVWF  2D
058D:  CLRF   2F
058E:  CLRF   2E
058F:  CLRF   36
0590:  CLRF   47
0591:  BCF    48.0
0592:  BSF    03.5
0593:  BSF    03.6
0594:  MOVF   09,W
0595:  ANDLW  C0
0596:  MOVWF  09
0597:  BCF    03.6
0598:  BCF    1F.4
0599:  BCF    1F.5
059A:  MOVLW  00
059B:  BSF    03.6
059C:  MOVWF  08
059D:  BCF    03.5
059E:  CLRF   07
059F:  CLRF   08
05A0:  CLRF   09
05A1:  BCF    03.7
.................... { 
....................     initialize_lcd_i2c(); // Initialize the LCD 
*
05A5:  GOTO   1DD
....................     set_tris_d(0x00);     // Set LED and buzzer pins as output 
05A6:  MOVLW  00
05A7:  BSF    03.5
05A8:  MOVWF  08
....................     set_tris_b(0x1F);     // Set SW pins as input 
05A9:  MOVLW  1F
05AA:  MOVWF  06
....................     output_d(0x02);       // Turn off LED and Buzzer 
05AB:  CLRF   08
05AC:  MOVLW  02
05AD:  BCF    03.5
05AE:  MOVWF  08
....................  
....................     memset(morseCodeBufferString, 0, sizeof(morseCodeBufferString)); 
05AF:  MOVLW  30
05B0:  MOVWF  04
05B1:  BCF    03.7
05B2:  CLRF   77
05B3:  MOVLW  06
05B4:  MOVWF  78
05B5:  CALL   24D
....................     memset(morseCodeString, 0, sizeof(morseCodeString)); 
05B6:  MOVLW  37
05B7:  MOVWF  04
05B8:  BCF    03.7
05B9:  CLRF   77
05BA:  MOVLW  10
05BB:  MOVWF  78
05BC:  CALL   24D
....................     clear_lcd_i2c(); 
05BD:  CALL   2C0
....................  
....................     set_lcd_i2c_cursor_position(1, 0); 
05BE:  MOVLW  01
05BF:  MOVWF  54
05C0:  CLRF   55
05C1:  CALL   2C7
....................     printf(write_lcd_i2c, "1. LE TRONG AN"); 
05C2:  MOVLW  83
05C3:  BSF    03.6
05C4:  MOVWF  0D
05C5:  MOVLW  01
05C6:  MOVWF  0F
05C7:  BCF    03.6
05C8:  CALL   48D
....................     set_lcd_i2c_cursor_position(2, 0); 
05C9:  MOVLW  02
05CA:  MOVWF  54
05CB:  CLRF   55
05CC:  CALL   2C7
....................     printf(write_lcd_i2c, "2. N.H VIET ANH"); 
05CD:  MOVLW  8B
05CE:  BSF    03.6
05CF:  MOVWF  0D
05D0:  MOVLW  01
05D1:  MOVWF  0F
05D2:  BCF    03.6
05D3:  CALL   48D
....................  
....................     delay_ms(1500); 
05D4:  MOVLW  06
05D5:  MOVWF  4B
05D6:  MOVLW  FA
05D7:  MOVWF  55
05D8:  CALL   2AB
05D9:  DECFSZ 4B,F
05DA:  GOTO   5D6
....................     clear_lcd_i2c(); 
05DB:  CALL   2C0
....................  
....................     while (TRUE) 
....................     { 
....................         handleButtonPress(); 
05DC:  BSF    0A.3
05DD:  GOTO   000
05DE:  BCF    0A.3
05DF:  GOTO   5DC
....................         // Additional functionality can be added here 
....................     } 
.................... } 
05E0:  SLEEP

Configuration Fuses:
   Word  1: 2CE2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
