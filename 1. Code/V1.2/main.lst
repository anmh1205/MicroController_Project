CCS PCM C Compiler, Version 5.025, 26966               06-Jul-24 00:06

               Filename:   E:\1. Phenikaa University\AML\1. Code\VDK (PIC16)\0. BTL\1. Code\V1.2\main.lst

               ROM used:   2085 words (25%)
                           Largest free fragment is 2048
               RAM used:   48 (13%) at main() level
                           73 (20%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   154
.................... #include <main.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDLW  58
0055:  BTFSC  03.0
0056:  INCF   0A,F
0057:  MOVWF  02
0058:  RETLW  2E
0059:  RETLW  2D
005A:  RETLW  00
005B:  RETLW  00
005C:  RETLW  00
005D:  RETLW  00
005E:  RETLW  41
005F:  RETLW  2D
0060:  RETLW  2E
0061:  RETLW  2E
0062:  RETLW  2E
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  2D
0067:  RETLW  2E
0068:  RETLW  2D
0069:  RETLW  2E
006A:  RETLW  00
006B:  RETLW  00
006C:  RETLW  43
006D:  RETLW  2D
006E:  RETLW  2E
006F:  RETLW  2E
0070:  RETLW  00
0071:  RETLW  00
0072:  RETLW  00
0073:  RETLW  44
0074:  RETLW  2E
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  00
0079:  RETLW  00
007A:  RETLW  45
007B:  RETLW  2E
007C:  RETLW  2E
007D:  RETLW  2D
007E:  RETLW  2E
007F:  RETLW  00
0080:  RETLW  00
0081:  RETLW  46
0082:  RETLW  2D
0083:  RETLW  2D
0084:  RETLW  2E
0085:  RETLW  00
0086:  RETLW  00
0087:  RETLW  00
0088:  RETLW  47
0089:  RETLW  2E
008A:  RETLW  2E
008B:  RETLW  2E
008C:  RETLW  2E
008D:  RETLW  00
008E:  RETLW  00
008F:  RETLW  48
0090:  RETLW  2E
0091:  RETLW  2E
0092:  RETLW  00
0093:  RETLW  00
0094:  RETLW  00
0095:  RETLW  00
0096:  RETLW  49
0097:  RETLW  2E
0098:  RETLW  2D
0099:  RETLW  2D
009A:  RETLW  2D
009B:  RETLW  00
009C:  RETLW  00
009D:  RETLW  4A
009E:  RETLW  2D
009F:  RETLW  2E
00A0:  RETLW  2D
00A1:  RETLW  00
00A2:  RETLW  00
00A3:  RETLW  00
00A4:  RETLW  4B
00A5:  RETLW  2E
00A6:  RETLW  2D
00A7:  RETLW  2E
00A8:  RETLW  2E
00A9:  RETLW  00
00AA:  RETLW  00
00AB:  RETLW  4C
00AC:  RETLW  2D
00AD:  RETLW  2D
00AE:  RETLW  00
00AF:  RETLW  00
00B0:  RETLW  00
00B1:  RETLW  00
00B2:  RETLW  4D
00B3:  RETLW  2D
00B4:  RETLW  2E
00B5:  RETLW  00
00B6:  RETLW  00
00B7:  RETLW  00
00B8:  RETLW  00
00B9:  RETLW  4E
00BA:  RETLW  2D
00BB:  RETLW  2D
00BC:  RETLW  2D
00BD:  RETLW  00
00BE:  RETLW  00
00BF:  RETLW  00
00C0:  RETLW  4F
00C1:  RETLW  2E
00C2:  RETLW  2D
00C3:  RETLW  2D
00C4:  RETLW  2E
00C5:  RETLW  00
00C6:  RETLW  00
00C7:  RETLW  50
00C8:  RETLW  2D
00C9:  RETLW  2D
00CA:  RETLW  2E
00CB:  RETLW  2D
00CC:  RETLW  00
00CD:  RETLW  00
00CE:  RETLW  51
00CF:  RETLW  2E
00D0:  RETLW  2D
00D1:  RETLW  2E
00D2:  RETLW  00
00D3:  RETLW  00
00D4:  RETLW  00
00D5:  RETLW  52
00D6:  RETLW  2E
00D7:  RETLW  2E
00D8:  RETLW  2E
00D9:  RETLW  00
00DA:  RETLW  00
00DB:  RETLW  00
00DC:  RETLW  53
00DD:  RETLW  2D
00DE:  RETLW  00
00DF:  RETLW  00
00E0:  RETLW  00
00E1:  RETLW  00
00E2:  RETLW  00
00E3:  RETLW  54
00E4:  RETLW  2E
00E5:  RETLW  2E
00E6:  RETLW  2D
00E7:  RETLW  00
00E8:  RETLW  00
00E9:  RETLW  00
00EA:  RETLW  55
00EB:  RETLW  2E
00EC:  RETLW  2E
00ED:  RETLW  2E
00EE:  RETLW  2D
00EF:  RETLW  00
00F0:  RETLW  00
00F1:  RETLW  56
00F2:  RETLW  2E
00F3:  RETLW  2D
00F4:  RETLW  2D
00F5:  RETLW  00
00F6:  RETLW  00
00F7:  RETLW  00
00F8:  RETLW  57
00F9:  RETLW  2D
00FA:  RETLW  2E
00FB:  RETLW  2E
00FC:  RETLW  2D
00FD:  RETLW  00
00FE:  RETLW  00
00FF:  RETLW  58
0100:  RETLW  2D
0101:  RETLW  2E
0102:  RETLW  2D
0103:  RETLW  2D
0104:  RETLW  00
0105:  RETLW  00
0106:  RETLW  59
0107:  RETLW  2D
0108:  RETLW  2D
0109:  RETLW  2E
010A:  RETLW  2E
010B:  RETLW  00
010C:  RETLW  00
010D:  RETLW  5A
010E:  RETLW  2D
010F:  RETLW  2D
0110:  RETLW  2D
0111:  RETLW  2D
0112:  RETLW  2D
0113:  RETLW  00
0114:  RETLW  30
0115:  RETLW  2E
0116:  RETLW  2D
0117:  RETLW  2D
0118:  RETLW  2D
0119:  RETLW  2D
011A:  RETLW  00
011B:  RETLW  31
011C:  RETLW  2E
011D:  RETLW  2E
011E:  RETLW  2D
011F:  RETLW  2D
0120:  RETLW  2D
0121:  RETLW  00
0122:  RETLW  32
0123:  RETLW  2E
0124:  RETLW  2E
0125:  RETLW  2E
0126:  RETLW  2D
0127:  RETLW  2D
0128:  RETLW  00
0129:  RETLW  33
012A:  RETLW  2E
012B:  RETLW  2E
012C:  RETLW  2E
012D:  RETLW  2E
012E:  RETLW  2D
012F:  RETLW  00
0130:  RETLW  34
0131:  RETLW  2E
0132:  RETLW  2E
0133:  RETLW  2E
0134:  RETLW  2E
0135:  RETLW  2E
0136:  RETLW  00
0137:  RETLW  35
0138:  RETLW  2D
0139:  RETLW  2E
013A:  RETLW  2E
013B:  RETLW  2E
013C:  RETLW  2E
013D:  RETLW  00
013E:  RETLW  36
013F:  RETLW  2D
0140:  RETLW  2D
0141:  RETLW  2E
0142:  RETLW  2E
0143:  RETLW  2E
0144:  RETLW  00
0145:  RETLW  37
0146:  RETLW  2D
0147:  RETLW  2D
0148:  RETLW  2D
0149:  RETLW  2E
014A:  RETLW  2E
014B:  RETLW  00
014C:  RETLW  38
014D:  RETLW  2D
014E:  RETLW  2D
014F:  RETLW  2D
0150:  RETLW  2D
0151:  RETLW  2E
0152:  RETLW  00
0153:  RETLW  39
*
0161:  DATA 20,10
0162:  DATA 20,10
0163:  DATA 20,10
0164:  DATA 20,10
0165:  DATA 20,10
0166:  DATA 20,10
0167:  DATA 20,10
0168:  DATA 20,10
0169:  DATA 00,00
016A:  DATA 20,10
016B:  DATA 20,10
016C:  DATA 20,10
016D:  DATA 20,10
016E:  DATA 20,10
016F:  DATA 20,10
0170:  DATA 20,10
0171:  DATA 20,10
0172:  DATA 00,00
0173:  DATA 31,17
0174:  DATA 20,26
0175:  DATA 45,10
0176:  DATA 54,29
0177:  DATA 4F,27
0178:  DATA 47,10
0179:  DATA 41,27
017A:  DATA 00,01
017B:  DATA 32,17
017C:  DATA 20,27
017D:  DATA 2E,24
017E:  DATA 20,2B
017F:  DATA C9,22
0180:  DATA 54,10
0181:  DATA 41,27
0182:  DATA 48,00
*
023D:  MOVF   78,W
023E:  BTFSC  03.2
023F:  GOTO   245
0240:  MOVF   77,W
0241:  MOVWF  00
0242:  INCF   04,F
0243:  DECFSZ 78,F
0244:  GOTO   240
0245:  RETURN
*
047D:  MOVF   0B,W
047E:  MOVWF  58
047F:  BCF    0B.7
0480:  BSF    03.5
0481:  BSF    03.6
0482:  BSF    0C.7
0483:  BSF    0C.0
0484:  NOP
0485:  NOP
0486:  BCF    03.5
0487:  BCF    03.6
0488:  BTFSC  58.7
0489:  BSF    0B.7
048A:  BSF    03.6
048B:  MOVF   0C,W
048C:  ANDLW  7F
048D:  BTFSC  03.2
048E:  GOTO   4D1
048F:  BCF    03.6
0490:  MOVWF  58
0491:  BSF    03.6
0492:  MOVF   0D,W
0493:  BCF    03.6
0494:  MOVWF  59
0495:  BSF    03.6
0496:  MOVF   0F,W
0497:  BCF    03.6
0498:  MOVWF  5A
0499:  MOVF   58,W
049A:  MOVWF  5B
049B:  CALL   314
049C:  MOVF   59,W
049D:  BSF    03.6
049E:  MOVWF  0D
049F:  BCF    03.6
04A0:  MOVF   5A,W
04A1:  BSF    03.6
04A2:  MOVWF  0F
04A3:  BCF    03.6
04A4:  MOVF   0B,W
04A5:  MOVWF  5B
04A6:  BCF    0B.7
04A7:  BSF    03.5
04A8:  BSF    03.6
04A9:  BSF    0C.7
04AA:  BSF    0C.0
04AB:  NOP
04AC:  NOP
04AD:  BCF    03.5
04AE:  BCF    03.6
04AF:  BTFSC  5B.7
04B0:  BSF    0B.7
04B1:  BSF    03.6
04B2:  RLF    0C,W
04B3:  RLF    0E,W
04B4:  ANDLW  7F
04B5:  BTFSC  03.2
04B6:  GOTO   4D1
04B7:  BCF    03.6
04B8:  MOVWF  58
04B9:  BSF    03.6
04BA:  MOVF   0D,W
04BB:  BCF    03.6
04BC:  MOVWF  59
04BD:  BSF    03.6
04BE:  MOVF   0F,W
04BF:  BCF    03.6
04C0:  MOVWF  5A
04C1:  MOVF   58,W
04C2:  MOVWF  5B
04C3:  CALL   314
04C4:  MOVF   59,W
04C5:  BSF    03.6
04C6:  MOVWF  0D
04C7:  BCF    03.6
04C8:  MOVF   5A,W
04C9:  BSF    03.6
04CA:  MOVWF  0F
04CB:  INCF   0D,F
04CC:  BTFSC  03.2
04CD:  INCF   0F,F
04CE:  BCF    03.6
04CF:  GOTO   47D
04D0:  BSF    03.6
04D1:  BCF    03.6
04D2:  RETURN
04D3:  MOVF   00,F
04D4:  BTFSC  03.2
04D5:  GOTO   4E8
04D6:  CLRF   59
04D7:  MOVF   04,W
04D8:  MOVWF  58
04D9:  BCF    59.0
04DA:  BTFSC  03.7
04DB:  BSF    59.0
04DC:  MOVF   00,W
04DD:  MOVWF  5B
04DE:  CALL   314
04DF:  MOVF   58,W
04E0:  MOVWF  04
04E1:  BCF    03.7
04E2:  BTFSC  59.0
04E3:  BSF    03.7
04E4:  INCF   04,F
04E5:  BTFSC  03.2
04E6:  INCF   05,F
04E7:  GOTO   4D3
04E8:  RETURN
04E9:  CLRF   77
04EA:  CLRF   78
04EB:  MOVF   61,W
04EC:  BCF    03.0
04ED:  BTFSC  62.0
04EE:  ADDWF  77,F
04EF:  RRF    77,F
04F0:  RRF    78,F
04F1:  BTFSC  62.1
04F2:  ADDWF  77,F
04F3:  RRF    77,F
04F4:  RRF    78,F
04F5:  BTFSC  62.2
04F6:  ADDWF  77,F
04F7:  RRF    77,F
04F8:  RRF    78,F
04F9:  BTFSC  62.3
04FA:  ADDWF  77,F
04FB:  RRF    77,F
04FC:  RRF    78,F
04FD:  BTFSC  62.4
04FE:  ADDWF  77,F
04FF:  RRF    77,F
0500:  RRF    78,F
0501:  BTFSC  62.5
0502:  ADDWF  77,F
0503:  RRF    77,F
0504:  RRF    78,F
0505:  BTFSC  62.6
0506:  ADDWF  77,F
0507:  RRF    77,F
0508:  RRF    78,F
0509:  BTFSC  62.7
050A:  ADDWF  77,F
050B:  RRF    77,F
050C:  RRF    78,F
050D:  RETURN
*
0517:  MOVF   0B,W
0518:  MOVWF  59
0519:  BCF    0B.7
051A:  BSF    03.5
051B:  BSF    03.6
051C:  BSF    0C.7
051D:  BSF    0C.0
051E:  NOP
051F:  NOP
0520:  BCF    03.5
0521:  BCF    03.6
0522:  BTFSC  59.7
0523:  BSF    0B.7
0524:  BSF    03.6
0525:  MOVF   0C,F
0526:  BTFSC  03.2
0527:  GOTO   541
0528:  MOVF   0D,W
0529:  BCF    03.6
052A:  MOVWF  59
052B:  BSF    03.6
052C:  MOVF   0F,W
052D:  BCF    03.6
052E:  MOVWF  5A
052F:  BSF    03.6
0530:  MOVF   0C,W
0531:  BCF    03.6
0532:  MOVWF  5B
0533:  CALL   314
0534:  MOVF   59,W
0535:  BSF    03.6
0536:  MOVWF  0D
0537:  BCF    03.6
0538:  MOVF   5A,W
0539:  BSF    03.6
053A:  MOVWF  0F
053B:  INCF   0D,F
053C:  BTFSC  03.2
053D:  INCF   0F,F
053E:  BCF    03.6
053F:  GOTO   517
0540:  BSF    03.6
0541:  BCF    03.6
0542:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC = 16 
....................  
.................... #FUSES NOWDT      // No Watch Dog Timer 
.................... #FUSES PUT        // Power Up Timer 
.................... #FUSES NOBROWNOUT // No brownout reset 
.................... #FUSES NOLVP      // No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal = 12000000) 
*
029B:  MOVLW  59
029C:  MOVWF  04
029D:  BCF    03.7
029E:  MOVF   00,W
029F:  BTFSC  03.2
02A0:  GOTO   2AF
02A1:  MOVLW  03
02A2:  MOVWF  78
02A3:  CLRF   77
02A4:  DECFSZ 77,F
02A5:  GOTO   2A4
02A6:  DECFSZ 78,F
02A7:  GOTO   2A3
02A8:  MOVLW  E3
02A9:  MOVWF  77
02AA:  DECFSZ 77,F
02AB:  GOTO   2AA
02AC:  NOP
02AD:  DECFSZ 00,F
02AE:  GOTO   2A1
02AF:  RETURN
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PORT1) 
.................... #use i2c(Master, Fast = 400000, sda = PIN_C4, scl = PIN_C3, force_sw) 
*
0183:  MOVLW  08
0184:  MOVWF  78
0185:  NOP
0186:  BCF    07.3
0187:  BCF    2B.3
0188:  MOVF   2B,W
0189:  BSF    03.5
018A:  MOVWF  07
018B:  NOP
018C:  BCF    03.5
018D:  RLF    62,F
018E:  BCF    07.4
018F:  BTFSS  03.0
0190:  GOTO   197
0191:  BSF    2B.4
0192:  MOVF   2B,W
0193:  BSF    03.5
0194:  MOVWF  07
0195:  GOTO   19B
0196:  BCF    03.5
0197:  BCF    2B.4
0198:  MOVF   2B,W
0199:  BSF    03.5
019A:  MOVWF  07
019B:  NOP
019C:  BCF    03.5
019D:  BSF    2B.3
019E:  MOVF   2B,W
019F:  BSF    03.5
01A0:  MOVWF  07
01A1:  BCF    03.5
01A2:  BTFSS  07.3
01A3:  GOTO   1A2
01A4:  DECFSZ 78,F
01A5:  GOTO   185
01A6:  NOP
01A7:  BCF    07.3
01A8:  BCF    2B.3
01A9:  MOVF   2B,W
01AA:  BSF    03.5
01AB:  MOVWF  07
01AC:  NOP
01AD:  BCF    03.5
01AE:  BSF    2B.4
01AF:  MOVF   2B,W
01B0:  BSF    03.5
01B1:  MOVWF  07
01B2:  NOP
01B3:  NOP
01B4:  BCF    03.5
01B5:  BSF    2B.3
01B6:  MOVF   2B,W
01B7:  BSF    03.5
01B8:  MOVWF  07
01B9:  BCF    03.5
01BA:  BTFSS  07.3
01BB:  GOTO   1BA
01BC:  CLRF   78
01BD:  NOP
01BE:  BTFSC  07.4
01BF:  BSF    78.0
01C0:  BCF    07.3
01C1:  BCF    2B.3
01C2:  MOVF   2B,W
01C3:  BSF    03.5
01C4:  MOVWF  07
01C5:  BCF    03.5
01C6:  BCF    07.4
01C7:  BCF    2B.4
01C8:  MOVF   2B,W
01C9:  BSF    03.5
01CA:  MOVWF  07
01CB:  BCF    03.5
01CC:  RETURN
*
02CF:  MOVLW  08
02D0:  MOVWF  61
02D1:  MOVF   77,W
02D2:  MOVWF  62
02D3:  BSF    2B.4
02D4:  MOVF   2B,W
02D5:  BSF    03.5
02D6:  MOVWF  07
02D7:  NOP
02D8:  BCF    03.5
02D9:  BSF    2B.3
02DA:  MOVF   2B,W
02DB:  BSF    03.5
02DC:  MOVWF  07
02DD:  BCF    03.5
02DE:  BTFSS  07.3
02DF:  GOTO   2DE
02E0:  BTFSC  07.4
02E1:  BSF    03.0
02E2:  BTFSS  07.4
02E3:  BCF    03.0
02E4:  RLF    78,F
02E5:  NOP
02E6:  BCF    2B.3
02E7:  MOVF   2B,W
02E8:  BSF    03.5
02E9:  MOVWF  07
02EA:  BCF    03.5
02EB:  BCF    07.3
02EC:  DECFSZ 61,F
02ED:  GOTO   2D3
02EE:  BSF    2B.4
02EF:  MOVF   2B,W
02F0:  BSF    03.5
02F1:  MOVWF  07
02F2:  NOP
02F3:  BCF    03.5
02F4:  BCF    07.4
02F5:  MOVF   62,W
02F6:  BTFSC  03.2
02F7:  GOTO   2FD
02F8:  BCF    2B.4
02F9:  MOVF   2B,W
02FA:  BSF    03.5
02FB:  MOVWF  07
02FC:  BCF    03.5
02FD:  NOP
02FE:  BSF    2B.3
02FF:  MOVF   2B,W
0300:  BSF    03.5
0301:  MOVWF  07
0302:  BCF    03.5
0303:  BTFSS  07.3
0304:  GOTO   303
0305:  NOP
0306:  BCF    07.3
0307:  BCF    2B.3
0308:  MOVF   2B,W
0309:  BSF    03.5
030A:  MOVWF  07
030B:  NOP
030C:  BCF    03.5
030D:  BCF    07.4
030E:  BCF    2B.4
030F:  MOVF   2B,W
0310:  BSF    03.5
0311:  MOVWF  07
0312:  BCF    03.5
0313:  RETURN
....................  
.................... #define PCF8574A       // Comment for modules using PCF8574 
.................... #define A2_A1_A0 0B111 // Address pin states (A2 A1 A0) of PCF8574A/PCF8574. 
.................... #define LCD16X2        // Comment this line to use 16x2 LCD 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
05E2:  MOVF   60,W
05E3:  MOVWF  7A
05E4:  MOVF   5F,W
05E5:  MOVWF  04
05E6:  BCF    03.7
05E7:  BTFSC  7A.0
05E8:  BSF    03.7
05E9:  MOVF   00,W
05EA:  MOVWF  63
05EB:  MOVF   62,W
05EC:  MOVWF  7A
05ED:  MOVF   61,W
05EE:  MOVWF  04
05EF:  BCF    03.7
05F0:  BTFSC  7A.0
05F1:  BSF    03.7
05F2:  MOVF   00,W
05F3:  SUBWF  63,W
05F4:  BTFSS  03.2
05F5:  GOTO   60D
....................       if (*s1 == '\0') 
05F6:  MOVF   60,W
05F7:  MOVWF  7A
05F8:  MOVF   5F,W
05F9:  MOVWF  04
05FA:  BCF    03.7
05FB:  BTFSC  7A.0
05FC:  BSF    03.7
05FD:  MOVF   00,F
05FE:  BTFSS  03.2
05FF:  GOTO   603
....................          return(0); 
0600:  MOVLW  00
0601:  MOVWF  78
0602:  GOTO   625
0603:  MOVF   60,W
0604:  MOVWF  7A
0605:  MOVF   5F,W
0606:  INCF   5F,F
0607:  BTFSC  03.2
0608:  INCF   60,F
0609:  INCF   61,F
060A:  BTFSC  03.2
060B:  INCF   62,F
060C:  GOTO   5E2
....................    return((*s1 < *s2) ? -1: 1); 
060D:  MOVF   60,W
060E:  MOVWF  7A
060F:  MOVF   5F,W
0610:  MOVWF  04
0611:  BCF    03.7
0612:  BTFSC  60.0
0613:  BSF    03.7
0614:  MOVF   00,W
0615:  MOVWF  63
0616:  MOVF   62,W
0617:  MOVWF  7A
0618:  MOVF   61,W
0619:  MOVWF  04
061A:  BCF    03.7
061B:  BTFSC  62.0
061C:  BSF    03.7
061D:  MOVF   00,W
061E:  SUBWF  63,W
061F:  BTFSC  03.0
0620:  GOTO   623
0621:  MOVLW  FF
0622:  GOTO   624
0623:  MOVLW  01
0624:  MOVWF  78
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0828:  BCF    03.6
0829:  CLRF   2C
082A:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <lcd_i2c.c> 
.................... #define RIGHT 0x1C 
.................... #define LEFT 0x18 
....................  
.................... #define CURSOR_ON 2 
.................... #define CURSOR_OFF 0 
....................  
.................... #define BLINK_ON 1 
.................... #define BLINK_OFF 0 
....................  
.................... #define BL_ON 0x08 
.................... #define BL_OFF 0x00 
....................  
.................... #ifdef PCF8574A 
.................... #define pcf_address_write 0x70 | (A2_A1_A0 << 1) 
.................... #define pcf_address_read 0x71 | (A2_A1_A0 << 1) 
.................... #else // PCF8574 
.................... #define pcf_address_write 0x40 | (A2_A1_A0 << 1) 
.................... #define pcf_address_read 0x41 | (A2_A1_A0 << 1) 
.................... #endif 
....................  
.................... #ifdef LCD20X4 
.................... #define line1_start 0x00 
.................... #define line1_end 0x13 
....................  
.................... #define line2_start 0x40 
.................... #define line2_end 0x53 
....................  
.................... #define line3_start 0x14 
.................... #define line3_end 0x27 
....................  
.................... #define line4_start 0x54 
.................... #define line4_end 0x67 
....................  
.................... #define line1_start_command 0x80 
.................... #define line2_start_command 0xC0 
.................... #define line3_start_command 0x94 
.................... #define line4_start_command 0xD4 
.................... #else LCD16X2 
.................... #define line1_start 0x00 
.................... #define line1_end 0x27 
....................  
.................... #define line2_start 0x40 
.................... #define line2_end 0x67 
....................  
.................... #define line1_start_command 0x80 
.................... #define line2_start_command 0xC0 
.................... #endif 
....................  
.................... int backlight_lcd_i2c = 0x08, lcd_i2c_line = 1; 
....................  
.................... void initialize_lcd_i2c() 
.................... { 
....................     i2c_start();                  // Start communication 
*
01CD:  BSF    2B.4
01CE:  MOVF   2B,W
01CF:  BSF    03.5
01D0:  MOVWF  07
01D1:  NOP
01D2:  BCF    03.5
01D3:  BSF    2B.3
01D4:  MOVF   2B,W
01D5:  BSF    03.5
01D6:  MOVWF  07
01D7:  NOP
01D8:  BCF    03.5
01D9:  BCF    07.4
01DA:  BCF    2B.4
01DB:  MOVF   2B,W
01DC:  BSF    03.5
01DD:  MOVWF  07
01DE:  NOP
01DF:  BCF    03.5
01E0:  BCF    07.3
01E1:  BCF    2B.3
01E2:  MOVF   2B,W
01E3:  BSF    03.5
01E4:  MOVWF  07
....................     i2c_write(pcf_address_write); // Send PCF address + WRITE bit 
01E5:  MOVLW  7E
01E6:  BCF    03.5
01E7:  MOVWF  62
01E8:  CALL   183
....................     i2c_write(0x2C);              // Configure LCD for 4 bits/BL ON/En 1 
01E9:  MOVLW  2C
01EA:  MOVWF  62
01EB:  CALL   183
....................     i2c_write(0x28);              // En 0 to execute instruction 
01EC:  MOVLW  28
01ED:  MOVWF  62
01EE:  CALL   183
....................  
....................     delay_us(40);    // Verify the delay for bits to be sent 
01EF:  MOVLW  27
01F0:  MOVWF  77
01F1:  DECFSZ 77,F
01F2:  GOTO   1F1
01F3:  GOTO   1F4
....................     i2c_write(0x2C); // Send first nibble of 
01F4:  MOVLW  2C
01F5:  MOVWF  62
01F6:  CALL   183
....................     i2c_write(0x28); // the "Function Set" instruction. 
01F7:  MOVLW  28
01F8:  MOVWF  62
01F9:  CALL   183
....................     i2c_write(0x8C); // Send second nibble of the instruction. 
01FA:  MOVLW  8C
01FB:  MOVWF  62
01FC:  CALL   183
....................     i2c_write(0x88); // 4 bits, 2 lines, font 5*8. 
01FD:  MOVLW  88
01FE:  MOVWF  62
01FF:  CALL   183
....................  
....................     delay_us(40); 
0200:  MOVLW  27
0201:  MOVWF  77
0202:  DECFSZ 77,F
0203:  GOTO   202
0204:  GOTO   205
....................  
....................     i2c_write(0x0C); // Send first nibble of 
0205:  MOVLW  0C
0206:  MOVWF  62
0207:  CALL   183
....................     i2c_write(0x08); // "Display ON/OFF control" instruction. 
0208:  MOVLW  08
0209:  MOVWF  62
020A:  CALL   183
....................     i2c_write(0xCC); // Send second nibble of the instruction. 
020B:  MOVLW  CC
020C:  MOVWF  62
020D:  CALL   183
....................     i2c_write(0xC8); // Display on, cursor off, blink off. 
020E:  MOVLW  C8
020F:  MOVWF  62
0210:  CALL   183
....................     delay_us(1); 
0211:  GOTO   212
0212:  NOP
....................  
....................     i2c_write(0x0C); // Send first nibble of 
0213:  MOVLW  0C
0214:  MOVWF  62
0215:  CALL   183
....................     i2c_write(0x08); // "Entry Mode Set" instruction. 
0216:  MOVLW  08
0217:  MOVWF  62
0218:  CALL   183
....................     i2c_write(0x6C); // Send second nibble of the instruction. 
0219:  MOVLW  6C
021A:  MOVWF  62
021B:  CALL   183
....................     i2c_write(0x68); // Increment cursor with each write 
021C:  MOVLW  68
021D:  MOVWF  62
021E:  CALL   183
....................                      // (position+=1), LCD scroll disabled; 
....................                      // if enabled, display scrolls with each character. 
....................     delay_us(40); 
021F:  MOVLW  27
0220:  MOVWF  77
0221:  DECFSZ 77,F
0222:  GOTO   221
0223:  GOTO   224
....................  
....................     i2c_stop(); 
0224:  BCF    2B.4
0225:  MOVF   2B,W
0226:  BSF    03.5
0227:  MOVWF  07
0228:  NOP
0229:  BCF    03.5
022A:  BSF    2B.3
022B:  MOVF   2B,W
022C:  BSF    03.5
022D:  MOVWF  07
022E:  BCF    03.5
022F:  BTFSS  07.3
0230:  GOTO   22F
0231:  NOP
0232:  GOTO   233
0233:  NOP
0234:  BSF    2B.4
0235:  MOVF   2B,W
0236:  BSF    03.5
0237:  MOVWF  07
0238:  NOP
0239:  BCF    03.5
023A:  BSF    0A.3
023B:  BCF    0A.4
023C:  GOTO   02D (RETURN)
.................... } 
.................... void send_lcd_i2c_command(char character) 
.................... { 
....................     int ms_nibble_e, ls_nibble_e, ms_nibble, ls_nibble; 
....................  
....................     ms_nibble = character & 0xF0;   // Most significant nibble of the character. 
*
0246:  MOVF   5D,W
0247:  ANDLW  F0
0248:  MOVWF  60
....................     ls_nibble = character & 0x0F;   // Least significant nibble of the character. 
0249:  MOVF   5D,W
024A:  ANDLW  0F
024B:  MOVWF  61
....................     swap(ls_nibble);                // Swap as the most significant bits are used (D7: D4). 
024C:  SWAPF  61,F
....................     ms_nibble |= backlight_lcd_i2c; // Add BL to the most significant nibble 
024D:  MOVF   2E,W
024E:  IORWF  60,F
....................     ls_nibble |= backlight_lcd_i2c; // Add BL to the least significant nibble 
024F:  MOVF   2E,W
0250:  IORWF  61,F
....................  
....................     ms_nibble_e = ms_nibble | 0x04; // Most significant nibble En 1 
0251:  MOVF   60,W
0252:  IORLW  04
0253:  MOVWF  5E
....................     ls_nibble_e = ls_nibble | 0x04; // Least significant nibble En 1 
0254:  MOVF   61,W
0255:  IORLW  04
0256:  MOVWF  5F
....................  
....................     i2c_start(); 
0257:  BSF    2B.4
0258:  MOVF   2B,W
0259:  BSF    03.5
025A:  MOVWF  07
025B:  NOP
025C:  BCF    03.5
025D:  BSF    2B.3
025E:  MOVF   2B,W
025F:  BSF    03.5
0260:  MOVWF  07
0261:  NOP
0262:  BCF    03.5
0263:  BCF    07.4
0264:  BCF    2B.4
0265:  MOVF   2B,W
0266:  BSF    03.5
0267:  MOVWF  07
0268:  NOP
0269:  BCF    03.5
026A:  BCF    07.3
026B:  BCF    2B.3
026C:  MOVF   2B,W
026D:  BSF    03.5
026E:  MOVWF  07
....................     i2c_write(pcf_address_write); 
026F:  MOVLW  7E
0270:  BCF    03.5
0271:  MOVWF  62
0272:  CALL   183
....................  
....................     i2c_write(ms_nibble_e); // Send 1st nibble with "E" set 
0273:  MOVF   5E,W
0274:  MOVWF  62
0275:  CALL   183
....................     i2c_write(ms_nibble);   // Send 1st nibble with "E" cleared 
0276:  MOVF   60,W
0277:  MOVWF  62
0278:  CALL   183
....................  
....................     i2c_write(ls_nibble_e); // Send 2nd nibble with "E" set 
0279:  MOVF   5F,W
027A:  MOVWF  62
027B:  CALL   183
....................     i2c_write(ls_nibble);   // Send 2nd nibble with "E" cleared 
027C:  MOVF   61,W
027D:  MOVWF  62
027E:  CALL   183
....................  
....................     i2c_stop(); 
027F:  BCF    2B.4
0280:  MOVF   2B,W
0281:  BSF    03.5
0282:  MOVWF  07
0283:  NOP
0284:  BCF    03.5
0285:  BSF    2B.3
0286:  MOVF   2B,W
0287:  BSF    03.5
0288:  MOVWF  07
0289:  BCF    03.5
028A:  BTFSS  07.3
028B:  GOTO   28A
028C:  NOP
028D:  GOTO   28E
028E:  NOP
028F:  BSF    2B.4
0290:  MOVF   2B,W
0291:  BSF    03.5
0292:  MOVWF  07
0293:  NOP
....................     delay_us(44); 
0294:  MOVLW  2B
0295:  MOVWF  77
0296:  DECFSZ 77,F
0297:  GOTO   296
0298:  GOTO   299
0299:  BCF    03.5
029A:  RETURN
.................... } 
.................... void send_lcd_i2c_character(int character) 
.................... { 
....................     int ms_nibble_e, ls_nibble_e, ms_nibble, ls_nibble; 
....................  
....................     ms_nibble = character & 0xF0; // Most significant nibble of the character. 
*
040B:  MOVF   5D,W
040C:  ANDLW  F0
040D:  MOVWF  60
....................     ls_nibble = character & 0x0F; // Least significant nibble of the character. 
040E:  MOVF   5D,W
040F:  ANDLW  0F
0410:  MOVWF  61
....................     swap(ls_nibble);              // Swap as the most significant bits are used (D7: D4). 
0411:  SWAPF  61,F
....................  
....................     ms_nibble |= backlight_lcd_i2c; // Add BL to the most significant nibble 
0412:  MOVF   2E,W
0413:  IORWF  60,F
....................     ls_nibble |= backlight_lcd_i2c; // Add BL to the least significant nibble 
0414:  MOVF   2E,W
0415:  IORWF  61,F
....................     ms_nibble++;                    // Set RS bit 
0416:  INCF   60,F
....................     ls_nibble++;                    // Set RS bit 
0417:  INCF   61,F
....................  
....................     ms_nibble_e = ms_nibble | 0x05; // Most significant nibble En and RS = 1 
0418:  MOVF   60,W
0419:  IORLW  05
041A:  MOVWF  5E
....................     ls_nibble_e = ls_nibble | 0x05; // Least significant nibble En and RS = 1 
041B:  MOVF   61,W
041C:  IORLW  05
041D:  MOVWF  5F
....................  
....................     i2c_start(); 
041E:  BSF    2B.4
041F:  MOVF   2B,W
0420:  BSF    03.5
0421:  MOVWF  07
0422:  NOP
0423:  BCF    03.5
0424:  BSF    2B.3
0425:  MOVF   2B,W
0426:  BSF    03.5
0427:  MOVWF  07
0428:  NOP
0429:  BCF    03.5
042A:  BCF    07.4
042B:  BCF    2B.4
042C:  MOVF   2B,W
042D:  BSF    03.5
042E:  MOVWF  07
042F:  NOP
0430:  BCF    03.5
0431:  BCF    07.3
0432:  BCF    2B.3
0433:  MOVF   2B,W
0434:  BSF    03.5
0435:  MOVWF  07
....................     i2c_write(pcf_address_write); 
0436:  MOVLW  7E
0437:  BCF    03.5
0438:  MOVWF  62
0439:  CALL   183
....................  
....................     i2c_write(ms_nibble_e); // Send 1st nibble with RS and En 1 
043A:  MOVF   5E,W
043B:  MOVWF  62
043C:  CALL   183
....................     i2c_write(ms_nibble);   // Send 1st nibble with RS 1 and E 0 
043D:  MOVF   60,W
043E:  MOVWF  62
043F:  CALL   183
....................  
....................     i2c_write(ls_nibble_e); // Send 2nd nibble with RS and E 1 
0440:  MOVF   5F,W
0441:  MOVWF  62
0442:  CALL   183
....................     i2c_write(ls_nibble);   // Send 2nd nibble with RS 0 and E 0 
0443:  MOVF   61,W
0444:  MOVWF  62
0445:  CALL   183
....................  
....................     i2c_stop(); 
0446:  BCF    2B.4
0447:  MOVF   2B,W
0448:  BSF    03.5
0449:  MOVWF  07
044A:  NOP
044B:  BCF    03.5
044C:  BSF    2B.3
044D:  MOVF   2B,W
044E:  BSF    03.5
044F:  MOVWF  07
0450:  BCF    03.5
0451:  BTFSS  07.3
0452:  GOTO   451
0453:  NOP
0454:  GOTO   455
0455:  NOP
0456:  BSF    2B.4
0457:  MOVF   2B,W
0458:  BSF    03.5
0459:  MOVWF  07
045A:  NOP
....................     delay_us(44); 
045B:  MOVLW  2B
045C:  MOVWF  77
045D:  DECFSZ 77,F
045E:  GOTO   45D
045F:  GOTO   460
.................... } 
.................... void clear_lcd_i2c() 
.................... { 
....................     send_lcd_i2c_command(0x01); 
*
02B0:  MOVLW  01
02B1:  MOVWF  5D
02B2:  CALL   246
....................     delay_ms(2); 
02B3:  MOVLW  02
02B4:  MOVWF  59
02B5:  CALL   29B
02B6:  RETURN
.................... } 
.................... int read_cursor_address() 
.................... { 
....................     int aux, aux2, address; 
....................  
....................     aux = 0xF2 | backlight_lcd_i2c; // Set PCF pins for D7:D4 of LCD E=0 | RW=1 | RS=0. 
*
032C:  MOVF   2E,W
032D:  IORLW  F2
032E:  MOVWF  5D
....................     aux2 = aux;                     // Copy aux value 
032F:  MOVF   5D,W
0330:  MOVWF  5E
....................  
....................     i2c_start(); 
0331:  BSF    2B.4
0332:  MOVF   2B,W
0333:  BSF    03.5
0334:  MOVWF  07
0335:  NOP
0336:  BCF    03.5
0337:  BSF    2B.3
0338:  MOVF   2B,W
0339:  BSF    03.5
033A:  MOVWF  07
033B:  NOP
033C:  BCF    03.5
033D:  BCF    07.4
033E:  BCF    2B.4
033F:  MOVF   2B,W
0340:  BSF    03.5
0341:  MOVWF  07
0342:  NOP
0343:  BCF    03.5
0344:  BCF    07.3
0345:  BCF    2B.3
0346:  MOVF   2B,W
0347:  BSF    03.5
0348:  MOVWF  07
....................     i2c_write(pcf_address_write); 
0349:  MOVLW  7E
034A:  BCF    03.5
034B:  MOVWF  62
034C:  CALL   183
....................     i2c_write(aux);        // Set PCF pins for D7:D4 of LCD E=0 | RW=1 | RS=0. 
034D:  MOVF   5D,W
034E:  MOVWF  62
034F:  CALL   183
....................     i2c_write(aux | 0x04); // En=1 for LCD to provide most significant nibble. 
0350:  MOVF   5D,W
0351:  IORLW  04
0352:  MOVWF  60
0353:  MOVWF  62
0354:  CALL   183
....................     i2c_start(); 
0355:  BSF    2B.4
0356:  MOVF   2B,W
0357:  BSF    03.5
0358:  MOVWF  07
0359:  NOP
035A:  BCF    03.5
035B:  BSF    2B.3
035C:  MOVF   2B,W
035D:  BSF    03.5
035E:  MOVWF  07
035F:  NOP
0360:  BCF    03.5
0361:  BTFSS  07.3
0362:  GOTO   361
0363:  BCF    07.4
0364:  BCF    2B.4
0365:  MOVF   2B,W
0366:  BSF    03.5
0367:  MOVWF  07
0368:  NOP
0369:  BCF    03.5
036A:  BCF    07.3
036B:  BCF    2B.3
036C:  MOVF   2B,W
036D:  BSF    03.5
036E:  MOVWF  07
....................     i2c_write(pcf_address_read); 
036F:  MOVLW  7F
0370:  BCF    03.5
0371:  MOVWF  62
0372:  CALL   183
....................     address = 0x70 & i2c_read(0); // Read most significant nibble with mask 0x70. 
0373:  CLRF   77
0374:  CALL   2CF
0375:  MOVF   78,W
0376:  ANDLW  70
0377:  MOVWF  5F
....................     i2c_start(); 
0378:  BSF    2B.4
0379:  MOVF   2B,W
037A:  BSF    03.5
037B:  MOVWF  07
037C:  NOP
037D:  BCF    03.5
037E:  BSF    2B.3
037F:  MOVF   2B,W
0380:  BSF    03.5
0381:  MOVWF  07
0382:  NOP
0383:  BCF    03.5
0384:  BTFSS  07.3
0385:  GOTO   384
0386:  BCF    07.4
0387:  BCF    2B.4
0388:  MOVF   2B,W
0389:  BSF    03.5
038A:  MOVWF  07
038B:  NOP
038C:  BCF    03.5
038D:  BCF    07.3
038E:  BCF    2B.3
038F:  MOVF   2B,W
0390:  BSF    03.5
0391:  MOVWF  07
....................     i2c_write(pcf_address_write); 
0392:  MOVLW  7E
0393:  BCF    03.5
0394:  MOVWF  62
0395:  CALL   183
....................     i2c_write(aux);        // Clear Enable pin of LCD 
0396:  MOVF   5D,W
0397:  MOVWF  62
0398:  CALL   183
....................     i2c_write(aux | 0x04); // Set Enable pin of LCD to provide least significant nibble. 
0399:  MOVF   5D,W
039A:  IORLW  04
039B:  MOVWF  60
039C:  MOVWF  62
039D:  CALL   183
....................     i2c_start(); 
039E:  BSF    2B.4
039F:  MOVF   2B,W
03A0:  BSF    03.5
03A1:  MOVWF  07
03A2:  NOP
03A3:  BCF    03.5
03A4:  BSF    2B.3
03A5:  MOVF   2B,W
03A6:  BSF    03.5
03A7:  MOVWF  07
03A8:  NOP
03A9:  BCF    03.5
03AA:  BTFSS  07.3
03AB:  GOTO   3AA
03AC:  BCF    07.4
03AD:  BCF    2B.4
03AE:  MOVF   2B,W
03AF:  BSF    03.5
03B0:  MOVWF  07
03B1:  NOP
03B2:  BCF    03.5
03B3:  BCF    07.3
03B4:  BCF    2B.3
03B5:  MOVF   2B,W
03B6:  BSF    03.5
03B7:  MOVWF  07
....................     i2c_write(pcf_address_read); 
03B8:  MOVLW  7F
03B9:  BCF    03.5
03BA:  MOVWF  62
03BB:  CALL   183
....................     aux = 0xF0 & i2c_read(0); // Read least significant nibble with mask 0xF0. 
03BC:  CLRF   77
03BD:  CALL   2CF
03BE:  MOVF   78,W
03BF:  ANDLW  F0
03C0:  MOVWF  5D
....................     i2c_start(); 
03C1:  BSF    2B.4
03C2:  MOVF   2B,W
03C3:  BSF    03.5
03C4:  MOVWF  07
03C5:  NOP
03C6:  BCF    03.5
03C7:  BSF    2B.3
03C8:  MOVF   2B,W
03C9:  BSF    03.5
03CA:  MOVWF  07
03CB:  NOP
03CC:  BCF    03.5
03CD:  BTFSS  07.3
03CE:  GOTO   3CD
03CF:  BCF    07.4
03D0:  BCF    2B.4
03D1:  MOVF   2B,W
03D2:  BSF    03.5
03D3:  MOVWF  07
03D4:  NOP
03D5:  BCF    03.5
03D6:  BCF    07.3
03D7:  BCF    2B.3
03D8:  MOVF   2B,W
03D9:  BSF    03.5
03DA:  MOVWF  07
....................     i2c_write(pcf_address_write); 
03DB:  MOVLW  7E
03DC:  BCF    03.5
03DD:  MOVWF  62
03DE:  CALL   183
....................     i2c_write(aux2); // Clear Enable pin first 
03DF:  MOVF   5E,W
03E0:  MOVWF  62
03E1:  CALL   183
....................     aux2 &= 0xF8; 
03E2:  MOVLW  F8
03E3:  ANDWF  5E,F
....................     i2c_write(aux2); // Clear RW pin to exit read mode. 
03E4:  MOVF   5E,W
03E5:  MOVWF  62
03E6:  CALL   183
....................     i2c_stop(); 
03E7:  BCF    2B.4
03E8:  MOVF   2B,W
03E9:  BSF    03.5
03EA:  MOVWF  07
03EB:  NOP
03EC:  BCF    03.5
03ED:  BSF    2B.3
03EE:  MOVF   2B,W
03EF:  BSF    03.5
03F0:  MOVWF  07
03F1:  BCF    03.5
03F2:  BTFSS  07.3
03F3:  GOTO   3F2
03F4:  NOP
03F5:  GOTO   3F6
03F6:  NOP
03F7:  BSF    2B.4
03F8:  MOVF   2B,W
03F9:  BSF    03.5
03FA:  MOVWF  07
03FB:  NOP
....................  
....................     swap(aux);      // Position least significant nibble correctly. 
03FC:  BCF    03.5
03FD:  SWAPF  5D,F
....................     address |= aux; // OR operation between least and most significant nibble. 
03FE:  MOVF   5D,W
03FF:  IORWF  5F,F
....................     delay_us(45); 
0400:  MOVLW  2C
0401:  MOVWF  77
0402:  DECFSZ 77,F
0403:  GOTO   402
0404:  GOTO   405
....................     return (address); // Return current cursor address. 
0405:  MOVF   5F,W
0406:  MOVWF  78
.................... } 
.................... void write_lcd_i2c(char character) 
.................... { 
....................     int cursor_address; 
....................  
....................     if (character == '\n') 
*
0314:  MOVF   5B,W
0315:  SUBLW  0A
0316:  BTFSS  03.2
0317:  GOTO   32C
....................     {          // Position cursor at the start of the next line. 
.................... #ifdef LCD20X4 // Using LCD 20 x 4 
....................         switch (lcd_i2c_line) 
....................         { 
....................         case 1: 
....................             send_lcd_i2c_command(line2_start_command); 
....................             lcd_i2c_line = 2; 
....................             break; 
....................         case 2: 
....................             send_lcd_i2c_command(line3_start_command); 
....................             lcd_i2c_line = 3; 
....................             break; 
....................         case 3: 
....................             send_lcd_i2c_command(line4_start_command); 
....................             lcd_i2c_line = 4; 
....................             break; 
....................         case 4: 
....................             send_lcd_i2c_command(line1_start_command); 
....................             lcd_i2c_line = 1; 
....................             break; 
....................         } 
.................... #else // Using LCD 16 x 2 
....................         switch (lcd_i2c_line) 
0318:  MOVF   2F,W
0319:  XORLW  01
031A:  BTFSC  03.2
031B:  GOTO   320
031C:  XORLW  03
031D:  BTFSC  03.2
031E:  GOTO   326
031F:  GOTO   32B
....................         { 
....................         case 1: 
....................             send_lcd_i2c_command(line2_start_command); 
0320:  MOVLW  C0
0321:  MOVWF  5D
0322:  CALL   246
....................             lcd_i2c_line = 2; 
0323:  MOVLW  02
0324:  MOVWF  2F
....................             break; 
0325:  GOTO   32B
....................         case 2: 
....................             send_lcd_i2c_command(line1_start_command); 
0326:  MOVLW  80
0327:  MOVWF  5D
0328:  CALL   246
....................             lcd_i2c_line = 1; 
0329:  MOVLW  01
032A:  MOVWF  2F
....................             break; 
....................         } 
.................... #endif 
....................     } 
032B:  GOTO   47C
....................     else 
....................     { 
....................         cursor_address = read_cursor_address(); 
*
0407:  MOVF   78,W
0408:  MOVWF  5C
....................         send_lcd_i2c_character(character); 
0409:  MOVF   5B,W
040A:  MOVWF  5D
.................... #ifdef LCD20X4 // Using LCD 20 x 4 
....................         switch (lcd_i2c_line) 
....................         { 
....................         case 1: 
....................             if (cursor_address == line1_end) 
....................             { 
....................                 send_lcd_i2c_command(line2_start_command); 
....................                 lcd_i2c_line = 2; 
....................             } 
....................             break; 
....................         case 2: 
....................             if (cursor_address == line2_end) 
....................             { 
....................                 send_lcd_i2c_command(line3_start_command); 
....................                 lcd_i2c_line = 3; 
....................             } 
....................             break; 
....................         case 3: 
....................             if (cursor_address == line3_end) 
....................             { 
....................                 send_lcd_i2c_command(line4_start_command); 
....................                 lcd_i2c_line = 4; 
....................             } 
....................             break; 
....................         case 4: 
....................             if (cursor_address == line4_end) 
....................             { 
....................                 send_lcd_i2c_command(line1_start_command); 
....................                 lcd_i2c_line = 1; 
....................             } 
....................             break; 
....................         } 
.................... #else // Using LCD 16 x 2 
....................         switch (lcd_i2c_line) 
*
0460:  BCF    03.5
0461:  MOVF   2F,W
0462:  XORLW  01
0463:  BTFSC  03.2
0464:  GOTO   469
0465:  XORLW  03
0466:  BTFSC  03.2
0467:  GOTO   473
0468:  GOTO   47C
....................         { 
....................         case 1: 
....................             if (cursor_address == line1_end) 
0469:  MOVF   5C,W
046A:  SUBLW  27
046B:  BTFSS  03.2
046C:  GOTO   472
....................             { 
....................                 send_lcd_i2c_command(line2_start_command); 
046D:  MOVLW  C0
046E:  MOVWF  5D
046F:  CALL   246
....................                 lcd_i2c_line = 2; 
0470:  MOVLW  02
0471:  MOVWF  2F
....................             } 
....................             break; 
0472:  GOTO   47C
....................         case 2: 
....................             if (cursor_address == line2_end) 
0473:  MOVF   5C,W
0474:  SUBLW  67
0475:  BTFSS  03.2
0476:  GOTO   47C
....................             { 
....................                 send_lcd_i2c_command(line1_start_command); 
0477:  MOVLW  80
0478:  MOVWF  5D
0479:  CALL   246
....................                 lcd_i2c_line = 1; 
047A:  MOVLW  01
047B:  MOVWF  2F
....................             } 
....................             break; 
....................         } 
.................... #endif 
....................     } 
047C:  RETURN
.................... } 
.................... void send_lcd_i2c_string(char *string) 
.................... { 
....................     while (*string) 
....................         write_lcd_i2c(*string++); 
.................... } 
.................... void set_lcd_i2c_cursor_position(char x, char y) 
.................... { 
....................     switch (x) 
*
02B7:  MOVF   58,W
02B8:  XORLW  01
02B9:  BTFSC  03.2
02BA:  GOTO   2BF
02BB:  XORLW  03
02BC:  BTFSC  03.2
02BD:  GOTO   2C7
02BE:  GOTO   2CE
....................     { 
....................     case 1:                                            // Line 1 
....................         send_lcd_i2c_command(line1_start_command + y); // Position command. 
02BF:  MOVLW  80
02C0:  ADDWF  59,W
02C1:  MOVWF  5A
02C2:  MOVWF  5D
02C3:  CALL   246
....................         lcd_i2c_line = 1;                              // Assign current line for write control. 
02C4:  MOVLW  01
02C5:  MOVWF  2F
....................         break; 
02C6:  GOTO   2CE
....................     case 2:                                            // Line 2 
....................         send_lcd_i2c_command(line2_start_command + y); // Position command. 
02C7:  MOVLW  C0
02C8:  ADDWF  59,W
02C9:  MOVWF  5A
02CA:  MOVWF  5D
02CB:  CALL   246
....................         lcd_i2c_line = 2;                              // Assign current line for write control. 
02CC:  MOVLW  02
02CD:  MOVWF  2F
....................         break; 
.................... #ifdef LCD20X4                                 // Using LCD 20 x 4 
....................     case 3:                                    // Line 3 
....................         send_lcd_i2c_command(line3_start + y); // Position command. 
....................         lcd_i2c_line = 3;                      // Assign current line for write control. 
....................         break; 
....................     case 4:                                    // Line 4 
....................         send_lcd_i2c_command(line4_start + y); // Position command. 
....................         lcd_i2c_line = 4;                      // Assign current line for write control. 
....................         break; 
.................... #endif 
....................     } 
02CE:  RETURN
.................... } 
.................... void configure_lcd_i2c(int cursor, int blink, int backlight) 
.................... { 
....................     int aux; 
....................     backlight_lcd_i2c = 0x08 * backlight; // Set backlight status. 
....................  
....................     aux = 0x08 | (cursor << 1) | blink; // Combine bits to form the control byte 
....................     send_lcd_i2c_command(aux);          // Send control command to the LCD 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... const unsigned int16 DOT_DURATION = 200; 
.................... const unsigned int16 DASH_DURATION = 600; 
....................  
.................... const int8 SW_Pin[] = {Pin_B0, Pin_B1, Pin_B2, Pin_B3, Pin_B4}; 
.................... // int8 SW_Pin = Pin_B0; // Assuming only one button for Morse code input 
....................  
.................... const int8 LED_Pin = Pin_D0; 
.................... const int8 Buzzer_Pin = Pin_D1; 
....................  
.................... unsigned int16 elapsedTime = 0; 
....................  
.................... unsigned int8 morseCodeBufferString[6]; 
.................... unsigned int8 morseCodeBufferIndex = 0; 
....................  
.................... unsigned int8 morseCodeString[16]; 
.................... unsigned int8 morseCodeStringIndex = 0; 
....................  
.................... typedef struct 
.................... { 
....................     char morseCode[6]; 
....................     char character; 
.................... } MorseCode; 
....................  
.................... const MorseCode morseCodeTable[] = { 
....................     {".-", 'A'}, {"-...", 'B'}, {"-.-.", 'C'}, {"-..", 'D'}, {".", 'E'}, {"..-.", 'F'}, {"--.", 'G'}, {"....", 'H'}, {"..", 'I'}, {".---", 'J'}, {"-.-", 'K'}, {".-..", 'L'}, {"--", 'M'}, {"-.", 'N'}, {"---", 'O'}, {".--.", 'P'}, {"--.-", 'Q'}, {".-.", 'R'}, {"...", 'S'}, {"-", 'T'}, {"..-", 'U'}, {"...-", 'V'}, {".--", 'W'}, {"-..-", 'X'}, {"-.--", 'Y'}, {"--..", 'Z'}, {"-----", '0'}, {".----", '1'}, {"..---", '2'}, {"...--", '3'}, {"....-", '4'}, {".....", '5'}, {"-....", '6'}, {"--...", '7'}, {"---..", '8'}, {"----.", '9'}}; 
....................  
.................... #INT_TIMER1 
.................... void An389_Interrupt() 
.................... { 
....................     elapsedTime++; 
*
0154:  INCF   30,F
0155:  BTFSC  03.2
0156:  INCF   31,F
....................     set_timer1(65036); 
0157:  CLRF   0E
0158:  MOVLW  FE
0159:  MOVWF  0F
015A:  MOVLW  0C
015B:  MOVWF  0E
....................     clear_interrupt(INT_TIMER1); 
015C:  BCF    0C.0
015D:  BCF    0C.0
015E:  BCF    0A.3
015F:  BCF    0A.4
0160:  GOTO   02D
.................... } 
....................  
.................... void startTimer() 
.................... { 
....................     elapsedTime = 0; 
*
0548:  CLRF   31
0549:  CLRF   30
....................  
....................     // setup timer1, 1ms interrupt, 16MHz, timer1 16 bit, prescaler 1:8 
....................     // 16MHz / 4 = 4MHz 
....................     // 4MHz / 8 = 500KHz 
....................     // 1 / 500KHz = 2us 
....................     // 1ms / 2us = 500 
....................     // 65536 - 500 = 65036 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
054A:  MOVLW  35
054B:  MOVWF  10
....................     set_timer1(65036); 
054C:  CLRF   0E
054D:  MOVLW  FE
054E:  MOVWF  0F
054F:  MOVLW  0C
0550:  MOVWF  0E
....................     enable_interrupts(INT_TIMER1); 
0551:  BSF    03.5
0552:  BSF    0C.0
....................     enable_interrupts(GLOBAL); 
0553:  MOVLW  C0
0554:  BCF    03.5
0555:  IORWF  0B,F
.................... } 
....................  
.................... unsigned int16 stopAndReadTimer() 
.................... { 
....................     disable_interrupts(INT_TIMER1); 
*
0582:  BSF    03.5
0583:  BCF    0C.0
....................     disable_interrupts(GLOBAL); 
0584:  BCF    03.5
0585:  BCF    0B.6
0586:  BCF    0B.7
0587:  BTFSC  0B.7
0588:  GOTO   586
....................     return elapsedTime; 
0589:  MOVF   30,W
058A:  MOVWF  78
058B:  MOVF   31,W
058C:  MOVWF  79
.................... } 
....................  
.................... void appendMorseCode(char morseChar) 
.................... { 
....................     morseCodeBufferString[morseCodeBufferIndex++] = morseChar; 
*
05A2:  MOVF   38,W
05A3:  INCF   38,F
05A4:  ADDLW  32
05A5:  MOVWF  04
05A6:  BCF    03.7
05A7:  MOVF   59,W
05A8:  MOVWF  00
....................     morseCodeBufferString[morseCodeBufferIndex] = '\0'; // Null-terminate the string 
05A9:  MOVLW  32
05AA:  ADDWF  38,W
05AB:  MOVWF  04
05AC:  BCF    03.7
05AD:  CLRF   00
.................... } 
....................  
.................... void clearMorseCodeBuffer() 
.................... { 
....................     memset(morseCodeBufferString, 0, sizeof(morseCodeBufferString)); 
*
050E:  MOVLW  32
050F:  MOVWF  04
0510:  BCF    03.7
0511:  CLRF   77
0512:  MOVLW  06
0513:  MOVWF  78
0514:  CALL   23D
....................     morseCodeBufferIndex = 0; 
0515:  CLRF   38
0516:  RETURN
.................... } 
....................  
.................... void clearMorseCodeString() 
.................... { 
....................     memset(morseCodeString, 0, sizeof(morseCodeString)); 
*
079A:  MOVLW  39
079B:  MOVWF  04
079C:  BCF    03.7
079D:  CLRF   77
079E:  MOVLW  10
079F:  MOVWF  78
07A0:  CALL   23D
....................     morseCodeStringIndex = 0; 
07A1:  CLRF   49
.................... } 
....................  
.................... void translateMorseCode() 
.................... { 
....................     for (int i = 0; i < sizeof(morseCodeTable) / sizeof(MorseCode); ++i) 
*
05BF:  CLRF   58
05C0:  MOVF   58,W
05C1:  SUBLW  23
05C2:  BTFSS  03.0
05C3:  GOTO   63B
....................     { 
....................         char temp[6]; 
....................         strcpy(temp, morseCodeTable[i].morseCode); 
05C4:  MOVF   58,W
05C5:  MOVWF  61
05C6:  MOVLW  07
05C7:  MOVWF  62
05C8:  CALL   4E9
05C9:  MOVF   78,W
05CA:  MOVWF  5F
05CB:  CLRF   60
05CC:  MOVF   5F,W
05CD:  MOVWF  61
05CE:  MOVLW  59
05CF:  MOVWF  04
05D0:  BCF    03.7
05D1:  MOVF   60,W
05D2:  ADDWF  04,F
05D3:  MOVF   61,W
05D4:  CALL   051
05D5:  MOVWF  00
05D6:  IORLW  00
05D7:  BTFSC  03.2
05D8:  GOTO   5DC
05D9:  INCF   61,F
05DA:  INCF   60,F
05DB:  GOTO   5CE
....................  
....................         if (strcmp(morseCodeBufferString, temp) == 0) 
05DC:  CLRF   60
05DD:  MOVLW  32
05DE:  MOVWF  5F
05DF:  CLRF   62
05E0:  MOVLW  59
05E1:  MOVWF  61
*
0625:  MOVF   78,F
0626:  BTFSS  03.2
0627:  GOTO   639
....................         { 
....................             morseCodeString[morseCodeStringIndex++] = morseCodeTable[i].character; 
0628:  MOVF   49,W
0629:  INCF   49,F
062A:  ADDLW  39
062B:  MOVWF  04
062C:  BCF    03.7
062D:  MOVF   58,W
062E:  MOVWF  61
062F:  MOVLW  07
0630:  MOVWF  62
0631:  CALL   4E9
0632:  MOVLW  06
0633:  ADDWF  78,W
0634:  CALL   051
0635:  MOVWF  78
0636:  MOVWF  00
....................             clearMorseCodeBuffer(); 
0637:  CALL   50E
....................             return; 
0638:  GOTO   643
....................         } 
0639:  INCF   58,F
063A:  GOTO   5C0
....................     } 
....................     morseCodeString[morseCodeStringIndex++] = '?'; 
063B:  MOVF   49,W
063C:  INCF   49,F
063D:  ADDLW  39
063E:  MOVWF  04
063F:  BCF    03.7
0640:  MOVLW  3F
0641:  MOVWF  00
....................     clearMorseCodeBuffer(); 
0642:  CALL   50E
.................... } 
....................  
.................... void handleButtonPress() 
.................... { 
....................     if (input(SW_Pin[0]) == 0) 
*
0543:  BSF    03.5
0544:  BSF    06.0
0545:  BCF    03.5
0546:  BTFSC  06.0
0547:  GOTO   5B7
....................     { // create morse code character 
....................         startTimer(); 
....................         delay_ms(50);           // Debounce 
*
0556:  MOVLW  32
0557:  MOVWF  59
0558:  CALL   29B
....................         output_high(LED_Pin);   // Turn on LED 
0559:  BSF    03.5
055A:  BCF    08.0
055B:  BCF    03.5
055C:  BSF    08.0
....................         output_low(Buzzer_Pin); // Turn on buzzer 
055D:  BSF    03.5
055E:  BCF    08.1
055F:  BCF    03.5
0560:  BCF    08.1
....................  
....................         while (input(SW_Pin[0]) == 0) 
0561:  BSF    03.5
0562:  BSF    06.0
0563:  BCF    03.5
0564:  BTFSC  06.0
0565:  GOTO   57A
....................         { 
....................             if (elapsedTime > DASH_DURATION) 
0566:  MOVF   31,W
0567:  SUBLW  01
0568:  BTFSC  03.0
0569:  GOTO   579
056A:  XORLW  FF
056B:  BTFSS  03.2
056C:  GOTO   571
056D:  MOVF   30,W
056E:  SUBLW  58
056F:  BTFSC  03.0
0570:  GOTO   579
....................             { 
....................                 output_low(LED_Pin);     // Turn off led 
0571:  BSF    03.5
0572:  BCF    08.0
0573:  BCF    03.5
0574:  BCF    08.0
....................                 output_high(Buzzer_Pin); // Turn off buzzer 
0575:  BSF    03.5
0576:  BCF    08.1
0577:  BCF    03.5
0578:  BSF    08.1
....................             } 
0579:  GOTO   561
....................         } 
....................  
....................         output_low(LED_Pin);     // Turn off LED 
057A:  BSF    03.5
057B:  BCF    08.0
057C:  BCF    03.5
057D:  BCF    08.0
....................         output_high(Buzzer_Pin); // Turn off buzzer 
057E:  BSF    03.5
057F:  BCF    08.1
0580:  BCF    03.5
0581:  BSF    08.1
....................  
....................         unsigned int16 duration = stopAndReadTimer(); 
*
058D:  MOVF   79,W
058E:  MOVWF  4B
058F:  MOVF   78,W
0590:  MOVWF  4A
....................         appendMorseCode(duration > DASH_DURATION ? '-' : '.'); 
0591:  MOVF   4B,W
0592:  SUBLW  01
0593:  BTFSC  03.0
0594:  GOTO   59E
0595:  XORLW  FF
0596:  BTFSS  03.2
0597:  GOTO   59C
0598:  MOVF   4A,W
0599:  SUBLW  58
059A:  BTFSC  03.0
059B:  GOTO   59E
059C:  MOVLW  2D
059D:  GOTO   59F
059E:  MOVLW  2E
059F:  MOVWF  58
05A0:  MOVF   58,W
05A1:  MOVWF  59
....................  
....................         set_lcd_i2c_cursor_position(2, 0); 
*
05AE:  MOVLW  02
05AF:  MOVWF  58
05B0:  CLRF   59
05B1:  CALL   2B7
....................         printf(write_lcd_i2c, "%s", morseCodeBufferString); 
05B2:  MOVLW  32
05B3:  MOVWF  04
05B4:  BCF    03.7
05B5:  CALL   4D3
....................     } 
05B6:  GOTO   7A7
....................  
....................     else if (input(SW_Pin[1]) == 0) 
05B7:  BSF    03.5
05B8:  BSF    06.1
05B9:  BCF    03.5
05BA:  BTFSC  06.1
05BB:  GOTO   652
....................     {                 // append character to string and lcd 
....................         delay_ms(100); // Debounce 
05BC:  MOVLW  64
05BD:  MOVWF  59
05BE:  CALL   29B
....................         translateMorseCode(); 
....................         clear_lcd_i2c(); 
*
0643:  CALL   2B0
....................         set_lcd_i2c_cursor_position(1, 0); 
0644:  MOVLW  01
0645:  MOVWF  58
0646:  CLRF   59
0647:  CALL   2B7
....................         printf(write_lcd_i2c, "%s", morseCodeString); 
0648:  MOVLW  39
0649:  MOVWF  04
064A:  BCF    03.7
064B:  CALL   4D3
....................  
....................         while (input(SW_Pin[1]) == 0) 
064C:  BSF    03.5
064D:  BSF    06.1
064E:  BCF    03.5
064F:  BTFSS  06.1
....................         { 
0650:  GOTO   64C
....................             // Wait for button release 
....................         } 
....................     } 
0651:  GOTO   7A7
....................  
....................     else if (input(SW_Pin[2]) == 0) 
0652:  BSF    03.5
0653:  BSF    06.2
0654:  BCF    03.5
0655:  BTFSC  06.2
0656:  GOTO   6F1
....................     {                 // play morse code with buzzer 
....................         delay_ms(50); // Debounce 
0657:  MOVLW  32
0658:  MOVWF  59
0659:  CALL   29B
....................  
....................         for (int i = 0; i < morseCodeStringIndex; ++i) 
065A:  CLRF   4C
065B:  MOVF   49,W
065C:  SUBWF  4C,W
065D:  BTFSC  03.0
065E:  GOTO   6EB
....................         { 
....................             char c = morseCodeString[i]; 
065F:  MOVLW  39
0660:  ADDWF  4C,W
0661:  MOVWF  04
0662:  BCF    03.7
0663:  MOVF   00,W
0664:  MOVWF  4D
....................             for (int j = 0; j < sizeof(morseCodeTable) / sizeof(MorseCode); ++j) 
0665:  CLRF   4E
0666:  MOVF   4E,W
0667:  SUBLW  23
0668:  BTFSS  03.0
0669:  GOTO   6E9
....................             { 
....................                 if (c == morseCodeTable[j].character) 
066A:  MOVF   4E,W
066B:  MOVWF  61
066C:  MOVLW  07
066D:  MOVWF  62
066E:  CALL   4E9
066F:  MOVLW  06
0670:  ADDWF  78,W
0671:  CALL   051
0672:  MOVWF  78
0673:  SUBWF  4D,W
0674:  BTFSS  03.2
0675:  GOTO   6E7
....................                 { 
....................                     set_lcd_i2c_cursor_position(2, 0); 
0676:  MOVLW  02
0677:  MOVWF  58
0678:  CLRF   59
0679:  CALL   2B7
....................                     printf(write_lcd_i2c, "%c: %s", c, morseCodeTable[j].morseCode); 
067A:  MOVF   4E,W
067B:  MOVWF  61
067C:  MOVLW  07
067D:  MOVWF  62
067E:  CALL   4E9
067F:  MOVF   78,W
0680:  MOVWF  58
0681:  MOVF   4D,W
0682:  MOVWF  5B
0683:  CALL   314
0684:  MOVLW  3A
0685:  MOVWF  5B
0686:  CALL   314
0687:  MOVLW  20
0688:  MOVWF  5B
0689:  CALL   314
068A:  MOVLW  58
068B:  BSF    03.6
068C:  MOVWF  0D
068D:  MOVLW  00
068E:  MOVWF  0F
068F:  BCF    03.6
0690:  MOVF   58,W
0691:  BSF    03.6
0692:  ADDWF  0D,F
0693:  BTFSC  03.0
0694:  INCF   0F,F
0695:  BCF    03.6
0696:  CALL   517
....................  
....................                     unsigned int8 k = 0; 
0697:  CLRF   4F
....................                     while (morseCodeTable[j].morseCode[k] != '\0') 
0698:  MOVF   4E,W
0699:  MOVWF  61
069A:  MOVLW  07
069B:  MOVWF  62
069C:  CALL   4E9
069D:  MOVF   4F,W
069E:  ADDWF  78,W
069F:  CALL   051
06A0:  XORLW  00
06A1:  BTFSC  03.2
06A2:  GOTO   6D5
....................                     { 
....................                         output_low(Buzzer_Pin); 
06A3:  BSF    03.5
06A4:  BCF    08.1
06A5:  BCF    03.5
06A6:  BCF    08.1
....................                         unsigned int16 duration = morseCodeTable[j].morseCode[k] == '-' ? DASH_DURATION : DOT_DURATION; 
06A7:  MOVF   4E,W
06A8:  MOVWF  61
06A9:  MOVLW  07
06AA:  MOVWF  62
06AB:  CALL   4E9
06AC:  MOVF   4F,W
06AD:  ADDWF  78,W
06AE:  CALL   051
06AF:  SUBLW  2D
06B0:  BTFSS  03.2
06B1:  GOTO   6B6
06B2:  MOVLW  02
06B3:  MOVWF  7A
06B4:  MOVLW  58
06B5:  GOTO   6B8
06B6:  CLRF   7A
06B7:  MOVLW  C8
06B8:  MOVWF  50
06B9:  MOVF   7A,W
06BA:  MOVWF  51
....................                         delay_ms(duration); 
06BB:  MOVF   51,W
06BC:  MOVWF  58
06BD:  INCF   58,F
06BE:  DECF   58,F
06BF:  BTFSC  03.2
06C0:  GOTO   6C5
06C1:  MOVLW  FF
06C2:  MOVWF  59
06C3:  CALL   29B
06C4:  GOTO   6BE
06C5:  MOVF   50,W
06C6:  MOVWF  59
06C7:  CALL   29B
....................                         output_high(Buzzer_Pin); 
06C8:  BSF    03.5
06C9:  BCF    08.1
06CA:  BCF    03.5
06CB:  BSF    08.1
....................  
....................                         delay_ms(400); 
06CC:  MOVLW  02
06CD:  MOVWF  58
06CE:  MOVLW  C8
06CF:  MOVWF  59
06D0:  CALL   29B
06D1:  DECFSZ 58,F
06D2:  GOTO   6CE
....................  
....................                         k++; 
06D3:  INCF   4F,F
06D4:  GOTO   698
....................                     } 
....................  
....................                     set_lcd_i2c_cursor_position(2, 0); 
06D5:  MOVLW  02
06D6:  MOVWF  58
06D7:  CLRF   59
06D8:  CALL   2B7
....................                     printf(write_lcd_i2c, "                "); 
06D9:  MOVLW  61
06DA:  BSF    03.6
06DB:  MOVWF  0D
06DC:  MOVLW  01
06DD:  MOVWF  0F
06DE:  BCF    03.6
06DF:  CALL   47D
....................  
....................                     delay_ms(800); 
06E0:  MOVLW  04
06E1:  MOVWF  58
06E2:  MOVLW  C8
06E3:  MOVWF  59
06E4:  CALL   29B
06E5:  DECFSZ 58,F
06E6:  GOTO   6E2
....................                 } 
06E7:  INCF   4E,F
06E8:  GOTO   666
....................             } 
06E9:  INCF   4C,F
06EA:  GOTO   65B
....................         } 
....................  
....................         while (input(SW_Pin[2]) == 0) 
06EB:  BSF    03.5
06EC:  BSF    06.2
06ED:  BCF    03.5
06EE:  BTFSS  06.2
....................         { 
06EF:  GOTO   6EB
....................             // Wait for button release 
....................         } 
....................     } 
06F0:  GOTO   7A7
....................  
....................     else if (input(SW_Pin[3]) == 0) // play morse code with LED 
06F1:  BSF    03.5
06F2:  BSF    06.3
06F3:  BCF    03.5
06F4:  BTFSC  06.3
06F5:  GOTO   790
....................     {                                
....................         delay_ms(50);               // Debounce 
06F6:  MOVLW  32
06F7:  MOVWF  59
06F8:  CALL   29B
....................  
....................         for (int i = 0; i < morseCodeStringIndex; ++i) 
06F9:  CLRF   52
06FA:  MOVF   49,W
06FB:  SUBWF  52,W
06FC:  BTFSC  03.0
06FD:  GOTO   78A
....................         { 
....................             char c = morseCodeString[i]; 
06FE:  MOVLW  39
06FF:  ADDWF  52,W
0700:  MOVWF  04
0701:  BCF    03.7
0702:  MOVF   00,W
0703:  MOVWF  53
....................             for (int j = 0; j < sizeof(morseCodeTable) / sizeof(MorseCode); ++j) 
0704:  CLRF   54
0705:  MOVF   54,W
0706:  SUBLW  23
0707:  BTFSS  03.0
0708:  GOTO   788
....................             { 
....................                 if (c == morseCodeTable[j].character) 
0709:  MOVF   54,W
070A:  MOVWF  61
070B:  MOVLW  07
070C:  MOVWF  62
070D:  CALL   4E9
070E:  MOVLW  06
070F:  ADDWF  78,W
0710:  CALL   051
0711:  MOVWF  78
0712:  SUBWF  53,W
0713:  BTFSS  03.2
0714:  GOTO   786
....................                 { 
....................                     set_lcd_i2c_cursor_position(2, 0); 
0715:  MOVLW  02
0716:  MOVWF  58
0717:  CLRF   59
0718:  CALL   2B7
....................                     printf(write_lcd_i2c, "%c: %s", c, morseCodeTable[j].morseCode); 
0719:  MOVF   54,W
071A:  MOVWF  61
071B:  MOVLW  07
071C:  MOVWF  62
071D:  CALL   4E9
071E:  MOVF   78,W
071F:  MOVWF  58
0720:  MOVF   53,W
0721:  MOVWF  5B
0722:  CALL   314
0723:  MOVLW  3A
0724:  MOVWF  5B
0725:  CALL   314
0726:  MOVLW  20
0727:  MOVWF  5B
0728:  CALL   314
0729:  MOVLW  58
072A:  BSF    03.6
072B:  MOVWF  0D
072C:  MOVLW  00
072D:  MOVWF  0F
072E:  BCF    03.6
072F:  MOVF   58,W
0730:  BSF    03.6
0731:  ADDWF  0D,F
0732:  BTFSC  03.0
0733:  INCF   0F,F
0734:  BCF    03.6
0735:  CALL   517
....................  
....................                     unsigned int8 k = 0; 
0736:  CLRF   55
....................                     while (morseCodeTable[j].morseCode[k] != '\0') 
0737:  MOVF   54,W
0738:  MOVWF  61
0739:  MOVLW  07
073A:  MOVWF  62
073B:  CALL   4E9
073C:  MOVF   55,W
073D:  ADDWF  78,W
073E:  CALL   051
073F:  XORLW  00
0740:  BTFSC  03.2
0741:  GOTO   774
....................                     { 
....................                         output_high(LED_Pin); 
0742:  BSF    03.5
0743:  BCF    08.0
0744:  BCF    03.5
0745:  BSF    08.0
....................                         unsigned int16 duration = morseCodeTable[j].morseCode[k] == '-' ? DASH_DURATION : DOT_DURATION; 
0746:  MOVF   54,W
0747:  MOVWF  61
0748:  MOVLW  07
0749:  MOVWF  62
074A:  CALL   4E9
074B:  MOVF   55,W
074C:  ADDWF  78,W
074D:  CALL   051
074E:  SUBLW  2D
074F:  BTFSS  03.2
0750:  GOTO   755
0751:  MOVLW  02
0752:  MOVWF  7A
0753:  MOVLW  58
0754:  GOTO   757
0755:  CLRF   7A
0756:  MOVLW  C8
0757:  MOVWF  56
0758:  MOVF   7A,W
0759:  MOVWF  57
....................                         delay_ms(duration); 
075A:  MOVF   57,W
075B:  MOVWF  58
075C:  INCF   58,F
075D:  DECF   58,F
075E:  BTFSC  03.2
075F:  GOTO   764
0760:  MOVLW  FF
0761:  MOVWF  59
0762:  CALL   29B
0763:  GOTO   75D
0764:  MOVF   56,W
0765:  MOVWF  59
0766:  CALL   29B
....................                         output_low(LED_Pin); 
0767:  BSF    03.5
0768:  BCF    08.0
0769:  BCF    03.5
076A:  BCF    08.0
....................  
....................                         delay_ms(400); 
076B:  MOVLW  02
076C:  MOVWF  58
076D:  MOVLW  C8
076E:  MOVWF  59
076F:  CALL   29B
0770:  DECFSZ 58,F
0771:  GOTO   76D
....................  
....................                         k++; 
0772:  INCF   55,F
0773:  GOTO   737
....................                     } 
....................  
....................                     set_lcd_i2c_cursor_position(2, 0); 
0774:  MOVLW  02
0775:  MOVWF  58
0776:  CLRF   59
0777:  CALL   2B7
....................                     printf(write_lcd_i2c, "                "); 
0778:  MOVLW  6A
0779:  BSF    03.6
077A:  MOVWF  0D
077B:  MOVLW  01
077C:  MOVWF  0F
077D:  BCF    03.6
077E:  CALL   47D
....................  
....................                     delay_ms(800); 
077F:  MOVLW  04
0780:  MOVWF  58
0781:  MOVLW  C8
0782:  MOVWF  59
0783:  CALL   29B
0784:  DECFSZ 58,F
0785:  GOTO   781
....................                 } 
0786:  INCF   54,F
0787:  GOTO   705
....................             } 
0788:  INCF   52,F
0789:  GOTO   6FA
....................         } 
....................  
....................         while (input(SW_Pin[3]) == 0) 
078A:  BSF    03.5
078B:  BSF    06.3
078C:  BCF    03.5
078D:  BTFSS  06.3
....................         { 
078E:  GOTO   78A
....................             // Wait for button release 
....................         } 
....................     } 
078F:  GOTO   7A7
....................  
....................     else if (input(SW_Pin[4]) == 0) 
0790:  BSF    03.5
0791:  BSF    06.4
0792:  BCF    03.5
0793:  BTFSC  06.4
0794:  GOTO   7A7
....................     {                 // clear all 
....................         delay_ms(50); // Debounce 
0795:  MOVLW  32
0796:  MOVWF  59
0797:  CALL   29B
....................         clear_lcd_i2c(); 
0798:  CALL   2B0
....................         clearMorseCodeBuffer(); 
0799:  CALL   50E
....................         clearMorseCodeString(); 
....................  
....................         while (input(SW_Pin[4]) == 0) 
*
07A2:  BSF    03.5
07A3:  BSF    06.4
07A4:  BCF    03.5
07A5:  BTFSS  06.4
....................         { 
07A6:  GOTO   7A2
....................             // Wait for button release 
....................         } 
....................     } 
07A7:  BSF    0A.3
07A8:  BCF    0A.4
07A9:  GOTO   078 (RETURN)
.................... } 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  BSF    03.5
0804:  BSF    03.6
0805:  BCF    07.3
0806:  MOVLW  4D
0807:  BCF    03.6
0808:  MOVWF  19
0809:  MOVLW  A6
080A:  MOVWF  18
080B:  MOVLW  90
080C:  BCF    03.5
080D:  MOVWF  18
080E:  MOVLW  FF
080F:  MOVWF  2B
0810:  MOVLW  08
0811:  MOVWF  2E
0812:  MOVLW  01
0813:  MOVWF  2F
0814:  CLRF   31
0815:  CLRF   30
0816:  CLRF   38
0817:  CLRF   49
0818:  BSF    03.5
0819:  BSF    03.6
081A:  MOVF   09,W
081B:  ANDLW  C0
081C:  MOVWF  09
081D:  BCF    03.6
081E:  BCF    1F.4
081F:  BCF    1F.5
0820:  MOVLW  00
0821:  BSF    03.6
0822:  MOVWF  08
0823:  BCF    03.5
0824:  CLRF   07
0825:  CLRF   08
0826:  CLRF   09
0827:  BCF    03.7
.................... { 
....................     initialize_lcd_i2c(); // Initialize the LCD 
*
082B:  BCF    0A.3
082C:  GOTO   1CD
082D:  BSF    0A.3
....................     set_tris_d(0x00);     // Set LED and buzzer pins as output 
082E:  MOVLW  00
082F:  BSF    03.5
0830:  MOVWF  08
....................     set_tris_b(0x1F);     // Set SW pins as input 
0831:  MOVLW  1F
0832:  MOVWF  06
....................     output_d(0x02);       // Turn off LED and Buzzer 
0833:  CLRF   08
0834:  MOVLW  02
0835:  BCF    03.5
0836:  MOVWF  08
....................  
....................     memset(morseCodeBufferString, 0, sizeof(morseCodeBufferString)); 
0837:  MOVLW  32
0838:  MOVWF  04
0839:  BCF    03.7
083A:  CLRF   77
083B:  MOVLW  06
083C:  MOVWF  78
083D:  BCF    0A.3
083E:  CALL   23D
083F:  BSF    0A.3
....................     memset(morseCodeString, 0, sizeof(morseCodeString)); 
0840:  MOVLW  39
0841:  MOVWF  04
0842:  BCF    03.7
0843:  CLRF   77
0844:  MOVLW  10
0845:  MOVWF  78
0846:  BCF    0A.3
0847:  CALL   23D
0848:  BSF    0A.3
....................     clear_lcd_i2c(); 
0849:  BCF    0A.3
084A:  CALL   2B0
084B:  BSF    0A.3
....................  
....................     set_lcd_i2c_cursor_position(1, 0); 
084C:  MOVLW  01
084D:  MOVWF  58
084E:  CLRF   59
084F:  BCF    0A.3
0850:  CALL   2B7
0851:  BSF    0A.3
....................     printf(write_lcd_i2c, "1. LE TRONG AN"); 
0852:  MOVLW  73
0853:  BSF    03.6
0854:  MOVWF  0D
0855:  MOVLW  01
0856:  MOVWF  0F
0857:  BCF    0A.3
0858:  BCF    03.6
0859:  CALL   47D
085A:  BSF    0A.3
....................     set_lcd_i2c_cursor_position(2, 0); 
085B:  MOVLW  02
085C:  MOVWF  58
085D:  CLRF   59
085E:  BCF    0A.3
085F:  CALL   2B7
0860:  BSF    0A.3
....................     printf(write_lcd_i2c, "2. N.H VIET ANH"); 
0861:  MOVLW  7B
0862:  BSF    03.6
0863:  MOVWF  0D
0864:  MOVLW  01
0865:  MOVWF  0F
0866:  BCF    0A.3
0867:  BCF    03.6
0868:  CALL   47D
0869:  BSF    0A.3
....................  
....................     delay_ms(1500); 
086A:  MOVLW  06
086B:  MOVWF  4A
086C:  MOVLW  FA
086D:  MOVWF  59
086E:  BCF    0A.3
086F:  CALL   29B
0870:  BSF    0A.3
0871:  DECFSZ 4A,F
0872:  GOTO   06C
....................     clear_lcd_i2c(); 
0873:  BCF    0A.3
0874:  CALL   2B0
0875:  BSF    0A.3
....................  
....................     while (TRUE) 
....................     { 
....................         handleButtonPress(); 
0876:  BCF    0A.3
0877:  GOTO   543
0878:  BSF    0A.3
0879:  GOTO   076
....................         // Additional functionality can be added here 
....................     } 
.................... } 
087A:  SLEEP

Configuration Fuses:
   Word  1: 2CE2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
