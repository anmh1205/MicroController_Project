CCS PCM C Compiler, Version 5.025, 26966               07-Jul-24 22:35

               Filename:   E:\1. Phenikaa University\AML\1. Code\VDK (PIC16)\0. BTL\1. Code\V1.2\main.lst

               ROM used:   2289 words (28%)
                           Largest free fragment is 2048
               RAM used:   51 (14%) at main() level
                           68 (18%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   07E
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   154
.................... #include <main.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDLW  58
0055:  BTFSC  03.0
0056:  INCF   0A,F
0057:  MOVWF  02
0058:  RETLW  2E
0059:  RETLW  2D
005A:  RETLW  00
005B:  RETLW  00
005C:  RETLW  00
005D:  RETLW  00
005E:  RETLW  41
005F:  RETLW  2D
0060:  RETLW  2E
0061:  RETLW  2E
0062:  RETLW  2E
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  2D
0067:  RETLW  2E
0068:  RETLW  2D
0069:  RETLW  2E
006A:  RETLW  00
006B:  RETLW  00
006C:  RETLW  43
006D:  RETLW  2D
006E:  RETLW  2E
006F:  RETLW  2E
0070:  RETLW  00
0071:  RETLW  00
0072:  RETLW  00
0073:  RETLW  44
0074:  RETLW  2E
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  00
0079:  RETLW  00
007A:  RETLW  45
007B:  RETLW  2E
007C:  RETLW  2E
007D:  RETLW  2D
007E:  RETLW  2E
007F:  RETLW  00
0080:  RETLW  00
0081:  RETLW  46
0082:  RETLW  2D
0083:  RETLW  2D
0084:  RETLW  2E
0085:  RETLW  00
0086:  RETLW  00
0087:  RETLW  00
0088:  RETLW  47
0089:  RETLW  2E
008A:  RETLW  2E
008B:  RETLW  2E
008C:  RETLW  2E
008D:  RETLW  00
008E:  RETLW  00
008F:  RETLW  48
0090:  RETLW  2E
0091:  RETLW  2E
0092:  RETLW  00
0093:  RETLW  00
0094:  RETLW  00
0095:  RETLW  00
0096:  RETLW  49
0097:  RETLW  2E
0098:  RETLW  2D
0099:  RETLW  2D
009A:  RETLW  2D
009B:  RETLW  00
009C:  RETLW  00
009D:  RETLW  4A
009E:  RETLW  2D
009F:  RETLW  2E
00A0:  RETLW  2D
00A1:  RETLW  00
00A2:  RETLW  00
00A3:  RETLW  00
00A4:  RETLW  4B
00A5:  RETLW  2E
00A6:  RETLW  2D
00A7:  RETLW  2E
00A8:  RETLW  2E
00A9:  RETLW  00
00AA:  RETLW  00
00AB:  RETLW  4C
00AC:  RETLW  2D
00AD:  RETLW  2D
00AE:  RETLW  00
00AF:  RETLW  00
00B0:  RETLW  00
00B1:  RETLW  00
00B2:  RETLW  4D
00B3:  RETLW  2D
00B4:  RETLW  2E
00B5:  RETLW  00
00B6:  RETLW  00
00B7:  RETLW  00
00B8:  RETLW  00
00B9:  RETLW  4E
00BA:  RETLW  2D
00BB:  RETLW  2D
00BC:  RETLW  2D
00BD:  RETLW  00
00BE:  RETLW  00
00BF:  RETLW  00
00C0:  RETLW  4F
00C1:  RETLW  2E
00C2:  RETLW  2D
00C3:  RETLW  2D
00C4:  RETLW  2E
00C5:  RETLW  00
00C6:  RETLW  00
00C7:  RETLW  50
00C8:  RETLW  2D
00C9:  RETLW  2D
00CA:  RETLW  2E
00CB:  RETLW  2D
00CC:  RETLW  00
00CD:  RETLW  00
00CE:  RETLW  51
00CF:  RETLW  2E
00D0:  RETLW  2D
00D1:  RETLW  2E
00D2:  RETLW  00
00D3:  RETLW  00
00D4:  RETLW  00
00D5:  RETLW  52
00D6:  RETLW  2E
00D7:  RETLW  2E
00D8:  RETLW  2E
00D9:  RETLW  00
00DA:  RETLW  00
00DB:  RETLW  00
00DC:  RETLW  53
00DD:  RETLW  2D
00DE:  RETLW  00
00DF:  RETLW  00
00E0:  RETLW  00
00E1:  RETLW  00
00E2:  RETLW  00
00E3:  RETLW  54
00E4:  RETLW  2E
00E5:  RETLW  2E
00E6:  RETLW  2D
00E7:  RETLW  00
00E8:  RETLW  00
00E9:  RETLW  00
00EA:  RETLW  55
00EB:  RETLW  2E
00EC:  RETLW  2E
00ED:  RETLW  2E
00EE:  RETLW  2D
00EF:  RETLW  00
00F0:  RETLW  00
00F1:  RETLW  56
00F2:  RETLW  2E
00F3:  RETLW  2D
00F4:  RETLW  2D
00F5:  RETLW  00
00F6:  RETLW  00
00F7:  RETLW  00
00F8:  RETLW  57
00F9:  RETLW  2D
00FA:  RETLW  2E
00FB:  RETLW  2E
00FC:  RETLW  2D
00FD:  RETLW  00
00FE:  RETLW  00
00FF:  RETLW  58
0100:  RETLW  2D
0101:  RETLW  2E
0102:  RETLW  2D
0103:  RETLW  2D
0104:  RETLW  00
0105:  RETLW  00
0106:  RETLW  59
0107:  RETLW  2D
0108:  RETLW  2D
0109:  RETLW  2E
010A:  RETLW  2E
010B:  RETLW  00
010C:  RETLW  00
010D:  RETLW  5A
010E:  RETLW  2D
010F:  RETLW  2D
0110:  RETLW  2D
0111:  RETLW  2D
0112:  RETLW  2D
0113:  RETLW  00
0114:  RETLW  30
0115:  RETLW  2E
0116:  RETLW  2D
0117:  RETLW  2D
0118:  RETLW  2D
0119:  RETLW  2D
011A:  RETLW  00
011B:  RETLW  31
011C:  RETLW  2E
011D:  RETLW  2E
011E:  RETLW  2D
011F:  RETLW  2D
0120:  RETLW  2D
0121:  RETLW  00
0122:  RETLW  32
0123:  RETLW  2E
0124:  RETLW  2E
0125:  RETLW  2E
0126:  RETLW  2D
0127:  RETLW  2D
0128:  RETLW  00
0129:  RETLW  33
012A:  RETLW  2E
012B:  RETLW  2E
012C:  RETLW  2E
012D:  RETLW  2E
012E:  RETLW  2D
012F:  RETLW  00
0130:  RETLW  34
0131:  RETLW  2E
0132:  RETLW  2E
0133:  RETLW  2E
0134:  RETLW  2E
0135:  RETLW  2E
0136:  RETLW  00
0137:  RETLW  35
0138:  RETLW  2D
0139:  RETLW  2E
013A:  RETLW  2E
013B:  RETLW  2E
013C:  RETLW  2E
013D:  RETLW  00
013E:  RETLW  36
013F:  RETLW  2D
0140:  RETLW  2D
0141:  RETLW  2E
0142:  RETLW  2E
0143:  RETLW  2E
0144:  RETLW  00
0145:  RETLW  37
0146:  RETLW  2D
0147:  RETLW  2D
0148:  RETLW  2D
0149:  RETLW  2E
014A:  RETLW  2E
014B:  RETLW  00
014C:  RETLW  38
014D:  RETLW  2D
014E:  RETLW  2D
014F:  RETLW  2D
0150:  RETLW  2D
0151:  RETLW  2E
0152:  RETLW  00
0153:  RETLW  39
*
0161:  DATA 20,10
0162:  DATA 20,10
0163:  DATA 20,10
0164:  DATA 20,10
0165:  DATA 20,10
0166:  DATA 20,10
0167:  DATA 20,10
0168:  DATA 20,10
0169:  DATA 00,00
016A:  DATA 20,10
016B:  DATA 20,10
016C:  DATA 20,10
016D:  DATA 20,10
016E:  DATA 20,10
016F:  DATA 20,10
0170:  DATA 20,10
0171:  DATA 20,10
0172:  DATA 00,00
0173:  DATA 49,27
0174:  DATA D0,2A
0175:  DATA 54,1D
0176:  DATA 20,21
0177:  DATA 55,2A
0178:  DATA D4,27
0179:  DATA 4E,00
017A:  DATA 49,27
017B:  DATA D0,2A
017C:  DATA 54,1D
017D:  DATA A0,2A
017E:  DATA 41,29
017F:  DATA 54,00
0180:  DATA 31,17
0181:  DATA 20,26
0182:  DATA 45,10
0183:  DATA 54,29
0184:  DATA 4F,27
0185:  DATA 47,10
0186:  DATA 41,27
0187:  DATA 00,01
0188:  DATA 32,17
0189:  DATA 20,27
018A:  DATA 2E,24
018B:  DATA 20,2B
018C:  DATA C9,22
018D:  DATA 54,10
018E:  DATA 41,27
018F:  DATA 48,00
0190:  INCF   04,F
0191:  MOVF   00,W
0192:  MOVWF  0A
0193:  DECF   04,F
0194:  MOVF   00,W
0195:  MOVWF  02
0196:  RETURN
*
0251:  MOVF   78,W
0252:  BTFSC  03.2
0253:  GOTO   259
0254:  MOVF   77,W
0255:  MOVWF  00
0256:  INCF   04,F
0257:  DECFSZ 78,F
0258:  GOTO   254
0259:  RETURN
*
0491:  MOVF   0B,W
0492:  MOVWF  54
0493:  BCF    0B.7
0494:  BSF    03.5
0495:  BSF    03.6
0496:  BSF    0C.7
0497:  BSF    0C.0
0498:  NOP
0499:  NOP
049A:  BCF    03.5
049B:  BCF    03.6
049C:  BTFSC  54.7
049D:  BSF    0B.7
049E:  BSF    03.6
049F:  MOVF   0C,W
04A0:  ANDLW  7F
04A1:  BTFSC  03.2
04A2:  GOTO   4E5
04A3:  BCF    03.6
04A4:  MOVWF  54
04A5:  BSF    03.6
04A6:  MOVF   0D,W
04A7:  BCF    03.6
04A8:  MOVWF  55
04A9:  BSF    03.6
04AA:  MOVF   0F,W
04AB:  BCF    03.6
04AC:  MOVWF  56
04AD:  MOVF   54,W
04AE:  MOVWF  57
04AF:  CALL   328
04B0:  MOVF   55,W
04B1:  BSF    03.6
04B2:  MOVWF  0D
04B3:  BCF    03.6
04B4:  MOVF   56,W
04B5:  BSF    03.6
04B6:  MOVWF  0F
04B7:  BCF    03.6
04B8:  MOVF   0B,W
04B9:  MOVWF  57
04BA:  BCF    0B.7
04BB:  BSF    03.5
04BC:  BSF    03.6
04BD:  BSF    0C.7
04BE:  BSF    0C.0
04BF:  NOP
04C0:  NOP
04C1:  BCF    03.5
04C2:  BCF    03.6
04C3:  BTFSC  57.7
04C4:  BSF    0B.7
04C5:  BSF    03.6
04C6:  RLF    0C,W
04C7:  RLF    0E,W
04C8:  ANDLW  7F
04C9:  BTFSC  03.2
04CA:  GOTO   4E5
04CB:  BCF    03.6
04CC:  MOVWF  54
04CD:  BSF    03.6
04CE:  MOVF   0D,W
04CF:  BCF    03.6
04D0:  MOVWF  55
04D1:  BSF    03.6
04D2:  MOVF   0F,W
04D3:  BCF    03.6
04D4:  MOVWF  56
04D5:  MOVF   54,W
04D6:  MOVWF  57
04D7:  CALL   328
04D8:  MOVF   55,W
04D9:  BSF    03.6
04DA:  MOVWF  0D
04DB:  BCF    03.6
04DC:  MOVF   56,W
04DD:  BSF    03.6
04DE:  MOVWF  0F
04DF:  INCF   0D,F
04E0:  BTFSC  03.2
04E1:  INCF   0F,F
04E2:  BCF    03.6
04E3:  GOTO   491
04E4:  BSF    03.6
04E5:  BCF    03.6
04E6:  RETURN
*
04FB:  CLRF   77
04FC:  CLRF   78
04FD:  MOVF   56,W
04FE:  BCF    03.0
04FF:  BTFSC  57.0
0500:  ADDWF  77,F
0501:  RRF    77,F
0502:  RRF    78,F
0503:  BTFSC  57.1
0504:  ADDWF  77,F
0505:  RRF    77,F
0506:  RRF    78,F
0507:  BTFSC  57.2
0508:  ADDWF  77,F
0509:  RRF    77,F
050A:  RRF    78,F
050B:  BTFSC  57.3
050C:  ADDWF  77,F
050D:  RRF    77,F
050E:  RRF    78,F
050F:  BTFSC  57.4
0510:  ADDWF  77,F
0511:  RRF    77,F
0512:  RRF    78,F
0513:  BTFSC  57.5
0514:  ADDWF  77,F
0515:  RRF    77,F
0516:  RRF    78,F
0517:  BTFSC  57.6
0518:  ADDWF  77,F
0519:  RRF    77,F
051A:  RRF    78,F
051B:  BTFSC  57.7
051C:  ADDWF  77,F
051D:  RRF    77,F
051E:  RRF    78,F
051F:  RETURN
0520:  MOVF   0B,W
0521:  MOVWF  55
0522:  BCF    0B.7
0523:  BSF    03.5
0524:  BSF    03.6
0525:  BSF    0C.7
0526:  BSF    0C.0
0527:  NOP
0528:  NOP
0529:  BCF    03.5
052A:  BCF    03.6
052B:  BTFSC  55.7
052C:  BSF    0B.7
052D:  BSF    03.6
052E:  MOVF   0C,F
052F:  BTFSC  03.2
0530:  GOTO   54A
0531:  MOVF   0D,W
0532:  BCF    03.6
0533:  MOVWF  55
0534:  BSF    03.6
0535:  MOVF   0F,W
0536:  BCF    03.6
0537:  MOVWF  56
0538:  BSF    03.6
0539:  MOVF   0C,W
053A:  BCF    03.6
053B:  MOVWF  57
053C:  CALL   328
053D:  MOVF   55,W
053E:  BSF    03.6
053F:  MOVWF  0D
0540:  BCF    03.6
0541:  MOVF   56,W
0542:  BSF    03.6
0543:  MOVWF  0F
0544:  INCF   0D,F
0545:  BTFSC  03.2
0546:  INCF   0F,F
0547:  BCF    03.6
0548:  GOTO   520
0549:  BSF    03.6
054A:  BCF    03.6
054B:  RETURN
*
0670:  MOVF   00,F
0671:  BTFSC  03.2
0672:  GOTO   685
0673:  CLRF   50
0674:  MOVF   04,W
0675:  MOVWF  4F
0676:  BCF    50.0
0677:  BTFSC  03.7
0678:  BSF    50.0
0679:  MOVF   00,W
067A:  MOVWF  57
067B:  CALL   328
067C:  MOVF   4F,W
067D:  MOVWF  04
067E:  BCF    03.7
067F:  BTFSC  50.0
0680:  BSF    03.7
0681:  INCF   04,F
0682:  BTFSC  03.2
0683:  INCF   05,F
0684:  GOTO   670
0685:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC = 16 
....................  
.................... #FUSES NOWDT      // No Watch Dog Timer 
.................... #FUSES PUT        // Power Up Timer 
.................... #FUSES NOBROWNOUT // No brownout reset 
.................... #FUSES NOLVP      // No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal = 12000000) 
*
02AF:  MOVLW  55
02B0:  MOVWF  04
02B1:  BCF    03.7
02B2:  MOVF   00,W
02B3:  BTFSC  03.2
02B4:  GOTO   2C3
02B5:  MOVLW  03
02B6:  MOVWF  78
02B7:  CLRF   77
02B8:  DECFSZ 77,F
02B9:  GOTO   2B8
02BA:  DECFSZ 78,F
02BB:  GOTO   2B7
02BC:  MOVLW  E3
02BD:  MOVWF  77
02BE:  DECFSZ 77,F
02BF:  GOTO   2BE
02C0:  NOP
02C1:  DECFSZ 00,F
02C2:  GOTO   2B5
02C3:  RETURN
.................... // #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PORT1) 
.................... #use rs232(UART1, baud = 9600) 
.................... #use i2c(Master, Fast = 100000, sda = PIN_C4, scl = PIN_C3, force_sw) 
*
0197:  MOVLW  08
0198:  MOVWF  78
0199:  GOTO   19A
019A:  BCF    07.3
019B:  BCF    2B.3
019C:  MOVF   2B,W
019D:  BSF    03.5
019E:  MOVWF  07
019F:  NOP
01A0:  BCF    03.5
01A1:  RLF    5E,F
01A2:  BCF    07.4
01A3:  BTFSS  03.0
01A4:  GOTO   1AB
01A5:  BSF    2B.4
01A6:  MOVF   2B,W
01A7:  BSF    03.5
01A8:  MOVWF  07
01A9:  GOTO   1AF
01AA:  BCF    03.5
01AB:  BCF    2B.4
01AC:  MOVF   2B,W
01AD:  BSF    03.5
01AE:  MOVWF  07
01AF:  NOP
01B0:  BCF    03.5
01B1:  BSF    2B.3
01B2:  MOVF   2B,W
01B3:  BSF    03.5
01B4:  MOVWF  07
01B5:  BCF    03.5
01B6:  BTFSS  07.3
01B7:  GOTO   1B6
01B8:  DECFSZ 78,F
01B9:  GOTO   199
01BA:  GOTO   1BB
01BB:  BCF    07.3
01BC:  BCF    2B.3
01BD:  MOVF   2B,W
01BE:  BSF    03.5
01BF:  MOVWF  07
01C0:  NOP
01C1:  BCF    03.5
01C2:  BSF    2B.4
01C3:  MOVF   2B,W
01C4:  BSF    03.5
01C5:  MOVWF  07
01C6:  NOP
01C7:  NOP
01C8:  BCF    03.5
01C9:  BSF    2B.3
01CA:  MOVF   2B,W
01CB:  BSF    03.5
01CC:  MOVWF  07
01CD:  BCF    03.5
01CE:  BTFSS  07.3
01CF:  GOTO   1CE
01D0:  CLRF   78
01D1:  NOP
01D2:  BTFSC  07.4
01D3:  BSF    78.0
01D4:  BCF    07.3
01D5:  BCF    2B.3
01D6:  MOVF   2B,W
01D7:  BSF    03.5
01D8:  MOVWF  07
01D9:  BCF    03.5
01DA:  BCF    07.4
01DB:  BCF    2B.4
01DC:  MOVF   2B,W
01DD:  BSF    03.5
01DE:  MOVWF  07
01DF:  BCF    03.5
01E0:  RETURN
*
02E3:  MOVLW  08
02E4:  MOVWF  5D
02E5:  MOVF   77,W
02E6:  MOVWF  5E
02E7:  BSF    2B.4
02E8:  MOVF   2B,W
02E9:  BSF    03.5
02EA:  MOVWF  07
02EB:  NOP
02EC:  BCF    03.5
02ED:  BSF    2B.3
02EE:  MOVF   2B,W
02EF:  BSF    03.5
02F0:  MOVWF  07
02F1:  BCF    03.5
02F2:  BTFSS  07.3
02F3:  GOTO   2F2
02F4:  BTFSC  07.4
02F5:  BSF    03.0
02F6:  BTFSS  07.4
02F7:  BCF    03.0
02F8:  RLF    78,F
02F9:  GOTO   2FA
02FA:  BCF    2B.3
02FB:  MOVF   2B,W
02FC:  BSF    03.5
02FD:  MOVWF  07
02FE:  BCF    03.5
02FF:  BCF    07.3
0300:  DECFSZ 5D,F
0301:  GOTO   2E7
0302:  BSF    2B.4
0303:  MOVF   2B,W
0304:  BSF    03.5
0305:  MOVWF  07
0306:  NOP
0307:  BCF    03.5
0308:  BCF    07.4
0309:  MOVF   5E,W
030A:  BTFSC  03.2
030B:  GOTO   311
030C:  BCF    2B.4
030D:  MOVF   2B,W
030E:  BSF    03.5
030F:  MOVWF  07
0310:  BCF    03.5
0311:  NOP
0312:  BSF    2B.3
0313:  MOVF   2B,W
0314:  BSF    03.5
0315:  MOVWF  07
0316:  BCF    03.5
0317:  BTFSS  07.3
0318:  GOTO   317
0319:  GOTO   31A
031A:  BCF    07.3
031B:  BCF    2B.3
031C:  MOVF   2B,W
031D:  BSF    03.5
031E:  MOVWF  07
031F:  NOP
0320:  BCF    03.5
0321:  BCF    07.4
0322:  BCF    2B.4
0323:  MOVF   2B,W
0324:  BSF    03.5
0325:  MOVWF  07
0326:  BCF    03.5
0327:  RETURN
....................  
.................... #define PCF8574A       // Comment for modules using PCF8574 
.................... #define A2_A1_A0 0B111 // Address pin states (A2 A1 A0) of PCF8574A/PCF8574. 
.................... #define LCD16X2        // Comment this line to use 16x2 LCD 
....................  
.................... #include <globalVariables.h> 
.................... #ifndef VAR_H 
.................... #define VAR_H 
....................  
.................... #include <lcd_i2c.c> 
.................... #define RIGHT 0x1C 
.................... #define LEFT 0x18 
....................  
.................... #define CURSOR_ON 2 
.................... #define CURSOR_OFF 0 
....................  
.................... #define BLINK_ON 1 
.................... #define BLINK_OFF 0 
....................  
.................... #define BL_ON 0x08 
.................... #define BL_OFF 0x00 
....................  
.................... #ifdef PCF8574A 
.................... #define pcf_address_write 0x70 | (A2_A1_A0 << 1) 
.................... #define pcf_address_read 0x71 | (A2_A1_A0 << 1) 
.................... #else // PCF8574 
.................... #define pcf_address_write 0x40 | (A2_A1_A0 << 1) 
.................... #define pcf_address_read 0x41 | (A2_A1_A0 << 1) 
.................... #endif 
....................  
.................... #ifdef LCD20X4 
.................... #define line1_start 0x00 
.................... #define line1_end 0x13 
....................  
.................... #define line2_start 0x40 
.................... #define line2_end 0x53 
....................  
.................... #define line3_start 0x14 
.................... #define line3_end 0x27 
....................  
.................... #define line4_start 0x54 
.................... #define line4_end 0x67 
....................  
.................... #define line1_start_command 0x80 
.................... #define line2_start_command 0xC0 
.................... #define line3_start_command 0x94 
.................... #define line4_start_command 0xD4 
.................... #else LCD16X2 
.................... #define line1_start 0x00 
.................... #define line1_end 0x27 
....................  
.................... #define line2_start 0x40 
.................... #define line2_end 0x67 
....................  
.................... #define line1_start_command 0x80 
.................... #define line2_start_command 0xC0 
.................... #endif 
....................  
.................... int backlight_lcd_i2c = 0x08, lcd_i2c_line = 1; 
....................  
.................... void initialize_lcd_i2c() 
.................... { 
....................     i2c_start();                  // Start communication 
*
01E1:  BSF    2B.4
01E2:  MOVF   2B,W
01E3:  BSF    03.5
01E4:  MOVWF  07
01E5:  GOTO   1E6
01E6:  BCF    03.5
01E7:  BSF    2B.3
01E8:  MOVF   2B,W
01E9:  BSF    03.5
01EA:  MOVWF  07
01EB:  NOP
01EC:  BCF    03.5
01ED:  BCF    07.4
01EE:  BCF    2B.4
01EF:  MOVF   2B,W
01F0:  BSF    03.5
01F1:  MOVWF  07
01F2:  GOTO   1F3
01F3:  BCF    03.5
01F4:  BCF    07.3
01F5:  BCF    2B.3
01F6:  MOVF   2B,W
01F7:  BSF    03.5
01F8:  MOVWF  07
....................     i2c_write(pcf_address_write); // Send PCF address + WRITE bit 
01F9:  MOVLW  7E
01FA:  BCF    03.5
01FB:  MOVWF  5E
01FC:  CALL   197
....................     i2c_write(0x2C);              // Configure LCD for 4 bits/BL ON/En 1 
01FD:  MOVLW  2C
01FE:  MOVWF  5E
01FF:  CALL   197
....................     i2c_write(0x28);              // En 0 to execute instruction 
0200:  MOVLW  28
0201:  MOVWF  5E
0202:  CALL   197
....................  
....................     delay_us(40);    // Verify the delay for bits to be sent 
0203:  MOVLW  27
0204:  MOVWF  77
0205:  DECFSZ 77,F
0206:  GOTO   205
0207:  GOTO   208
....................     i2c_write(0x2C); // Send first nibble of 
0208:  MOVLW  2C
0209:  MOVWF  5E
020A:  CALL   197
....................     i2c_write(0x28); // the "Function Set" instruction. 
020B:  MOVLW  28
020C:  MOVWF  5E
020D:  CALL   197
....................     i2c_write(0x8C); // Send second nibble of the instruction. 
020E:  MOVLW  8C
020F:  MOVWF  5E
0210:  CALL   197
....................     i2c_write(0x88); // 4 bits, 2 lines, font 5*8. 
0211:  MOVLW  88
0212:  MOVWF  5E
0213:  CALL   197
....................  
....................     delay_us(40); 
0214:  MOVLW  27
0215:  MOVWF  77
0216:  DECFSZ 77,F
0217:  GOTO   216
0218:  GOTO   219
....................  
....................     i2c_write(0x0C); // Send first nibble of 
0219:  MOVLW  0C
021A:  MOVWF  5E
021B:  CALL   197
....................     i2c_write(0x08); // "Display ON/OFF control" instruction. 
021C:  MOVLW  08
021D:  MOVWF  5E
021E:  CALL   197
....................     i2c_write(0xCC); // Send second nibble of the instruction. 
021F:  MOVLW  CC
0220:  MOVWF  5E
0221:  CALL   197
....................     i2c_write(0xC8); // Display on, cursor off, blink off. 
0222:  MOVLW  C8
0223:  MOVWF  5E
0224:  CALL   197
....................     delay_us(1); 
0225:  GOTO   226
0226:  NOP
....................  
....................     i2c_write(0x0C); // Send first nibble of 
0227:  MOVLW  0C
0228:  MOVWF  5E
0229:  CALL   197
....................     i2c_write(0x08); // "Entry Mode Set" instruction. 
022A:  MOVLW  08
022B:  MOVWF  5E
022C:  CALL   197
....................     i2c_write(0x6C); // Send second nibble of the instruction. 
022D:  MOVLW  6C
022E:  MOVWF  5E
022F:  CALL   197
....................     i2c_write(0x68); // Increment cursor with each write 
0230:  MOVLW  68
0231:  MOVWF  5E
0232:  CALL   197
....................                      // (position+=1), LCD scroll disabled; 
....................                      // if enabled, display scrolls with each character. 
....................     delay_us(40); 
0233:  MOVLW  27
0234:  MOVWF  77
0235:  DECFSZ 77,F
0236:  GOTO   235
0237:  GOTO   238
....................  
....................     i2c_stop(); 
0238:  BCF    2B.4
0239:  MOVF   2B,W
023A:  BSF    03.5
023B:  MOVWF  07
023C:  NOP
023D:  BCF    03.5
023E:  BSF    2B.3
023F:  MOVF   2B,W
0240:  BSF    03.5
0241:  MOVWF  07
0242:  BCF    03.5
0243:  BTFSS  07.3
0244:  GOTO   243
0245:  GOTO   246
0246:  GOTO   247
0247:  NOP
0248:  BSF    2B.4
0249:  MOVF   2B,W
024A:  BSF    03.5
024B:  MOVWF  07
024C:  GOTO   24D
024D:  BCF    03.5
024E:  BSF    0A.3
024F:  BCF    0A.4
0250:  GOTO   0AC (RETURN)
.................... } 
.................... void send_lcd_i2c_command(char character) 
.................... { 
....................     int ms_nibble_e, ls_nibble_e, ms_nibble, ls_nibble; 
....................  
....................     ms_nibble = character & 0xF0;   // Most significant nibble of the character. 
*
025A:  MOVF   59,W
025B:  ANDLW  F0
025C:  MOVWF  5C
....................     ls_nibble = character & 0x0F;   // Least significant nibble of the character. 
025D:  MOVF   59,W
025E:  ANDLW  0F
025F:  MOVWF  5D
....................     swap(ls_nibble);                // Swap as the most significant bits are used (D7: D4). 
0260:  SWAPF  5D,F
....................     ms_nibble |= backlight_lcd_i2c; // Add BL to the most significant nibble 
0261:  MOVF   2C,W
0262:  IORWF  5C,F
....................     ls_nibble |= backlight_lcd_i2c; // Add BL to the least significant nibble 
0263:  MOVF   2C,W
0264:  IORWF  5D,F
....................  
....................     ms_nibble_e = ms_nibble | 0x04; // Most significant nibble En 1 
0265:  MOVF   5C,W
0266:  IORLW  04
0267:  MOVWF  5A
....................     ls_nibble_e = ls_nibble | 0x04; // Least significant nibble En 1 
0268:  MOVF   5D,W
0269:  IORLW  04
026A:  MOVWF  5B
....................  
....................     i2c_start(); 
026B:  BSF    2B.4
026C:  MOVF   2B,W
026D:  BSF    03.5
026E:  MOVWF  07
026F:  GOTO   270
0270:  BCF    03.5
0271:  BSF    2B.3
0272:  MOVF   2B,W
0273:  BSF    03.5
0274:  MOVWF  07
0275:  NOP
0276:  BCF    03.5
0277:  BCF    07.4
0278:  BCF    2B.4
0279:  MOVF   2B,W
027A:  BSF    03.5
027B:  MOVWF  07
027C:  GOTO   27D
027D:  BCF    03.5
027E:  BCF    07.3
027F:  BCF    2B.3
0280:  MOVF   2B,W
0281:  BSF    03.5
0282:  MOVWF  07
....................     i2c_write(pcf_address_write); 
0283:  MOVLW  7E
0284:  BCF    03.5
0285:  MOVWF  5E
0286:  CALL   197
....................  
....................     i2c_write(ms_nibble_e); // Send 1st nibble with "E" set 
0287:  MOVF   5A,W
0288:  MOVWF  5E
0289:  CALL   197
....................     i2c_write(ms_nibble);   // Send 1st nibble with "E" cleared 
028A:  MOVF   5C,W
028B:  MOVWF  5E
028C:  CALL   197
....................  
....................     i2c_write(ls_nibble_e); // Send 2nd nibble with "E" set 
028D:  MOVF   5B,W
028E:  MOVWF  5E
028F:  CALL   197
....................     i2c_write(ls_nibble);   // Send 2nd nibble with "E" cleared 
0290:  MOVF   5D,W
0291:  MOVWF  5E
0292:  CALL   197
....................  
....................     i2c_stop(); 
0293:  BCF    2B.4
0294:  MOVF   2B,W
0295:  BSF    03.5
0296:  MOVWF  07
0297:  NOP
0298:  BCF    03.5
0299:  BSF    2B.3
029A:  MOVF   2B,W
029B:  BSF    03.5
029C:  MOVWF  07
029D:  BCF    03.5
029E:  BTFSS  07.3
029F:  GOTO   29E
02A0:  GOTO   2A1
02A1:  GOTO   2A2
02A2:  NOP
02A3:  BSF    2B.4
02A4:  MOVF   2B,W
02A5:  BSF    03.5
02A6:  MOVWF  07
02A7:  GOTO   2A8
....................     delay_us(44); 
02A8:  MOVLW  2B
02A9:  MOVWF  77
02AA:  DECFSZ 77,F
02AB:  GOTO   2AA
02AC:  GOTO   2AD
02AD:  BCF    03.5
02AE:  RETURN
.................... } 
.................... void send_lcd_i2c_character(int character) 
.................... { 
....................     int ms_nibble_e, ls_nibble_e, ms_nibble, ls_nibble; 
....................  
....................     ms_nibble = character & 0xF0; // Most significant nibble of the character. 
*
041F:  MOVF   59,W
0420:  ANDLW  F0
0421:  MOVWF  5C
....................     ls_nibble = character & 0x0F; // Least significant nibble of the character. 
0422:  MOVF   59,W
0423:  ANDLW  0F
0424:  MOVWF  5D
....................     swap(ls_nibble);              // Swap as the most significant bits are used (D7: D4). 
0425:  SWAPF  5D,F
....................  
....................     ms_nibble |= backlight_lcd_i2c; // Add BL to the most significant nibble 
0426:  MOVF   2C,W
0427:  IORWF  5C,F
....................     ls_nibble |= backlight_lcd_i2c; // Add BL to the least significant nibble 
0428:  MOVF   2C,W
0429:  IORWF  5D,F
....................     ms_nibble++;                    // Set RS bit 
042A:  INCF   5C,F
....................     ls_nibble++;                    // Set RS bit 
042B:  INCF   5D,F
....................  
....................     ms_nibble_e = ms_nibble | 0x05; // Most significant nibble En and RS = 1 
042C:  MOVF   5C,W
042D:  IORLW  05
042E:  MOVWF  5A
....................     ls_nibble_e = ls_nibble | 0x05; // Least significant nibble En and RS = 1 
042F:  MOVF   5D,W
0430:  IORLW  05
0431:  MOVWF  5B
....................  
....................     i2c_start(); 
0432:  BSF    2B.4
0433:  MOVF   2B,W
0434:  BSF    03.5
0435:  MOVWF  07
0436:  GOTO   437
0437:  BCF    03.5
0438:  BSF    2B.3
0439:  MOVF   2B,W
043A:  BSF    03.5
043B:  MOVWF  07
043C:  NOP
043D:  BCF    03.5
043E:  BCF    07.4
043F:  BCF    2B.4
0440:  MOVF   2B,W
0441:  BSF    03.5
0442:  MOVWF  07
0443:  GOTO   444
0444:  BCF    03.5
0445:  BCF    07.3
0446:  BCF    2B.3
0447:  MOVF   2B,W
0448:  BSF    03.5
0449:  MOVWF  07
....................     i2c_write(pcf_address_write); 
044A:  MOVLW  7E
044B:  BCF    03.5
044C:  MOVWF  5E
044D:  CALL   197
....................  
....................     i2c_write(ms_nibble_e); // Send 1st nibble with RS and En 1 
044E:  MOVF   5A,W
044F:  MOVWF  5E
0450:  CALL   197
....................     i2c_write(ms_nibble);   // Send 1st nibble with RS 1 and E 0 
0451:  MOVF   5C,W
0452:  MOVWF  5E
0453:  CALL   197
....................  
....................     i2c_write(ls_nibble_e); // Send 2nd nibble with RS and E 1 
0454:  MOVF   5B,W
0455:  MOVWF  5E
0456:  CALL   197
....................     i2c_write(ls_nibble);   // Send 2nd nibble with RS 0 and E 0 
0457:  MOVF   5D,W
0458:  MOVWF  5E
0459:  CALL   197
....................  
....................     i2c_stop(); 
045A:  BCF    2B.4
045B:  MOVF   2B,W
045C:  BSF    03.5
045D:  MOVWF  07
045E:  NOP
045F:  BCF    03.5
0460:  BSF    2B.3
0461:  MOVF   2B,W
0462:  BSF    03.5
0463:  MOVWF  07
0464:  BCF    03.5
0465:  BTFSS  07.3
0466:  GOTO   465
0467:  GOTO   468
0468:  GOTO   469
0469:  NOP
046A:  BSF    2B.4
046B:  MOVF   2B,W
046C:  BSF    03.5
046D:  MOVWF  07
046E:  GOTO   46F
....................     delay_us(44); 
046F:  MOVLW  2B
0470:  MOVWF  77
0471:  DECFSZ 77,F
0472:  GOTO   471
0473:  GOTO   474
.................... } 
.................... void clear_lcd_i2c() 
.................... { 
....................     send_lcd_i2c_command(0x01); 
*
02C4:  MOVLW  01
02C5:  MOVWF  59
02C6:  CALL   25A
....................     delay_ms(2); 
02C7:  MOVLW  02
02C8:  MOVWF  55
02C9:  CALL   2AF
02CA:  RETURN
.................... } 
.................... int read_cursor_address() 
.................... { 
....................     int aux, aux2, address; 
....................  
....................     aux = 0xF2 | backlight_lcd_i2c; // Set PCF pins for D7:D4 of LCD E=0 | RW=1 | RS=0. 
*
0340:  MOVF   2C,W
0341:  IORLW  F2
0342:  MOVWF  59
....................     aux2 = aux;                     // Copy aux value 
0343:  MOVF   59,W
0344:  MOVWF  5A
....................  
....................     i2c_start(); 
0345:  BSF    2B.4
0346:  MOVF   2B,W
0347:  BSF    03.5
0348:  MOVWF  07
0349:  GOTO   34A
034A:  BCF    03.5
034B:  BSF    2B.3
034C:  MOVF   2B,W
034D:  BSF    03.5
034E:  MOVWF  07
034F:  NOP
0350:  BCF    03.5
0351:  BCF    07.4
0352:  BCF    2B.4
0353:  MOVF   2B,W
0354:  BSF    03.5
0355:  MOVWF  07
0356:  GOTO   357
0357:  BCF    03.5
0358:  BCF    07.3
0359:  BCF    2B.3
035A:  MOVF   2B,W
035B:  BSF    03.5
035C:  MOVWF  07
....................     i2c_write(pcf_address_write); 
035D:  MOVLW  7E
035E:  BCF    03.5
035F:  MOVWF  5E
0360:  CALL   197
....................     i2c_write(aux);        // Set PCF pins for D7:D4 of LCD E=0 | RW=1 | RS=0. 
0361:  MOVF   59,W
0362:  MOVWF  5E
0363:  CALL   197
....................     i2c_write(aux | 0x04); // En=1 for LCD to provide most significant nibble. 
0364:  MOVF   59,W
0365:  IORLW  04
0366:  MOVWF  5C
0367:  MOVWF  5E
0368:  CALL   197
....................     i2c_start(); 
0369:  BSF    2B.4
036A:  MOVF   2B,W
036B:  BSF    03.5
036C:  MOVWF  07
036D:  GOTO   36E
036E:  BCF    03.5
036F:  BSF    2B.3
0370:  MOVF   2B,W
0371:  BSF    03.5
0372:  MOVWF  07
0373:  NOP
0374:  BCF    03.5
0375:  BTFSS  07.3
0376:  GOTO   375
0377:  BCF    07.4
0378:  BCF    2B.4
0379:  MOVF   2B,W
037A:  BSF    03.5
037B:  MOVWF  07
037C:  GOTO   37D
037D:  BCF    03.5
037E:  BCF    07.3
037F:  BCF    2B.3
0380:  MOVF   2B,W
0381:  BSF    03.5
0382:  MOVWF  07
....................     i2c_write(pcf_address_read); 
0383:  MOVLW  7F
0384:  BCF    03.5
0385:  MOVWF  5E
0386:  CALL   197
....................     address = 0x70 & i2c_read(0); // Read most significant nibble with mask 0x70. 
0387:  CLRF   77
0388:  CALL   2E3
0389:  MOVF   78,W
038A:  ANDLW  70
038B:  MOVWF  5B
....................     i2c_start(); 
038C:  BSF    2B.4
038D:  MOVF   2B,W
038E:  BSF    03.5
038F:  MOVWF  07
0390:  GOTO   391
0391:  BCF    03.5
0392:  BSF    2B.3
0393:  MOVF   2B,W
0394:  BSF    03.5
0395:  MOVWF  07
0396:  NOP
0397:  BCF    03.5
0398:  BTFSS  07.3
0399:  GOTO   398
039A:  BCF    07.4
039B:  BCF    2B.4
039C:  MOVF   2B,W
039D:  BSF    03.5
039E:  MOVWF  07
039F:  GOTO   3A0
03A0:  BCF    03.5
03A1:  BCF    07.3
03A2:  BCF    2B.3
03A3:  MOVF   2B,W
03A4:  BSF    03.5
03A5:  MOVWF  07
....................     i2c_write(pcf_address_write); 
03A6:  MOVLW  7E
03A7:  BCF    03.5
03A8:  MOVWF  5E
03A9:  CALL   197
....................     i2c_write(aux);        // Clear Enable pin of LCD 
03AA:  MOVF   59,W
03AB:  MOVWF  5E
03AC:  CALL   197
....................     i2c_write(aux | 0x04); // Set Enable pin of LCD to provide least significant nibble. 
03AD:  MOVF   59,W
03AE:  IORLW  04
03AF:  MOVWF  5C
03B0:  MOVWF  5E
03B1:  CALL   197
....................     i2c_start(); 
03B2:  BSF    2B.4
03B3:  MOVF   2B,W
03B4:  BSF    03.5
03B5:  MOVWF  07
03B6:  GOTO   3B7
03B7:  BCF    03.5
03B8:  BSF    2B.3
03B9:  MOVF   2B,W
03BA:  BSF    03.5
03BB:  MOVWF  07
03BC:  NOP
03BD:  BCF    03.5
03BE:  BTFSS  07.3
03BF:  GOTO   3BE
03C0:  BCF    07.4
03C1:  BCF    2B.4
03C2:  MOVF   2B,W
03C3:  BSF    03.5
03C4:  MOVWF  07
03C5:  GOTO   3C6
03C6:  BCF    03.5
03C7:  BCF    07.3
03C8:  BCF    2B.3
03C9:  MOVF   2B,W
03CA:  BSF    03.5
03CB:  MOVWF  07
....................     i2c_write(pcf_address_read); 
03CC:  MOVLW  7F
03CD:  BCF    03.5
03CE:  MOVWF  5E
03CF:  CALL   197
....................     aux = 0xF0 & i2c_read(0); // Read least significant nibble with mask 0xF0. 
03D0:  CLRF   77
03D1:  CALL   2E3
03D2:  MOVF   78,W
03D3:  ANDLW  F0
03D4:  MOVWF  59
....................     i2c_start(); 
03D5:  BSF    2B.4
03D6:  MOVF   2B,W
03D7:  BSF    03.5
03D8:  MOVWF  07
03D9:  GOTO   3DA
03DA:  BCF    03.5
03DB:  BSF    2B.3
03DC:  MOVF   2B,W
03DD:  BSF    03.5
03DE:  MOVWF  07
03DF:  NOP
03E0:  BCF    03.5
03E1:  BTFSS  07.3
03E2:  GOTO   3E1
03E3:  BCF    07.4
03E4:  BCF    2B.4
03E5:  MOVF   2B,W
03E6:  BSF    03.5
03E7:  MOVWF  07
03E8:  GOTO   3E9
03E9:  BCF    03.5
03EA:  BCF    07.3
03EB:  BCF    2B.3
03EC:  MOVF   2B,W
03ED:  BSF    03.5
03EE:  MOVWF  07
....................     i2c_write(pcf_address_write); 
03EF:  MOVLW  7E
03F0:  BCF    03.5
03F1:  MOVWF  5E
03F2:  CALL   197
....................     i2c_write(aux2); // Clear Enable pin first 
03F3:  MOVF   5A,W
03F4:  MOVWF  5E
03F5:  CALL   197
....................     aux2 &= 0xF8; 
03F6:  MOVLW  F8
03F7:  ANDWF  5A,F
....................     i2c_write(aux2); // Clear RW pin to exit read mode. 
03F8:  MOVF   5A,W
03F9:  MOVWF  5E
03FA:  CALL   197
....................     i2c_stop(); 
03FB:  BCF    2B.4
03FC:  MOVF   2B,W
03FD:  BSF    03.5
03FE:  MOVWF  07
03FF:  NOP
0400:  BCF    03.5
0401:  BSF    2B.3
0402:  MOVF   2B,W
0403:  BSF    03.5
0404:  MOVWF  07
0405:  BCF    03.5
0406:  BTFSS  07.3
0407:  GOTO   406
0408:  GOTO   409
0409:  GOTO   40A
040A:  NOP
040B:  BSF    2B.4
040C:  MOVF   2B,W
040D:  BSF    03.5
040E:  MOVWF  07
040F:  GOTO   410
....................  
....................     swap(aux);      // Position least significant nibble correctly. 
0410:  BCF    03.5
0411:  SWAPF  59,F
....................     address |= aux; // OR operation between least and most significant nibble. 
0412:  MOVF   59,W
0413:  IORWF  5B,F
....................     delay_us(45); 
0414:  MOVLW  2C
0415:  MOVWF  77
0416:  DECFSZ 77,F
0417:  GOTO   416
0418:  GOTO   419
....................     return (address); // Return current cursor address. 
0419:  MOVF   5B,W
041A:  MOVWF  78
.................... } 
.................... void write_lcd_i2c(char character) 
.................... { 
....................     int cursor_address; 
....................  
....................     if (character == '\n') 
*
0328:  MOVF   57,W
0329:  SUBLW  0A
032A:  BTFSS  03.2
032B:  GOTO   340
....................     {          // Position cursor at the start of the next line. 
.................... #ifdef LCD20X4 // Using LCD 20 x 4 
....................         switch (lcd_i2c_line) 
....................         { 
....................         case 1: 
....................             send_lcd_i2c_command(line2_start_command); 
....................             lcd_i2c_line = 2; 
....................             break; 
....................         case 2: 
....................             send_lcd_i2c_command(line3_start_command); 
....................             lcd_i2c_line = 3; 
....................             break; 
....................         case 3: 
....................             send_lcd_i2c_command(line4_start_command); 
....................             lcd_i2c_line = 4; 
....................             break; 
....................         case 4: 
....................             send_lcd_i2c_command(line1_start_command); 
....................             lcd_i2c_line = 1; 
....................             break; 
....................         } 
.................... #else // Using LCD 16 x 2 
....................         switch (lcd_i2c_line) 
032C:  MOVF   2D,W
032D:  XORLW  01
032E:  BTFSC  03.2
032F:  GOTO   334
0330:  XORLW  03
0331:  BTFSC  03.2
0332:  GOTO   33A
0333:  GOTO   33F
....................         { 
....................         case 1: 
....................             send_lcd_i2c_command(line2_start_command); 
0334:  MOVLW  C0
0335:  MOVWF  59
0336:  CALL   25A
....................             lcd_i2c_line = 2; 
0337:  MOVLW  02
0338:  MOVWF  2D
....................             break; 
0339:  GOTO   33F
....................         case 2: 
....................             send_lcd_i2c_command(line1_start_command); 
033A:  MOVLW  80
033B:  MOVWF  59
033C:  CALL   25A
....................             lcd_i2c_line = 1; 
033D:  MOVLW  01
033E:  MOVWF  2D
....................             break; 
....................         } 
.................... #endif 
....................     } 
033F:  GOTO   490
....................     else 
....................     { 
....................         cursor_address = read_cursor_address(); 
*
041B:  MOVF   78,W
041C:  MOVWF  58
....................         send_lcd_i2c_character(character); 
041D:  MOVF   57,W
041E:  MOVWF  59
.................... #ifdef LCD20X4 // Using LCD 20 x 4 
....................         switch (lcd_i2c_line) 
....................         { 
....................         case 1: 
....................             if (cursor_address == line1_end) 
....................             { 
....................                 send_lcd_i2c_command(line2_start_command); 
....................                 lcd_i2c_line = 2; 
....................             } 
....................             break; 
....................         case 2: 
....................             if (cursor_address == line2_end) 
....................             { 
....................                 send_lcd_i2c_command(line3_start_command); 
....................                 lcd_i2c_line = 3; 
....................             } 
....................             break; 
....................         case 3: 
....................             if (cursor_address == line3_end) 
....................             { 
....................                 send_lcd_i2c_command(line4_start_command); 
....................                 lcd_i2c_line = 4; 
....................             } 
....................             break; 
....................         case 4: 
....................             if (cursor_address == line4_end) 
....................             { 
....................                 send_lcd_i2c_command(line1_start_command); 
....................                 lcd_i2c_line = 1; 
....................             } 
....................             break; 
....................         } 
.................... #else // Using LCD 16 x 2 
....................         switch (lcd_i2c_line) 
*
0474:  BCF    03.5
0475:  MOVF   2D,W
0476:  XORLW  01
0477:  BTFSC  03.2
0478:  GOTO   47D
0479:  XORLW  03
047A:  BTFSC  03.2
047B:  GOTO   487
047C:  GOTO   490
....................         { 
....................         case 1: 
....................             if (cursor_address == line1_end) 
047D:  MOVF   58,W
047E:  SUBLW  27
047F:  BTFSS  03.2
0480:  GOTO   486
....................             { 
....................                 send_lcd_i2c_command(line2_start_command); 
0481:  MOVLW  C0
0482:  MOVWF  59
0483:  CALL   25A
....................                 lcd_i2c_line = 2; 
0484:  MOVLW  02
0485:  MOVWF  2D
....................             } 
....................             break; 
0486:  GOTO   490
....................         case 2: 
....................             if (cursor_address == line2_end) 
0487:  MOVF   58,W
0488:  SUBLW  67
0489:  BTFSS  03.2
048A:  GOTO   490
....................             { 
....................                 send_lcd_i2c_command(line1_start_command); 
048B:  MOVLW  80
048C:  MOVWF  59
048D:  CALL   25A
....................                 lcd_i2c_line = 1; 
048E:  MOVLW  01
048F:  MOVWF  2D
....................             } 
....................             break; 
....................         } 
.................... #endif 
....................     } 
0490:  RETURN
.................... } 
.................... void send_lcd_i2c_string(char *string) 
.................... { 
....................     while (*string) 
....................         write_lcd_i2c(*string++); 
.................... } 
.................... void set_lcd_i2c_cursor_position(char x, char y) 
.................... { 
....................     switch (x) 
*
02CB:  MOVF   54,W
02CC:  XORLW  01
02CD:  BTFSC  03.2
02CE:  GOTO   2D3
02CF:  XORLW  03
02D0:  BTFSC  03.2
02D1:  GOTO   2DB
02D2:  GOTO   2E2
....................     { 
....................     case 1:                                            // Line 1 
....................         send_lcd_i2c_command(line1_start_command + y); // Position command. 
02D3:  MOVLW  80
02D4:  ADDWF  55,W
02D5:  MOVWF  56
02D6:  MOVWF  59
02D7:  CALL   25A
....................         lcd_i2c_line = 1;                              // Assign current line for write control. 
02D8:  MOVLW  01
02D9:  MOVWF  2D
....................         break; 
02DA:  GOTO   2E2
....................     case 2:                                            // Line 2 
....................         send_lcd_i2c_command(line2_start_command + y); // Position command. 
02DB:  MOVLW  C0
02DC:  ADDWF  55,W
02DD:  MOVWF  56
02DE:  MOVWF  59
02DF:  CALL   25A
....................         lcd_i2c_line = 2;                              // Assign current line for write control. 
02E0:  MOVLW  02
02E1:  MOVWF  2D
....................         break; 
.................... #ifdef LCD20X4                                 // Using LCD 20 x 4 
....................     case 3:                                    // Line 3 
....................         send_lcd_i2c_command(line3_start + y); // Position command. 
....................         lcd_i2c_line = 3;                      // Assign current line for write control. 
....................         break; 
....................     case 4:                                    // Line 4 
....................         send_lcd_i2c_command(line4_start + y); // Position command. 
....................         lcd_i2c_line = 4;                      // Assign current line for write control. 
....................         break; 
.................... #endif 
....................     } 
02E2:  RETURN
.................... } 
.................... void configure_lcd_i2c(int cursor, int blink, int backlight) 
.................... { 
....................     int aux; 
....................     backlight_lcd_i2c = 0x08 * backlight; // Set backlight status. 
....................  
....................     aux = 0x08 | (cursor << 1) | blink; // Combine bits to form the control byte 
....................     send_lcd_i2c_command(aux);          // Send control command to the LCD 
.................... } 
....................  
....................  
.................... const unsigned int16 DOT_DURATION = 200; 
.................... const unsigned int16 DASH_DURATION = 600; 
....................  
.................... const int8 SW_Pin[] = {Pin_B0, Pin_B1, Pin_B2, Pin_B3, Pin_B4}; 
.................... // int8 SW_Pin = Pin_B0; // Assuming only one button for Morse code input 
....................  
.................... const int8 LED_Pin = Pin_D0; 
.................... const int8 Buzzer_Pin = Pin_D1; 
....................  
.................... unsigned int16 elapsedTime = 0; 
....................  
.................... char morseCodeBufferString[6]; 
.................... unsigned int8 morseCodeBufferIndex = 0; 
....................  
.................... char morseCodeString[16]; 
.................... unsigned int8 morseCodeStringIndex = 0; 
....................  
.................... typedef struct 
.................... { 
....................     char morseCode[6]; 
....................     char character; 
.................... } MorseCode; 
....................  
.................... const MorseCode morseCodeTable[] = { 
....................     {".-", 'A'}, // 
....................     {"-...", 'B'}, 
....................     {"-.-.", 'C'}, 
....................     {"-..", 'D'}, 
....................     {".", 'E'}, 
....................     {"..-.", 'F'}, 
....................     {"--.", 'G'}, 
....................     {"....", 'H'}, 
....................     {"..", 'I'}, 
....................     {".---", 'J'}, 
....................     {"-.-", 'K'}, 
....................     {".-..", 'L'}, 
....................     {"--", 'M'}, 
....................     {"-.", 'N'}, 
....................     {"---", 'O'}, 
....................     {".--.", 'P'}, 
....................     {"--.-", 'Q'}, 
....................     {".-.", 'R'}, 
....................     {"...", 'S'}, 
....................     {"-", 'T'}, 
....................     {"..-", 'U'}, 
....................     {"...-", 'V'}, 
....................     {".--", 'W'}, 
....................     {"-..-", 'X'}, 
....................     {"-.--", 'Y'}, 
....................     {"--..", 'Z'}, 
....................     {"-----", '0'}, 
....................     {".----", '1'}, 
....................     {"..---", '2'}, 
....................     {"...--", '3'}, 
....................     {"....-", '4'}, 
....................     {".....", '5'}, 
....................     {"-....", '6'}, 
....................     {"--...", '7'}, 
....................     {"---..", '8'}, 
....................     {"----.", '9'}}; 
....................  
.................... typedef enum 
.................... { 
....................     BUTTON_MODE, 
....................     UART_MODE 
.................... } Mode; 
....................  
.................... Mode tempMode = BUTTON_MODE; 
....................  
.................... #INT_TIMER1 
.................... void An389_Interrupt() 
.................... { 
....................     elapsedTime++; 
*
0154:  INCF   2E,F
0155:  BTFSC  03.2
0156:  INCF   2F,F
....................     set_timer1(65036); 
0157:  CLRF   0E
0158:  MOVLW  FE
0159:  MOVWF  0F
015A:  MOVLW  0C
015B:  MOVWF  0E
....................     clear_interrupt(INT_TIMER1); 
015C:  BCF    0C.0
015D:  BCF    0C.0
015E:  BCF    0A.3
015F:  BCF    0A.4
0160:  GOTO   02D
.................... } 
....................  
.................... void startTimer() 
.................... { 
....................     elapsedTime = 0; 
*
06B5:  CLRF   2F
06B6:  CLRF   2E
....................  
....................     // setup timer1, 1ms interrupt, 16MHz, timer1 16 bit, prescaler 1:8 
....................     // 16MHz / 4 = 4MHz 
....................     // 4MHz / 8 = 500KHz 
....................     // 1 / 500KHz = 2us 
....................     // 1ms / 2us = 500 
....................     // 65536 - 500 = 65036 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
06B7:  MOVLW  35
06B8:  MOVWF  10
....................     set_timer1(65036); 
06B9:  CLRF   0E
06BA:  MOVLW  FE
06BB:  MOVWF  0F
06BC:  MOVLW  0C
06BD:  MOVWF  0E
....................     enable_interrupts(INT_TIMER1); 
06BE:  BSF    03.5
06BF:  BSF    0C.0
....................     enable_interrupts(GLOBAL); 
06C0:  MOVLW  C0
06C1:  BCF    03.5
06C2:  IORWF  0B,F
06C3:  RETURN
.................... } 
....................  
.................... unsigned int16 getTimerValue() 
.................... { 
....................     return elapsedTime; 
*
0812:  MOVF   2E,W
0813:  MOVWF  78
0814:  MOVF   2F,W
0815:  MOVWF  79
.................... } 
....................  
.................... unsigned int16 stopAndReadTimer() 
.................... { 
....................     disable_interrupts(INT_TIMER1); 
*
06C4:  BSF    03.5
06C5:  BCF    0C.0
....................     disable_interrupts(GLOBAL); 
06C6:  BCF    03.5
06C7:  BCF    0B.6
06C8:  BCF    0B.7
06C9:  BTFSC  0B.7
06CA:  GOTO   6C8
....................     return elapsedTime; 
06CB:  MOVF   2E,W
06CC:  MOVWF  78
06CD:  MOVF   2F,W
06CE:  MOVWF  79
06CF:  RETURN
.................... } 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
075F:  MOVF   55,W
0760:  MOVWF  7A
0761:  MOVF   54,W
0762:  MOVWF  04
0763:  BCF    03.7
0764:  BTFSC  7A.0
0765:  BSF    03.7
0766:  MOVF   00,W
0767:  MOVWF  58
0768:  MOVF   57,W
0769:  MOVWF  7A
076A:  MOVF   56,W
076B:  MOVWF  04
076C:  BCF    03.7
076D:  BTFSC  7A.0
076E:  BSF    03.7
076F:  MOVF   00,W
0770:  SUBWF  58,W
0771:  BTFSS  03.2
0772:  GOTO   78A
....................       if (*s1 == '\0') 
0773:  MOVF   55,W
0774:  MOVWF  7A
0775:  MOVF   54,W
0776:  MOVWF  04
0777:  BCF    03.7
0778:  BTFSC  7A.0
0779:  BSF    03.7
077A:  MOVF   00,F
077B:  BTFSS  03.2
077C:  GOTO   780
....................          return(0); 
077D:  MOVLW  00
077E:  MOVWF  78
077F:  GOTO   7A2
0780:  MOVF   55,W
0781:  MOVWF  7A
0782:  MOVF   54,W
0783:  INCF   54,F
0784:  BTFSC  03.2
0785:  INCF   55,F
0786:  INCF   56,F
0787:  BTFSC  03.2
0788:  INCF   57,F
0789:  GOTO   75F
....................    return((*s1 < *s2) ? -1: 1); 
078A:  MOVF   55,W
078B:  MOVWF  7A
078C:  MOVF   54,W
078D:  MOVWF  04
078E:  BCF    03.7
078F:  BTFSC  55.0
0790:  BSF    03.7
0791:  MOVF   00,W
0792:  MOVWF  58
0793:  MOVF   57,W
0794:  MOVWF  7A
0795:  MOVF   56,W
0796:  MOVWF  04
0797:  BCF    03.7
0798:  BTFSC  57.0
0799:  BSF    03.7
079A:  MOVF   00,W
079B:  SUBWF  58,W
079C:  BTFSC  03.0
079D:  GOTO   7A0
079E:  MOVLW  FF
079F:  GOTO   7A1
07A0:  MOVLW  01
07A1:  MOVWF  78
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
08A7:  BCF    03.6
08A8:  CLRF   49
08A9:  CLRF   4A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <morseCodeReader.c> 
.................... #include <globalVariables.h> 
.................... #ifndef VAR_H 
.................... #define VAR_H 
....................  
.................... #include <lcd_i2c.c> 
....................  
.................... const unsigned int16 DOT_DURATION = 200; 
.................... const unsigned int16 DASH_DURATION = 600; 
....................  
.................... const int8 SW_Pin[] = {Pin_B0, Pin_B1, Pin_B2, Pin_B3, Pin_B4}; 
.................... // int8 SW_Pin = Pin_B0; // Assuming only one button for Morse code input 
....................  
.................... const int8 LED_Pin = Pin_D0; 
.................... const int8 Buzzer_Pin = Pin_D1; 
....................  
.................... unsigned int16 elapsedTime = 0; 
....................  
.................... char morseCodeBufferString[6]; 
.................... unsigned int8 morseCodeBufferIndex = 0; 
....................  
.................... char morseCodeString[16]; 
.................... unsigned int8 morseCodeStringIndex = 0; 
....................  
.................... typedef struct 
.................... { 
....................     char morseCode[6]; 
....................     char character; 
.................... } MorseCode; 
....................  
.................... const MorseCode morseCodeTable[] = { 
....................     {".-", 'A'}, // 
....................     {"-...", 'B'}, 
....................     {"-.-.", 'C'}, 
....................     {"-..", 'D'}, 
....................     {".", 'E'}, 
....................     {"..-.", 'F'}, 
....................     {"--.", 'G'}, 
....................     {"....", 'H'}, 
....................     {"..", 'I'}, 
....................     {".---", 'J'}, 
....................     {"-.-", 'K'}, 
....................     {".-..", 'L'}, 
....................     {"--", 'M'}, 
....................     {"-.", 'N'}, 
....................     {"---", 'O'}, 
....................     {".--.", 'P'}, 
....................     {"--.-", 'Q'}, 
....................     {".-.", 'R'}, 
....................     {"...", 'S'}, 
....................     {"-", 'T'}, 
....................     {"..-", 'U'}, 
....................     {"...-", 'V'}, 
....................     {".--", 'W'}, 
....................     {"-..-", 'X'}, 
....................     {"-.--", 'Y'}, 
....................     {"--..", 'Z'}, 
....................     {"-----", '0'}, 
....................     {".----", '1'}, 
....................     {"..---", '2'}, 
....................     {"...--", '3'}, 
....................     {"....-", '4'}, 
....................     {".....", '5'}, 
....................     {"-....", '6'}, 
....................     {"--...", '7'}, 
....................     {"---..", '8'}, 
....................     {"----.", '9'}}; 
....................  
.................... typedef enum 
.................... { 
....................     BUTTON_MODE, 
....................     UART_MODE 
.................... } Mode; 
....................  
.................... Mode tempMode = BUTTON_MODE; 
....................  
.................... #INT_TIMER1 
.................... void An389_Interrupt() 
.................... { 
....................     elapsedTime++; 
....................     set_timer1(65036); 
....................     clear_interrupt(INT_TIMER1); 
.................... } 
....................  
.................... void startTimer() 
.................... { 
....................     elapsedTime = 0; 
....................  
....................     // setup timer1, 1ms interrupt, 16MHz, timer1 16 bit, prescaler 1:8 
....................     // 16MHz / 4 = 4MHz 
....................     // 4MHz / 8 = 500KHz 
....................     // 1 / 500KHz = 2us 
....................     // 1ms / 2us = 500 
....................     // 65536 - 500 = 65036 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
....................     set_timer1(65036); 
....................     enable_interrupts(INT_TIMER1); 
....................     enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... unsigned int16 getTimerValue() 
.................... { 
....................     return elapsedTime; 
.................... } 
....................  
.................... unsigned int16 stopAndReadTimer() 
.................... { 
....................     disable_interrupts(INT_TIMER1); 
....................     disable_interrupts(GLOBAL); 
....................     return elapsedTime; 
.................... } 
....................  
.................... #endif 
....................  
.................... // #include <lcd_i2c.c> 
....................  
.................... void appendMorseCode(char morseChar) 
.................... { 
....................    morseCodeBufferString[morseCodeBufferIndex++] = morseChar; 
*
071C:  MOVF   36,W
071D:  INCF   36,F
071E:  ADDLW  30
071F:  MOVWF  04
0720:  BCF    03.7
0721:  MOVF   50,W
0722:  MOVWF  00
....................    morseCodeBufferString[morseCodeBufferIndex] = '\0'; // Null-terminate the string 
0723:  MOVLW  30
0724:  ADDWF  36,W
0725:  MOVWF  04
0726:  BCF    03.7
0727:  CLRF   00
.................... } 
....................  
.................... void clearMorseCodeBuffer() 
.................... { 
....................    memset(morseCodeBufferString, 0, sizeof(morseCodeBufferString)); 
*
04E7:  MOVLW  30
04E8:  MOVWF  04
04E9:  BCF    03.7
04EA:  CLRF   77
04EB:  MOVLW  06
04EC:  MOVWF  78
04ED:  CALL   251
....................    morseCodeBufferIndex = 0; 
04EE:  CLRF   36
04EF:  RETURN
.................... } 
....................  
.................... void clearMorseCodeString() 
.................... { 
....................    memset(morseCodeString, 0, sizeof(morseCodeString)); 
*
04F1:  MOVLW  37
04F2:  MOVWF  04
04F3:  BCF    03.7
04F4:  CLRF   77
04F5:  MOVLW  10
04F6:  MOVWF  78
04F7:  CALL   251
....................    morseCodeStringIndex = 0; 
04F8:  CLRF   47
.................... } 
....................  
.................... void clearAll() 
.................... { 
....................    clearMorseCodeBuffer(); 
*
04F0:  CALL   4E7
....................    clearMorseCodeString(); 
....................  
....................    clear_lcd_i2c(); 
*
04F9:  CALL   2C4
04FA:  RETURN
.................... } 
....................  
.................... void translateMorseCode() 
.................... { 
....................    for (int i = 0; i < sizeof(morseCodeTable) / sizeof(MorseCode); ++i) 
*
073C:  CLRF   4D
073D:  MOVF   4D,W
073E:  SUBLW  23
073F:  BTFSS  03.0
0740:  GOTO   7B8
....................    { 
....................       char temp[6]; 
....................       strcpy(temp, morseCodeTable[i].morseCode); 
0741:  MOVF   4D,W
0742:  MOVWF  56
0743:  MOVLW  07
0744:  MOVWF  57
0745:  CALL   4FB
0746:  MOVF   78,W
0747:  MOVWF  54
0748:  CLRF   55
0749:  MOVF   54,W
074A:  MOVWF  56
074B:  MOVLW  4E
074C:  MOVWF  04
074D:  BCF    03.7
074E:  MOVF   55,W
074F:  ADDWF  04,F
0750:  MOVF   56,W
0751:  CALL   051
0752:  MOVWF  00
0753:  IORLW  00
0754:  BTFSC  03.2
0755:  GOTO   759
0756:  INCF   56,F
0757:  INCF   55,F
0758:  GOTO   74B
....................  
....................       if (strcmp(morseCodeBufferString, temp) == 0) 
0759:  CLRF   55
075A:  MOVLW  30
075B:  MOVWF  54
075C:  CLRF   57
075D:  MOVLW  4E
075E:  MOVWF  56
*
07A2:  MOVF   78,F
07A3:  BTFSS  03.2
07A4:  GOTO   7B6
....................       { 
....................          morseCodeString[morseCodeStringIndex++] = morseCodeTable[i].character; 
07A5:  MOVF   47,W
07A6:  INCF   47,F
07A7:  ADDLW  37
07A8:  MOVWF  04
07A9:  BCF    03.7
07AA:  MOVF   4D,W
07AB:  MOVWF  56
07AC:  MOVLW  07
07AD:  MOVWF  57
07AE:  CALL   4FB
07AF:  MOVLW  06
07B0:  ADDWF  78,W
07B1:  CALL   051
07B2:  MOVWF  78
07B3:  MOVWF  00
....................          clearMorseCodeBuffer(); 
07B4:  CALL   4E7
....................          return; 
07B5:  GOTO   7C0
....................       } 
07B6:  INCF   4D,F
07B7:  GOTO   73D
....................    } 
....................    morseCodeString[morseCodeStringIndex++] = '?'; 
07B8:  MOVF   47,W
07B9:  INCF   47,F
07BA:  ADDLW  37
07BB:  MOVWF  04
07BC:  BCF    03.7
07BD:  MOVLW  3F
07BE:  MOVWF  00
....................    clearMorseCodeBuffer(); 
07BF:  CALL   4E7
.................... } 
....................  
.................... void recordMorseCode() 
.................... { 
....................    startTimer(); 
*
06D9:  CALL   6B5
....................    delay_ms(50);           // Debounce 
06DA:  MOVLW  32
06DB:  MOVWF  55
06DC:  CALL   2AF
....................    output_high(LED_Pin);   // Turn on LED 
06DD:  BSF    03.5
06DE:  BCF    08.0
06DF:  BCF    03.5
06E0:  BSF    08.0
....................    output_low(Buzzer_Pin); // Turn on buzzer 
06E1:  BSF    03.5
06E2:  BCF    08.1
06E3:  BCF    03.5
06E4:  BCF    08.1
....................  
....................    while (input(SW_Pin[0]) == 0) 
06E5:  BSF    03.5
06E6:  BSF    06.0
06E7:  BCF    03.5
06E8:  BTFSC  06.0
06E9:  GOTO   6FE
....................    { 
....................       if (elapsedTime > DASH_DURATION) 
06EA:  MOVF   2F,W
06EB:  SUBLW  01
06EC:  BTFSC  03.0
06ED:  GOTO   6FD
06EE:  XORLW  FF
06EF:  BTFSS  03.2
06F0:  GOTO   6F5
06F1:  MOVF   2E,W
06F2:  SUBLW  58
06F3:  BTFSC  03.0
06F4:  GOTO   6FD
....................       { 
....................          output_low(LED_Pin);     // Turn off led 
06F5:  BSF    03.5
06F6:  BCF    08.0
06F7:  BCF    03.5
06F8:  BCF    08.0
....................          output_high(Buzzer_Pin); // Turn off buzzer 
06F9:  BSF    03.5
06FA:  BCF    08.1
06FB:  BCF    03.5
06FC:  BSF    08.1
....................       } 
06FD:  GOTO   6E5
....................    } 
....................  
....................    output_low(LED_Pin);     // Turn off LED 
06FE:  BSF    03.5
06FF:  BCF    08.0
0700:  BCF    03.5
0701:  BCF    08.0
....................    output_high(Buzzer_Pin); // Turn off buzzer 
0702:  BSF    03.5
0703:  BCF    08.1
0704:  BCF    03.5
0705:  BSF    08.1
....................  
....................    unsigned int16 duration = stopAndReadTimer(); 
0706:  CALL   6C4
0707:  MOVF   79,W
0708:  MOVWF  4E
0709:  MOVF   78,W
070A:  MOVWF  4D
....................    appendMorseCode(duration > DASH_DURATION ? '-' : '.'); 
070B:  MOVF   4E,W
070C:  SUBLW  01
070D:  BTFSC  03.0
070E:  GOTO   718
070F:  XORLW  FF
0710:  BTFSS  03.2
0711:  GOTO   716
0712:  MOVF   4D,W
0713:  SUBLW  58
0714:  BTFSC  03.0
0715:  GOTO   718
0716:  MOVLW  2D
0717:  GOTO   719
0718:  MOVLW  2E
0719:  MOVWF  4F
071A:  MOVF   4F,W
071B:  MOVWF  50
....................  
....................    set_lcd_i2c_cursor_position(2, 0); 
*
0728:  MOVLW  02
0729:  MOVWF  54
072A:  CLRF   55
072B:  CALL   2CB
....................    printf(write_lcd_i2c, "%s", morseCodeBufferString); 
072C:  MOVLW  30
072D:  MOVWF  04
072E:  BCF    03.7
072F:  CALL   670
.................... } 
....................  
.................... void completeMorseCode() 
.................... { 
....................    if (morseCodeBufferIndex > 0) 
*
0739:  MOVF   36,F
073A:  BTFSC  03.2
073B:  GOTO   7C9
....................    { 
....................       translateMorseCode(); 
....................       clear_lcd_i2c(); 
*
07C0:  CALL   2C4
....................       set_lcd_i2c_cursor_position(1, 0); 
07C1:  MOVLW  01
07C2:  MOVWF  54
07C3:  CLRF   55
07C4:  CALL   2CB
....................       printf(write_lcd_i2c, "%s", morseCodeString); 
07C5:  MOVLW  37
07C6:  MOVWF  04
07C7:  BCF    03.7
07C8:  CALL   670
....................    } 
.................... } 
....................  
.................... #include <morseCodeSpeaker.c> 
.................... #include <globalVariables.h> 
.................... #ifndef VAR_H 
.................... #define VAR_H 
....................  
.................... #include <lcd_i2c.c> 
....................  
.................... const unsigned int16 DOT_DURATION = 200; 
.................... const unsigned int16 DASH_DURATION = 600; 
....................  
.................... const int8 SW_Pin[] = {Pin_B0, Pin_B1, Pin_B2, Pin_B3, Pin_B4}; 
.................... // int8 SW_Pin = Pin_B0; // Assuming only one button for Morse code input 
....................  
.................... const int8 LED_Pin = Pin_D0; 
.................... const int8 Buzzer_Pin = Pin_D1; 
....................  
.................... unsigned int16 elapsedTime = 0; 
....................  
.................... char morseCodeBufferString[6]; 
.................... unsigned int8 morseCodeBufferIndex = 0; 
....................  
.................... char morseCodeString[16]; 
.................... unsigned int8 morseCodeStringIndex = 0; 
....................  
.................... typedef struct 
.................... { 
....................     char morseCode[6]; 
....................     char character; 
.................... } MorseCode; 
....................  
.................... const MorseCode morseCodeTable[] = { 
....................     {".-", 'A'}, // 
....................     {"-...", 'B'}, 
....................     {"-.-.", 'C'}, 
....................     {"-..", 'D'}, 
....................     {".", 'E'}, 
....................     {"..-.", 'F'}, 
....................     {"--.", 'G'}, 
....................     {"....", 'H'}, 
....................     {"..", 'I'}, 
....................     {".---", 'J'}, 
....................     {"-.-", 'K'}, 
....................     {".-..", 'L'}, 
....................     {"--", 'M'}, 
....................     {"-.", 'N'}, 
....................     {"---", 'O'}, 
....................     {".--.", 'P'}, 
....................     {"--.-", 'Q'}, 
....................     {".-.", 'R'}, 
....................     {"...", 'S'}, 
....................     {"-", 'T'}, 
....................     {"..-", 'U'}, 
....................     {"...-", 'V'}, 
....................     {".--", 'W'}, 
....................     {"-..-", 'X'}, 
....................     {"-.--", 'Y'}, 
....................     {"--..", 'Z'}, 
....................     {"-----", '0'}, 
....................     {".----", '1'}, 
....................     {"..---", '2'}, 
....................     {"...--", '3'}, 
....................     {"....-", '4'}, 
....................     {".....", '5'}, 
....................     {"-....", '6'}, 
....................     {"--...", '7'}, 
....................     {"---..", '8'}, 
....................     {"----.", '9'}}; 
....................  
.................... typedef enum 
.................... { 
....................     BUTTON_MODE, 
....................     UART_MODE 
.................... } Mode; 
....................  
.................... Mode tempMode = BUTTON_MODE; 
....................  
.................... #INT_TIMER1 
.................... void An389_Interrupt() 
.................... { 
....................     elapsedTime++; 
....................     set_timer1(65036); 
....................     clear_interrupt(INT_TIMER1); 
.................... } 
....................  
.................... void startTimer() 
.................... { 
....................     elapsedTime = 0; 
....................  
....................     // setup timer1, 1ms interrupt, 16MHz, timer1 16 bit, prescaler 1:8 
....................     // 16MHz / 4 = 4MHz 
....................     // 4MHz / 8 = 500KHz 
....................     // 1 / 500KHz = 2us 
....................     // 1ms / 2us = 500 
....................     // 65536 - 500 = 65036 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
....................     set_timer1(65036); 
....................     enable_interrupts(INT_TIMER1); 
....................     enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... unsigned int16 getTimerValue() 
.................... { 
....................     return elapsedTime; 
.................... } 
....................  
.................... unsigned int16 stopAndReadTimer() 
.................... { 
....................     disable_interrupts(INT_TIMER1); 
....................     disable_interrupts(GLOBAL); 
....................     return elapsedTime; 
.................... } 
....................  
.................... #endif 
....................  
.................... // #include <lcd_i2c.c> 
....................  
.................... void playMorseCodeWithBuzzer() 
.................... { 
....................     for (int i = 0; i < morseCodeStringIndex; ++i) 
*
054C:  CLRF   4E
054D:  MOVF   47,W
054E:  SUBWF  4E,W
054F:  BTFSC  03.0
0550:  GOTO   5DD
....................     { 
....................         char c = morseCodeString[i]; 
0551:  MOVLW  37
0552:  ADDWF  4E,W
0553:  MOVWF  04
0554:  BCF    03.7
0555:  MOVF   00,W
0556:  MOVWF  4F
....................         for (int j = 0; j < sizeof(morseCodeTable) / sizeof(MorseCode); ++j) 
0557:  CLRF   50
0558:  MOVF   50,W
0559:  SUBLW  23
055A:  BTFSS  03.0
055B:  GOTO   5DB
....................         { 
....................             if (c == morseCodeTable[j].character) 
055C:  MOVF   50,W
055D:  MOVWF  56
055E:  MOVLW  07
055F:  MOVWF  57
0560:  CALL   4FB
0561:  MOVLW  06
0562:  ADDWF  78,W
0563:  CALL   051
0564:  MOVWF  78
0565:  SUBWF  4F,W
0566:  BTFSS  03.2
0567:  GOTO   5D9
....................             { 
....................                 set_lcd_i2c_cursor_position(2, 0); 
0568:  MOVLW  02
0569:  MOVWF  54
056A:  CLRF   55
056B:  CALL   2CB
....................                 printf(write_lcd_i2c, "%c: %s", c, morseCodeTable[j].morseCode); 
056C:  MOVF   50,W
056D:  MOVWF  56
056E:  MOVLW  07
056F:  MOVWF  57
0570:  CALL   4FB
0571:  MOVF   78,W
0572:  MOVWF  54
0573:  MOVF   4F,W
0574:  MOVWF  57
0575:  CALL   328
0576:  MOVLW  3A
0577:  MOVWF  57
0578:  CALL   328
0579:  MOVLW  20
057A:  MOVWF  57
057B:  CALL   328
057C:  MOVLW  58
057D:  BSF    03.6
057E:  MOVWF  0D
057F:  MOVLW  00
0580:  MOVWF  0F
0581:  BCF    03.6
0582:  MOVF   54,W
0583:  BSF    03.6
0584:  ADDWF  0D,F
0585:  BTFSC  03.0
0586:  INCF   0F,F
0587:  BCF    03.6
0588:  CALL   520
....................  
....................                 unsigned int8 k = 0; 
0589:  CLRF   51
....................                 while (morseCodeTable[j].morseCode[k] != '\0') 
058A:  MOVF   50,W
058B:  MOVWF  56
058C:  MOVLW  07
058D:  MOVWF  57
058E:  CALL   4FB
058F:  MOVF   51,W
0590:  ADDWF  78,W
0591:  CALL   051
0592:  XORLW  00
0593:  BTFSC  03.2
0594:  GOTO   5C7
....................                 { 
....................                     output_low(Buzzer_Pin); 
0595:  BSF    03.5
0596:  BCF    08.1
0597:  BCF    03.5
0598:  BCF    08.1
....................                     unsigned int16 duration = morseCodeTable[j].morseCode[k] == '-' ? DASH_DURATION : DOT_DURATION; 
0599:  MOVF   50,W
059A:  MOVWF  56
059B:  MOVLW  07
059C:  MOVWF  57
059D:  CALL   4FB
059E:  MOVF   51,W
059F:  ADDWF  78,W
05A0:  CALL   051
05A1:  SUBLW  2D
05A2:  BTFSS  03.2
05A3:  GOTO   5A8
05A4:  MOVLW  02
05A5:  MOVWF  7A
05A6:  MOVLW  58
05A7:  GOTO   5AA
05A8:  CLRF   7A
05A9:  MOVLW  C8
05AA:  MOVWF  52
05AB:  MOVF   7A,W
05AC:  MOVWF  53
....................                     delay_ms(duration); 
05AD:  MOVF   53,W
05AE:  MOVWF  54
05AF:  INCF   54,F
05B0:  DECF   54,F
05B1:  BTFSC  03.2
05B2:  GOTO   5B7
05B3:  MOVLW  FF
05B4:  MOVWF  55
05B5:  CALL   2AF
05B6:  GOTO   5B0
05B7:  MOVF   52,W
05B8:  MOVWF  55
05B9:  CALL   2AF
....................                     output_high(Buzzer_Pin); 
05BA:  BSF    03.5
05BB:  BCF    08.1
05BC:  BCF    03.5
05BD:  BSF    08.1
....................  
....................                     delay_ms(400); 
05BE:  MOVLW  02
05BF:  MOVWF  54
05C0:  MOVLW  C8
05C1:  MOVWF  55
05C2:  CALL   2AF
05C3:  DECFSZ 54,F
05C4:  GOTO   5C0
....................  
....................                     k++; 
05C5:  INCF   51,F
05C6:  GOTO   58A
....................                 } 
....................  
....................                 set_lcd_i2c_cursor_position(2, 0); 
05C7:  MOVLW  02
05C8:  MOVWF  54
05C9:  CLRF   55
05CA:  CALL   2CB
....................                 printf(write_lcd_i2c, "                "); 
05CB:  MOVLW  61
05CC:  BSF    03.6
05CD:  MOVWF  0D
05CE:  MOVLW  01
05CF:  MOVWF  0F
05D0:  BCF    03.6
05D1:  CALL   491
....................  
....................                 delay_ms(800); 
05D2:  MOVLW  04
05D3:  MOVWF  54
05D4:  MOVLW  C8
05D5:  MOVWF  55
05D6:  CALL   2AF
05D7:  DECFSZ 54,F
05D8:  GOTO   5D4
....................             } 
05D9:  INCF   50,F
05DA:  GOTO   558
....................         } 
05DB:  INCF   4E,F
05DC:  GOTO   54D
....................     } 
05DD:  RETURN
.................... } 
....................  
.................... void playMorseCodeWithLED() 
.................... { 
....................     for (int i = 0; i < morseCodeStringIndex; ++i) 
05DE:  CLRF   4E
05DF:  MOVF   47,W
05E0:  SUBWF  4E,W
05E1:  BTFSC  03.0
05E2:  GOTO   66F
....................     { 
....................         char c = morseCodeString[i]; 
05E3:  MOVLW  37
05E4:  ADDWF  4E,W
05E5:  MOVWF  04
05E6:  BCF    03.7
05E7:  MOVF   00,W
05E8:  MOVWF  4F
....................         for (int j = 0; j < sizeof(morseCodeTable) / sizeof(MorseCode); ++j) 
05E9:  CLRF   50
05EA:  MOVF   50,W
05EB:  SUBLW  23
05EC:  BTFSS  03.0
05ED:  GOTO   66D
....................         { 
....................             if (c == morseCodeTable[j].character) 
05EE:  MOVF   50,W
05EF:  MOVWF  56
05F0:  MOVLW  07
05F1:  MOVWF  57
05F2:  CALL   4FB
05F3:  MOVLW  06
05F4:  ADDWF  78,W
05F5:  CALL   051
05F6:  MOVWF  78
05F7:  SUBWF  4F,W
05F8:  BTFSS  03.2
05F9:  GOTO   66B
....................             { 
....................                 set_lcd_i2c_cursor_position(2, 0); 
05FA:  MOVLW  02
05FB:  MOVWF  54
05FC:  CLRF   55
05FD:  CALL   2CB
....................                 printf(write_lcd_i2c, "%c: %s", c, morseCodeTable[j].morseCode); 
05FE:  MOVF   50,W
05FF:  MOVWF  56
0600:  MOVLW  07
0601:  MOVWF  57
0602:  CALL   4FB
0603:  MOVF   78,W
0604:  MOVWF  54
0605:  MOVF   4F,W
0606:  MOVWF  57
0607:  CALL   328
0608:  MOVLW  3A
0609:  MOVWF  57
060A:  CALL   328
060B:  MOVLW  20
060C:  MOVWF  57
060D:  CALL   328
060E:  MOVLW  58
060F:  BSF    03.6
0610:  MOVWF  0D
0611:  MOVLW  00
0612:  MOVWF  0F
0613:  BCF    03.6
0614:  MOVF   54,W
0615:  BSF    03.6
0616:  ADDWF  0D,F
0617:  BTFSC  03.0
0618:  INCF   0F,F
0619:  BCF    03.6
061A:  CALL   520
....................  
....................                 unsigned int8 k = 0; 
061B:  CLRF   51
....................                 while (morseCodeTable[j].morseCode[k] != '\0') 
061C:  MOVF   50,W
061D:  MOVWF  56
061E:  MOVLW  07
061F:  MOVWF  57
0620:  CALL   4FB
0621:  MOVF   51,W
0622:  ADDWF  78,W
0623:  CALL   051
0624:  XORLW  00
0625:  BTFSC  03.2
0626:  GOTO   659
....................                 { 
....................                     output_high(LED_Pin); 
0627:  BSF    03.5
0628:  BCF    08.0
0629:  BCF    03.5
062A:  BSF    08.0
....................                     unsigned int16 duration = morseCodeTable[j].morseCode[k] == '-' ? DASH_DURATION : DOT_DURATION; 
062B:  MOVF   50,W
062C:  MOVWF  56
062D:  MOVLW  07
062E:  MOVWF  57
062F:  CALL   4FB
0630:  MOVF   51,W
0631:  ADDWF  78,W
0632:  CALL   051
0633:  SUBLW  2D
0634:  BTFSS  03.2
0635:  GOTO   63A
0636:  MOVLW  02
0637:  MOVWF  7A
0638:  MOVLW  58
0639:  GOTO   63C
063A:  CLRF   7A
063B:  MOVLW  C8
063C:  MOVWF  52
063D:  MOVF   7A,W
063E:  MOVWF  53
....................                     delay_ms(duration); 
063F:  MOVF   53,W
0640:  MOVWF  54
0641:  INCF   54,F
0642:  DECF   54,F
0643:  BTFSC  03.2
0644:  GOTO   649
0645:  MOVLW  FF
0646:  MOVWF  55
0647:  CALL   2AF
0648:  GOTO   642
0649:  MOVF   52,W
064A:  MOVWF  55
064B:  CALL   2AF
....................                     output_low(LED_Pin); 
064C:  BSF    03.5
064D:  BCF    08.0
064E:  BCF    03.5
064F:  BCF    08.0
....................  
....................                     delay_ms(400); 
0650:  MOVLW  02
0651:  MOVWF  54
0652:  MOVLW  C8
0653:  MOVWF  55
0654:  CALL   2AF
0655:  DECFSZ 54,F
0656:  GOTO   652
....................  
....................                     k++; 
0657:  INCF   51,F
0658:  GOTO   61C
....................                 } 
....................  
....................                 set_lcd_i2c_cursor_position(2, 0); 
0659:  MOVLW  02
065A:  MOVWF  54
065B:  CLRF   55
065C:  CALL   2CB
....................                 printf(write_lcd_i2c, "                "); 
065D:  MOVLW  6A
065E:  BSF    03.6
065F:  MOVWF  0D
0660:  MOVLW  01
0661:  MOVWF  0F
0662:  BCF    03.6
0663:  CALL   491
....................  
....................                 delay_ms(800); 
0664:  MOVLW  04
0665:  MOVWF  54
0666:  MOVLW  C8
0667:  MOVWF  55
0668:  CALL   2AF
0669:  DECFSZ 54,F
066A:  GOTO   666
....................             } 
066B:  INCF   50,F
066C:  GOTO   5EA
....................         } 
066D:  INCF   4E,F
066E:  GOTO   5DF
....................     } 
066F:  RETURN
.................... } 
....................  
....................  
....................  
....................  
.................... void (*inputMode)(void); 
....................  
.................... void handleUartMode() 
.................... { 
....................     if (kbhit()) 
*
0686:  BTFSS  0C.5
0687:  GOTO   6B4
....................     { 
....................         char c = fgetc(); 
0688:  BTFSS  0C.5
0689:  GOTO   688
068A:  MOVF   1A,W
068B:  MOVWF  4D
....................  
....................         switch (c) 
068C:  MOVF   4D,W
068D:  XORLW  63
068E:  BTFSC  03.2
068F:  GOTO   69A
0690:  XORLW  01
0691:  BTFSC  03.2
0692:  GOTO   69C
0693:  XORLW  0E
0694:  BTFSC  03.2
0695:  GOTO   69E
0696:  XORLW  61
0697:  BTFSC  03.2
0698:  GOTO   6A0
0699:  GOTO   6A9
....................         { 
....................         case 'c': 
....................             clearAll(); 
069A:  CALL   4F0
....................             break; 
069B:  GOTO   6B4
....................  
....................         case 'b': 
....................             playMorseCodeWithBuzzer(); 
069C:  CALL   54C
....................             break; 
069D:  GOTO   6B4
....................  
....................         case 'l': 
....................             playMorseCodeWithLED(); 
069E:  CALL   5DE
....................             break; 
069F:  GOTO   6B4
....................  
....................         case '\r': 
....................             set_lcd_i2c_cursor_position(1, 0); 
06A0:  MOVLW  01
06A1:  MOVWF  54
06A2:  CLRF   55
06A3:  CALL   2CB
....................             printf(write_lcd_i2c, "%s", morseCodeString); 
06A4:  MOVLW  37
06A5:  MOVWF  04
06A6:  BCF    03.7
06A7:  CALL   670
....................             break; 
06A8:  GOTO   6B4
....................  
....................         default: 
....................             if (morseCodeStringIndex < sizeof(morseCodeString)) 
06A9:  MOVF   47,W
06AA:  SUBLW  0F
06AB:  BTFSS  03.0
06AC:  GOTO   6B4
....................             { 
....................                 morseCodeString[morseCodeStringIndex++] = c; 
06AD:  MOVF   47,W
06AE:  INCF   47,F
06AF:  ADDLW  37
06B0:  MOVWF  04
06B1:  BCF    03.7
06B2:  MOVF   4D,W
06B3:  MOVWF  00
....................             } 
....................             break; 
....................         } 
....................     } 
06B4:  RETURN
.................... } 
....................  
.................... void handleButtonMode() 
.................... { 
....................     if (input(SW_Pin[0]) == 0 && morseCodeStringIndex < sizeof(morseCodeString)) // create morse code character 
*
06D0:  BSF    03.5
06D1:  BSF    06.0
06D2:  BCF    03.5
06D3:  BTFSC  06.0
06D4:  GOTO   731
06D5:  MOVF   47,W
06D6:  SUBLW  0F
06D7:  BTFSS  03.0
06D8:  GOTO   731
....................     { 
....................         recordMorseCode(); 
....................     } 
*
0730:  GOTO   7EC
....................  
....................     else if (input(SW_Pin[1]) == 0) // append character to string and lcd 
0731:  BSF    03.5
0732:  BSF    06.1
0733:  BCF    03.5
0734:  BTFSC  06.1
0735:  GOTO   7CF
....................     { 
....................         delay_ms(100); // Debounce 
0736:  MOVLW  64
0737:  MOVWF  55
0738:  CALL   2AF
....................  
....................         completeMorseCode(); 
....................  
....................         while (input(SW_Pin[1]) == 0) 
*
07C9:  BSF    03.5
07CA:  BSF    06.1
07CB:  BCF    03.5
07CC:  BTFSS  06.1
07CD:  GOTO   7C9
....................             ; // Wait for button release 
....................     } 
07CE:  GOTO   7EC
....................  
....................     else if (input(SW_Pin[2]) == 0) // play morse code with buzzer 
07CF:  BSF    03.5
07D0:  BSF    06.2
07D1:  BCF    03.5
07D2:  BTFSC  06.2
07D3:  GOTO   7DE
....................     { 
....................         delay_ms(50); // Debounce 
07D4:  MOVLW  32
07D5:  MOVWF  55
07D6:  CALL   2AF
....................  
....................         playMorseCodeWithBuzzer(); 
07D7:  CALL   54C
....................  
....................         while (input(SW_Pin[2]) == 0) 
07D8:  BSF    03.5
07D9:  BSF    06.2
07DA:  BCF    03.5
07DB:  BTFSS  06.2
07DC:  GOTO   7D8
....................             ; // Wait for button release 
....................     } 
07DD:  GOTO   7EC
....................  
....................     else if (input(SW_Pin[3]) == 0) // play morse code with LED 
07DE:  BSF    03.5
07DF:  BSF    06.3
07E0:  BCF    03.5
07E1:  BTFSC  06.3
07E2:  GOTO   7EC
....................     { 
....................         delay_ms(50); // Debounce 
07E3:  MOVLW  32
07E4:  MOVWF  55
07E5:  CALL   2AF
....................  
....................         playMorseCodeWithLED(); 
07E6:  CALL   5DE
....................  
....................         while (input(SW_Pin[3]) == 0) 
07E7:  BSF    03.5
07E8:  BSF    06.3
07E9:  BCF    03.5
07EA:  BTFSS  06.3
07EB:  GOTO   7E7
....................             ; // Wait for button release 
....................     } 
07EC:  RETURN
.................... } 
....................  
.................... void switchMode() 
.................... { 
....................     clearAll(); 
*
0836:  BCF    0A.3
0837:  CALL   4F0
0838:  BSF    0A.3
....................  
....................     clear_lcd_i2c(); 
0839:  BCF    0A.3
083A:  CALL   2C4
083B:  BSF    0A.3
....................  
....................     tempMode = !tempMode; 
083C:  MOVLW  01
083D:  XORWF  48,F
....................  
....................     if (tempMode == BUTTON_MODE) 
083E:  BTFSC  48.0
083F:  GOTO   056
....................     { 
....................         set_lcd_i2c_cursor_position(1, 0); 
0840:  MOVLW  01
0841:  MOVWF  54
0842:  CLRF   55
0843:  BCF    0A.3
0844:  CALL   2CB
0845:  BSF    0A.3
....................         printf(write_lcd_i2c, "INPUT: BUTTON"); 
0846:  MOVLW  73
0847:  BSF    03.6
0848:  MOVWF  0D
0849:  MOVLW  01
084A:  MOVWF  0F
084B:  BCF    0A.3
084C:  BCF    03.6
084D:  CALL   491
084E:  BSF    0A.3
....................  
....................         inputMode = handleButtonMode; 
084F:  MOVLW  06
0850:  MOVWF  7A
0851:  MOVLW  D0
0852:  MOVWF  4B
0853:  MOVF   7A,W
0854:  MOVWF  4C
....................     } 
0855:  GOTO   06B
....................     else 
....................     { 
....................         set_lcd_i2c_cursor_position(1, 0); 
0856:  MOVLW  01
0857:  MOVWF  54
0858:  CLRF   55
0859:  BCF    0A.3
085A:  CALL   2CB
085B:  BSF    0A.3
....................         printf(write_lcd_i2c, "INPUT: UART"); 
085C:  MOVLW  7A
085D:  BSF    03.6
085E:  MOVWF  0D
085F:  MOVLW  01
0860:  MOVWF  0F
0861:  BCF    0A.3
0862:  BCF    03.6
0863:  CALL   491
0864:  BSF    0A.3
....................  
....................         inputMode = handleUartMode; 
0865:  MOVLW  06
0866:  MOVWF  7A
0867:  MOVLW  86
0868:  MOVWF  4B
0869:  MOVF   7A,W
086A:  MOVWF  4C
....................     } 
....................  
....................     delay_ms(1500); 
086B:  MOVLW  06
086C:  MOVWF  4F
086D:  MOVLW  FA
086E:  MOVWF  55
086F:  BCF    0A.3
0870:  CALL   2AF
0871:  BSF    0A.3
0872:  DECFSZ 4F,F
0873:  GOTO   06D
....................     clear_lcd_i2c(); 
0874:  BCF    0A.3
0875:  CALL   2C4
0876:  BSF    0A.3
.................... } 
....................  
.................... void readModeSelection() 
.................... { 
....................     if (input(SW_Pin[4]) == 0) // clear all 
*
0800:  BSF    03.5
0801:  BSF    06.4
0802:  BCF    03.5
0803:  BTFSC  06.4
0804:  GOTO   07B
....................     { 
....................         startTimer(); 
0805:  BCF    0A.3
0806:  CALL   6B5
0807:  BSF    0A.3
....................  
....................         delay_ms(50); // Debounce 
0808:  MOVLW  32
0809:  MOVWF  55
080A:  BCF    0A.3
080B:  CALL   2AF
080C:  BSF    0A.3
....................  
....................         while (input(SW_Pin[4]) == 0 && getTimerValue() < 1000) 
080D:  BSF    03.5
080E:  BSF    06.4
080F:  BCF    03.5
0810:  BTFSC  06.4
0811:  GOTO   024
*
0816:  MOVF   79,W
0817:  MOVWF  51
0818:  MOVF   78,W
0819:  MOVWF  50
081A:  MOVF   51,W
081B:  SUBLW  03
081C:  BTFSS  03.0
081D:  GOTO   024
081E:  BTFSS  03.2
081F:  GOTO   00D
0820:  MOVF   50,W
0821:  SUBLW  E7
0822:  BTFSC  03.0
0823:  GOTO   00D
....................             ; // Wait for button release 
....................  
....................         unsigned int16 duration = stopAndReadTimer(); 
0824:  BCF    0A.3
0825:  CALL   6C4
0826:  BSF    0A.3
0827:  MOVF   79,W
0828:  MOVWF  4E
0829:  MOVF   78,W
082A:  MOVWF  4D
....................  
....................         if (duration >= 1000) 
082B:  MOVF   4E,W
082C:  SUBLW  02
082D:  BTFSC  03.0
082E:  GOTO   078
082F:  XORLW  FF
0830:  BTFSS  03.2
0831:  GOTO   036
0832:  MOVF   4D,W
0833:  SUBLW  E7
0834:  BTFSC  03.0
0835:  GOTO   078
....................         { 
....................             switchMode(); 
....................         } 
*
0877:  GOTO   07B
....................         else 
....................         { 
....................             clearAll(); 
0878:  BCF    0A.3
0879:  CALL   4F0
087A:  BSF    0A.3
....................         } 
....................     } 
087B:  BSF    0A.3
087C:  BCF    0A.4
087D:  GOTO   102 (RETURN)
.................... } 
....................  
.................... void main() 
087E:  MOVF   03,W
087F:  ANDLW  1F
0880:  MOVWF  03
0881:  BSF    03.5
0882:  BSF    03.6
0883:  BCF    07.3
0884:  MOVLW  4D
0885:  BCF    03.6
0886:  MOVWF  19
0887:  MOVLW  A6
0888:  MOVWF  18
0889:  MOVLW  90
088A:  BCF    03.5
088B:  MOVWF  18
088C:  MOVLW  FF
088D:  MOVWF  2B
088E:  MOVLW  08
088F:  MOVWF  2C
0890:  MOVLW  01
0891:  MOVWF  2D
0892:  CLRF   2F
0893:  CLRF   2E
0894:  CLRF   36
0895:  CLRF   47
0896:  BCF    48.0
0897:  BSF    03.5
0898:  BSF    03.6
0899:  MOVF   09,W
089A:  ANDLW  C0
089B:  MOVWF  09
089C:  BCF    03.6
089D:  BCF    1F.4
089E:  BCF    1F.5
089F:  MOVLW  00
08A0:  BSF    03.6
08A1:  MOVWF  08
08A2:  BCF    03.5
08A3:  CLRF   07
08A4:  CLRF   08
08A5:  CLRF   09
08A6:  BCF    03.7
.................... { 
....................     initialize_lcd_i2c(); // Initialize the LCD 
*
08AA:  BCF    0A.3
08AB:  GOTO   1E1
08AC:  BSF    0A.3
....................  
....................     set_tris_d(0x00); // Set LED and buzzer pins as output 
08AD:  MOVLW  00
08AE:  BSF    03.5
08AF:  MOVWF  08
....................     set_tris_b(0x1F); // Set SW pins as input 
08B0:  MOVLW  1F
08B1:  MOVWF  06
....................     output_d(0x02);   // Turn off LED and Buzzer 
08B2:  CLRF   08
08B3:  MOVLW  02
08B4:  BCF    03.5
08B5:  MOVWF  08
....................  
....................     memset(morseCodeBufferString, 0, sizeof(morseCodeBufferString)); 
08B6:  MOVLW  30
08B7:  MOVWF  04
08B8:  BCF    03.7
08B9:  CLRF   77
08BA:  MOVLW  06
08BB:  MOVWF  78
08BC:  BCF    0A.3
08BD:  CALL   251
08BE:  BSF    0A.3
....................     memset(morseCodeString, 0, sizeof(morseCodeString)); 
08BF:  MOVLW  37
08C0:  MOVWF  04
08C1:  BCF    03.7
08C2:  CLRF   77
08C3:  MOVLW  10
08C4:  MOVWF  78
08C5:  BCF    0A.3
08C6:  CALL   251
08C7:  BSF    0A.3
....................     clear_lcd_i2c(); 
08C8:  BCF    0A.3
08C9:  CALL   2C4
08CA:  BSF    0A.3
....................  
....................     set_lcd_i2c_cursor_position(1, 0); 
08CB:  MOVLW  01
08CC:  MOVWF  54
08CD:  CLRF   55
08CE:  BCF    0A.3
08CF:  CALL   2CB
08D0:  BSF    0A.3
....................     printf(write_lcd_i2c, "1. LE TRONG AN"); 
08D1:  MOVLW  80
08D2:  BSF    03.6
08D3:  MOVWF  0D
08D4:  MOVLW  01
08D5:  MOVWF  0F
08D6:  BCF    0A.3
08D7:  BCF    03.6
08D8:  CALL   491
08D9:  BSF    0A.3
....................     set_lcd_i2c_cursor_position(2, 0); 
08DA:  MOVLW  02
08DB:  MOVWF  54
08DC:  CLRF   55
08DD:  BCF    0A.3
08DE:  CALL   2CB
08DF:  BSF    0A.3
....................     printf(write_lcd_i2c, "2. N.H VIET ANH"); 
08E0:  MOVLW  88
08E1:  BSF    03.6
08E2:  MOVWF  0D
08E3:  MOVLW  01
08E4:  MOVWF  0F
08E5:  BCF    0A.3
08E6:  BCF    03.6
08E7:  CALL   491
08E8:  BSF    0A.3
....................  
....................     delay_ms(1500); 
08E9:  MOVLW  06
08EA:  MOVWF  4D
08EB:  MOVLW  FA
08EC:  MOVWF  55
08ED:  BCF    0A.3
08EE:  CALL   2AF
08EF:  BSF    0A.3
08F0:  DECFSZ 4D,F
08F1:  GOTO   0EB
....................     clear_lcd_i2c(); 
08F2:  BCF    0A.3
08F3:  CALL   2C4
08F4:  BSF    0A.3
....................  
....................     inputMode = handleButtonMode; 
08F5:  MOVLW  06
08F6:  MOVWF  7A
08F7:  MOVLW  D0
08F8:  MOVWF  4B
08F9:  MOVF   7A,W
08FA:  MOVWF  4C
....................  
....................     while (TRUE) 
....................     { 
....................         (*inputMode)(); 
08FB:  MOVLW  4B
08FC:  MOVWF  04
08FD:  BCF    03.7
08FE:  BCF    0A.3
08FF:  CALL   190
0900:  BSF    0A.3
....................  
....................         readModeSelection(); 
0901:  GOTO   000
0902:  GOTO   0FB
....................     } 
.................... } 
0903:  SLEEP

Configuration Fuses:
   Word  1: 2CE2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
