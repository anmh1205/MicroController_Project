CCS PCM C Compiler, Version 5.025, 26966               07-Jul-24 03:39

               Filename:   E:\1. Phenikaa University\AML\1. Code\VDK (PIC16)\0. BTL\1. Code\V1.2\main.lst

               ROM used:   3169 words (39%)
                           Largest free fragment is 2048
               RAM used:   50 (14%) at main() level
                           86 (23%) worst case
               Stack used: 9 locations (4 in main + 5 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.0
0030:  GOTO   033
0031:  BTFSC  0C.0
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   4C2
0057:  BCF    0A.3
0058:  BCF    0A.4
0059:  GOTO   15D
.................... #include <main.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
005A:  BCF    0A.0
005B:  BCF    0A.1
005C:  BCF    0A.2
005D:  ADDLW  61
005E:  BTFSC  03.0
005F:  INCF   0A,F
0060:  MOVWF  02
0061:  RETLW  2E
0062:  RETLW  2D
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  00
0066:  RETLW  00
0067:  RETLW  41
0068:  RETLW  2D
0069:  RETLW  2E
006A:  RETLW  2E
006B:  RETLW  2E
006C:  RETLW  00
006D:  RETLW  00
006E:  RETLW  42
006F:  RETLW  2D
0070:  RETLW  2E
0071:  RETLW  2D
0072:  RETLW  2E
0073:  RETLW  00
0074:  RETLW  00
0075:  RETLW  43
0076:  RETLW  2D
0077:  RETLW  2E
0078:  RETLW  2E
0079:  RETLW  00
007A:  RETLW  00
007B:  RETLW  00
007C:  RETLW  44
007D:  RETLW  2E
007E:  RETLW  00
007F:  RETLW  00
0080:  RETLW  00
0081:  RETLW  00
0082:  RETLW  00
0083:  RETLW  45
0084:  RETLW  2E
0085:  RETLW  2E
0086:  RETLW  2D
0087:  RETLW  2E
0088:  RETLW  00
0089:  RETLW  00
008A:  RETLW  46
008B:  RETLW  2D
008C:  RETLW  2D
008D:  RETLW  2E
008E:  RETLW  00
008F:  RETLW  00
0090:  RETLW  00
0091:  RETLW  47
0092:  RETLW  2E
0093:  RETLW  2E
0094:  RETLW  2E
0095:  RETLW  2E
0096:  RETLW  00
0097:  RETLW  00
0098:  RETLW  48
0099:  RETLW  2E
009A:  RETLW  2E
009B:  RETLW  00
009C:  RETLW  00
009D:  RETLW  00
009E:  RETLW  00
009F:  RETLW  49
00A0:  RETLW  2E
00A1:  RETLW  2D
00A2:  RETLW  2D
00A3:  RETLW  2D
00A4:  RETLW  00
00A5:  RETLW  00
00A6:  RETLW  4A
00A7:  RETLW  2D
00A8:  RETLW  2E
00A9:  RETLW  2D
00AA:  RETLW  00
00AB:  RETLW  00
00AC:  RETLW  00
00AD:  RETLW  4B
00AE:  RETLW  2E
00AF:  RETLW  2D
00B0:  RETLW  2E
00B1:  RETLW  2E
00B2:  RETLW  00
00B3:  RETLW  00
00B4:  RETLW  4C
00B5:  RETLW  2D
00B6:  RETLW  2D
00B7:  RETLW  00
00B8:  RETLW  00
00B9:  RETLW  00
00BA:  RETLW  00
00BB:  RETLW  4D
00BC:  RETLW  2D
00BD:  RETLW  2E
00BE:  RETLW  00
00BF:  RETLW  00
00C0:  RETLW  00
00C1:  RETLW  00
00C2:  RETLW  4E
00C3:  RETLW  2D
00C4:  RETLW  2D
00C5:  RETLW  2D
00C6:  RETLW  00
00C7:  RETLW  00
00C8:  RETLW  00
00C9:  RETLW  4F
00CA:  RETLW  2E
00CB:  RETLW  2D
00CC:  RETLW  2D
00CD:  RETLW  2E
00CE:  RETLW  00
00CF:  RETLW  00
00D0:  RETLW  50
00D1:  RETLW  2D
00D2:  RETLW  2D
00D3:  RETLW  2E
00D4:  RETLW  2D
00D5:  RETLW  00
00D6:  RETLW  00
00D7:  RETLW  51
00D8:  RETLW  2E
00D9:  RETLW  2D
00DA:  RETLW  2E
00DB:  RETLW  00
00DC:  RETLW  00
00DD:  RETLW  00
00DE:  RETLW  52
00DF:  RETLW  2E
00E0:  RETLW  2E
00E1:  RETLW  2E
00E2:  RETLW  00
00E3:  RETLW  00
00E4:  RETLW  00
00E5:  RETLW  53
00E6:  RETLW  2D
00E7:  RETLW  00
00E8:  RETLW  00
00E9:  RETLW  00
00EA:  RETLW  00
00EB:  RETLW  00
00EC:  RETLW  54
00ED:  RETLW  2E
00EE:  RETLW  2E
00EF:  RETLW  2D
00F0:  RETLW  00
00F1:  RETLW  00
00F2:  RETLW  00
00F3:  RETLW  55
00F4:  RETLW  2E
00F5:  RETLW  2E
00F6:  RETLW  2E
00F7:  RETLW  2D
00F8:  RETLW  00
00F9:  RETLW  00
00FA:  RETLW  56
00FB:  RETLW  2E
00FC:  RETLW  2D
00FD:  RETLW  2D
00FE:  RETLW  00
00FF:  RETLW  00
0100:  RETLW  00
0101:  RETLW  57
0102:  RETLW  2D
0103:  RETLW  2E
0104:  RETLW  2E
0105:  RETLW  2D
0106:  RETLW  00
0107:  RETLW  00
0108:  RETLW  58
0109:  RETLW  2D
010A:  RETLW  2E
010B:  RETLW  2D
010C:  RETLW  2D
010D:  RETLW  00
010E:  RETLW  00
010F:  RETLW  59
0110:  RETLW  2D
0111:  RETLW  2D
0112:  RETLW  2E
0113:  RETLW  2E
0114:  RETLW  00
0115:  RETLW  00
0116:  RETLW  5A
0117:  RETLW  2D
0118:  RETLW  2D
0119:  RETLW  2D
011A:  RETLW  2D
011B:  RETLW  2D
011C:  RETLW  00
011D:  RETLW  30
011E:  RETLW  2E
011F:  RETLW  2D
0120:  RETLW  2D
0121:  RETLW  2D
0122:  RETLW  2D
0123:  RETLW  00
0124:  RETLW  31
0125:  RETLW  2E
0126:  RETLW  2E
0127:  RETLW  2D
0128:  RETLW  2D
0129:  RETLW  2D
012A:  RETLW  00
012B:  RETLW  32
012C:  RETLW  2E
012D:  RETLW  2E
012E:  RETLW  2E
012F:  RETLW  2D
0130:  RETLW  2D
0131:  RETLW  00
0132:  RETLW  33
0133:  RETLW  2E
0134:  RETLW  2E
0135:  RETLW  2E
0136:  RETLW  2E
0137:  RETLW  2D
0138:  RETLW  00
0139:  RETLW  34
013A:  RETLW  2E
013B:  RETLW  2E
013C:  RETLW  2E
013D:  RETLW  2E
013E:  RETLW  2E
013F:  RETLW  00
0140:  RETLW  35
0141:  RETLW  2D
0142:  RETLW  2E
0143:  RETLW  2E
0144:  RETLW  2E
0145:  RETLW  2E
0146:  RETLW  00
0147:  RETLW  36
0148:  RETLW  2D
0149:  RETLW  2D
014A:  RETLW  2E
014B:  RETLW  2E
014C:  RETLW  2E
014D:  RETLW  00
014E:  RETLW  37
014F:  RETLW  2D
0150:  RETLW  2D
0151:  RETLW  2D
0152:  RETLW  2E
0153:  RETLW  2E
0154:  RETLW  00
0155:  RETLW  38
0156:  RETLW  2D
0157:  RETLW  2D
0158:  RETLW  2D
0159:  RETLW  2D
015A:  RETLW  2E
015B:  RETLW  00
015C:  RETLW  39
*
016A:  DATA 20,10
016B:  DATA 20,10
016C:  DATA 20,10
016D:  DATA 20,10
016E:  DATA 20,10
016F:  DATA 20,10
0170:  DATA 20,10
0171:  DATA 20,10
0172:  DATA 00,00
0173:  DATA 20,10
0174:  DATA 20,10
0175:  DATA 20,10
0176:  DATA 20,10
0177:  DATA 20,10
0178:  DATA 20,10
0179:  DATA 20,10
017A:  DATA 20,10
017B:  DATA 00,00
*
0237:  MOVF   78,W
0238:  BTFSC  03.2
0239:  GOTO   23F
023A:  MOVF   77,W
023B:  MOVWF  00
023C:  INCF   04,F
023D:  DECFSZ 78,F
023E:  GOTO   23A
023F:  RETURN
0240:  CLRF   77
0241:  CLRF   78
0242:  MOVF   66,W
0243:  BCF    03.0
0244:  BTFSC  67.0
0245:  ADDWF  77,F
0246:  RRF    77,F
0247:  RRF    78,F
0248:  BTFSC  67.1
0249:  ADDWF  77,F
024A:  RRF    77,F
024B:  RRF    78,F
024C:  BTFSC  67.2
024D:  ADDWF  77,F
024E:  RRF    77,F
024F:  RRF    78,F
0250:  BTFSC  67.3
0251:  ADDWF  77,F
0252:  RRF    77,F
0253:  RRF    78,F
0254:  BTFSC  67.4
0255:  ADDWF  77,F
0256:  RRF    77,F
0257:  RRF    78,F
0258:  BTFSC  67.5
0259:  ADDWF  77,F
025A:  RRF    77,F
025B:  RRF    78,F
025C:  BTFSC  67.6
025D:  ADDWF  77,F
025E:  RRF    77,F
025F:  RRF    78,F
0260:  BTFSC  67.7
0261:  ADDWF  77,F
0262:  RRF    77,F
0263:  RRF    78,F
0264:  RETURN
*
046C:  MOVF   0B,W
046D:  MOVWF  66
046E:  BCF    0B.7
046F:  BSF    03.5
0470:  BSF    03.6
0471:  BSF    0C.7
0472:  BSF    0C.0
0473:  NOP
0474:  NOP
0475:  BCF    03.5
0476:  BCF    03.6
0477:  BTFSC  66.7
0478:  BSF    0B.7
0479:  BSF    03.6
047A:  MOVF   0C,W
047B:  ANDLW  7F
047C:  BTFSC  03.2
047D:  GOTO   4C0
047E:  BCF    03.6
047F:  MOVWF  66
0480:  BSF    03.6
0481:  MOVF   0D,W
0482:  BCF    03.6
0483:  MOVWF  67
0484:  BSF    03.6
0485:  MOVF   0F,W
0486:  BCF    03.6
0487:  MOVWF  68
0488:  MOVF   66,W
0489:  MOVWF  69
048A:  CALL   27D
048B:  MOVF   67,W
048C:  BSF    03.6
048D:  MOVWF  0D
048E:  BCF    03.6
048F:  MOVF   68,W
0490:  BSF    03.6
0491:  MOVWF  0F
0492:  BCF    03.6
0493:  MOVF   0B,W
0494:  MOVWF  69
0495:  BCF    0B.7
0496:  BSF    03.5
0497:  BSF    03.6
0498:  BSF    0C.7
0499:  BSF    0C.0
049A:  NOP
049B:  NOP
049C:  BCF    03.5
049D:  BCF    03.6
049E:  BTFSC  69.7
049F:  BSF    0B.7
04A0:  BSF    03.6
04A1:  RLF    0C,W
04A2:  RLF    0E,W
04A3:  ANDLW  7F
04A4:  BTFSC  03.2
04A5:  GOTO   4C0
04A6:  BCF    03.6
04A7:  MOVWF  66
04A8:  BSF    03.6
04A9:  MOVF   0D,W
04AA:  BCF    03.6
04AB:  MOVWF  67
04AC:  BSF    03.6
04AD:  MOVF   0F,W
04AE:  BCF    03.6
04AF:  MOVWF  68
04B0:  MOVF   66,W
04B1:  MOVWF  69
04B2:  CALL   27D
04B3:  MOVF   67,W
04B4:  BSF    03.6
04B5:  MOVWF  0D
04B6:  BCF    03.6
04B7:  MOVF   68,W
04B8:  BSF    03.6
04B9:  MOVWF  0F
04BA:  INCF   0D,F
04BB:  BTFSC  03.2
04BC:  INCF   0F,F
04BD:  BCF    03.6
04BE:  GOTO   46C
04BF:  BSF    03.6
04C0:  BCF    03.6
04C1:  RETURN
*
051E:  BCF    03.6
051F:  MOVF   0B,W
0520:  MOVWF  67
0521:  BCF    0B.7
0522:  BSF    03.5
0523:  BSF    03.6
0524:  BSF    0C.7
0525:  BSF    0C.0
0526:  NOP
0527:  NOP
0528:  BCF    03.5
0529:  BCF    03.6
052A:  BTFSC  67.7
052B:  BSF    0B.7
052C:  BSF    03.6
052D:  MOVF   0C,F
052E:  BTFSC  03.2
052F:  GOTO   547
0530:  MOVF   0D,W
0531:  BCF    03.6
0532:  MOVWF  67
0533:  BSF    03.6
0534:  MOVF   0F,W
0535:  BCF    03.6
0536:  MOVWF  68
0537:  BSF    03.6
0538:  MOVF   0C,W
0539:  BCF    03.6
053A:  MOVWF  69
053B:  CALL   27D
053C:  MOVF   67,W
053D:  BSF    03.6
053E:  MOVWF  0D
053F:  BCF    03.6
0540:  MOVF   68,W
0541:  BSF    03.6
0542:  MOVWF  0F
0543:  INCF   0D,F
0544:  BTFSC  03.2
0545:  INCF   0F,F
0546:  GOTO   51E
*
05D8:  BCF    03.6
05D9:  MOVF   0B,W
05DA:  MOVWF  67
05DB:  BCF    0B.7
05DC:  BSF    03.5
05DD:  BSF    03.6
05DE:  BSF    0C.7
05DF:  BSF    0C.0
05E0:  NOP
05E1:  NOP
05E2:  BCF    03.5
05E3:  BCF    03.6
05E4:  BTFSC  67.7
05E5:  BSF    0B.7
05E6:  BSF    03.6
05E7:  MOVF   0C,F
05E8:  BTFSC  03.2
05E9:  GOTO   601
05EA:  MOVF   0D,W
05EB:  BCF    03.6
05EC:  MOVWF  67
05ED:  BSF    03.6
05EE:  MOVF   0F,W
05EF:  BCF    03.6
05F0:  MOVWF  68
05F1:  BSF    03.6
05F2:  MOVF   0C,W
05F3:  BCF    03.6
05F4:  MOVWF  69
05F5:  CALL   27D
05F6:  MOVF   67,W
05F7:  BSF    03.6
05F8:  MOVWF  0D
05F9:  BCF    03.6
05FA:  MOVF   68,W
05FB:  BSF    03.6
05FC:  MOVWF  0F
05FD:  INCF   0D,F
05FE:  BTFSC  03.2
05FF:  INCF   0F,F
0600:  GOTO   5D8
*
066D:  DATA 49,27
066E:  DATA D0,2A
066F:  DATA 54,1D
0670:  DATA 20,21
0671:  DATA 55,2A
0672:  DATA D4,27
0673:  DATA 4E,00
0674:  DATA 49,27
0675:  DATA D0,2A
0676:  DATA 54,1D
0677:  DATA A0,2A
0678:  DATA 41,29
0679:  DATA 54,00
067A:  DATA 31,17
067B:  DATA 20,26
067C:  DATA 45,10
067D:  DATA 54,29
067E:  DATA 4F,27
067F:  DATA 47,10
0680:  DATA 41,27
0681:  DATA 00,01
0682:  DATA 32,17
0683:  DATA 20,27
0684:  DATA 2E,24
0685:  DATA 20,2B
0686:  DATA C9,22
0687:  DATA 54,10
0688:  DATA 41,27
0689:  DATA 48,00
*
0927:  MOVF   00,F
0928:  BTFSC  03.2
0929:  GOTO   144
092A:  CLRF   51
092B:  MOVF   04,W
092C:  MOVWF  50
092D:  BCF    51.0
092E:  BTFSC  03.7
092F:  BSF    51.0
0930:  CLRF   2B
0931:  BTFSC  0B.7
0932:  BSF    2B.7
0933:  BCF    0B.7
0934:  MOVF   00,W
0935:  MOVWF  69
0936:  BCF    0A.3
0937:  CALL   27D
0938:  BSF    0A.3
0939:  BTFSC  2B.7
093A:  BSF    0B.7
093B:  MOVF   50,W
093C:  MOVWF  04
093D:  BCF    03.7
093E:  BTFSC  51.0
093F:  BSF    03.7
0940:  INCF   04,F
0941:  BTFSC  03.2
0942:  INCF   05,F
0943:  GOTO   127
*
0A1C:  MOVF   00,F
0A1D:  BTFSC  03.2
0A1E:  GOTO   239
0A1F:  CLRF   51
0A20:  MOVF   04,W
0A21:  MOVWF  50
0A22:  BCF    51.0
0A23:  BTFSC  03.7
0A24:  BSF    51.0
0A25:  CLRF   2B
0A26:  BTFSC  0B.7
0A27:  BSF    2B.7
0A28:  BCF    0B.7
0A29:  MOVF   00,W
0A2A:  MOVWF  69
0A2B:  BCF    0A.3
0A2C:  CALL   27D
0A2D:  BSF    0A.3
0A2E:  BTFSC  2B.7
0A2F:  BSF    0B.7
0A30:  MOVF   50,W
0A31:  MOVWF  04
0A32:  BCF    03.7
0A33:  BTFSC  51.0
0A34:  BSF    03.7
0A35:  INCF   04,F
0A36:  BTFSC  03.2
0A37:  INCF   05,F
0A38:  GOTO   21C
*
0A98:  BCF    03.6
0A99:  MOVF   0B,W
0A9A:  MOVWF  67
0A9B:  BCF    0B.7
0A9C:  BSF    03.5
0A9D:  BSF    03.6
0A9E:  BSF    0C.7
0A9F:  BSF    0C.0
0AA0:  NOP
0AA1:  NOP
0AA2:  BCF    03.5
0AA3:  BCF    03.6
0AA4:  BTFSC  67.7
0AA5:  BSF    0B.7
0AA6:  BSF    03.6
0AA7:  MOVF   0C,F
0AA8:  BTFSC  03.2
0AA9:  GOTO   2C3
0AAA:  MOVF   0D,W
0AAB:  BCF    03.6
0AAC:  MOVWF  67
0AAD:  BSF    03.6
0AAE:  MOVF   0F,W
0AAF:  BCF    03.6
0AB0:  MOVWF  68
0AB1:  BSF    03.6
0AB2:  MOVF   0C,W
0AB3:  BCF    03.6
0AB4:  MOVWF  69
0AB5:  BCF    0A.3
0AB6:  CALL   27D
0AB7:  BSF    0A.3
0AB8:  MOVF   67,W
0AB9:  BSF    03.6
0ABA:  MOVWF  0D
0ABB:  BCF    03.6
0ABC:  MOVF   68,W
0ABD:  BSF    03.6
0ABE:  MOVWF  0F
0ABF:  INCF   0D,F
0AC0:  BTFSC  03.2
0AC1:  INCF   0F,F
0AC2:  GOTO   298
*
0B8B:  BCF    03.6
0B8C:  MOVF   0B,W
0B8D:  MOVWF  67
0B8E:  BCF    0B.7
0B8F:  BSF    03.5
0B90:  BSF    03.6
0B91:  BSF    0C.7
0B92:  BSF    0C.0
0B93:  NOP
0B94:  NOP
0B95:  BCF    03.5
0B96:  BCF    03.6
0B97:  BTFSC  67.7
0B98:  BSF    0B.7
0B99:  BSF    03.6
0B9A:  MOVF   0C,F
0B9B:  BTFSC  03.2
0B9C:  GOTO   3B6
0B9D:  MOVF   0D,W
0B9E:  BCF    03.6
0B9F:  MOVWF  67
0BA0:  BSF    03.6
0BA1:  MOVF   0F,W
0BA2:  BCF    03.6
0BA3:  MOVWF  68
0BA4:  BSF    03.6
0BA5:  MOVF   0C,W
0BA6:  BCF    03.6
0BA7:  MOVWF  69
0BA8:  BCF    0A.3
0BA9:  CALL   27D
0BAA:  BSF    0A.3
0BAB:  MOVF   67,W
0BAC:  BSF    03.6
0BAD:  MOVWF  0D
0BAE:  BCF    03.6
0BAF:  MOVF   68,W
0BB0:  BSF    03.6
0BB1:  MOVWF  0F
0BB2:  INCF   0D,F
0BB3:  BTFSC  03.2
0BB4:  INCF   0F,F
0BB5:  GOTO   38B
....................  
.................... #list 
....................  
.................... #device ADC = 16 
....................  
.................... #FUSES NOWDT      // No Watch Dog Timer 
.................... #FUSES PUT        // Power Up Timer 
.................... #FUSES NOBROWNOUT // No brownout reset 
.................... #FUSES NOLVP      // No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal = 12000000) 
*
021B:  MOVLW  67
021C:  MOVWF  04
021D:  BCF    03.7
021E:  MOVF   00,W
021F:  BTFSC  03.2
0220:  GOTO   22F
0221:  MOVLW  03
0222:  MOVWF  78
0223:  CLRF   77
0224:  DECFSZ 77,F
0225:  GOTO   224
0226:  DECFSZ 78,F
0227:  GOTO   223
0228:  MOVLW  E3
0229:  MOVWF  77
022A:  DECFSZ 77,F
022B:  GOTO   22A
022C:  NOP
022D:  DECFSZ 00,F
022E:  GOTO   221
022F:  RETURN
.................... #use rs232(baud = 4800, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PORT1) 
.................... #use i2c(Master, Fast = 400000, sda = PIN_C4, scl = PIN_C3, force_sw) 
*
017C:  MOVLW  08
017D:  MOVWF  78
017E:  NOP
017F:  BCF    07.3
0180:  BCF    2C.3
0181:  MOVF   2C,W
0182:  BSF    03.5
0183:  MOVWF  07
0184:  NOP
0185:  RLF    70,F
0186:  BCF    03.5
0187:  BCF    07.4
0188:  BTFSS  03.0
0189:  GOTO   190
018A:  BSF    2C.4
018B:  MOVF   2C,W
018C:  BSF    03.5
018D:  MOVWF  07
018E:  GOTO   194
018F:  BCF    03.5
0190:  BCF    2C.4
0191:  MOVF   2C,W
0192:  BSF    03.5
0193:  MOVWF  07
0194:  NOP
0195:  BCF    03.5
0196:  BSF    2C.3
0197:  MOVF   2C,W
0198:  BSF    03.5
0199:  MOVWF  07
019A:  BCF    03.5
019B:  BTFSS  07.3
019C:  GOTO   19B
019D:  DECFSZ 78,F
019E:  GOTO   17E
019F:  NOP
01A0:  BCF    07.3
01A1:  BCF    2C.3
01A2:  MOVF   2C,W
01A3:  BSF    03.5
01A4:  MOVWF  07
01A5:  NOP
01A6:  BCF    03.5
01A7:  BSF    2C.4
01A8:  MOVF   2C,W
01A9:  BSF    03.5
01AA:  MOVWF  07
01AB:  NOP
01AC:  NOP
01AD:  BCF    03.5
01AE:  BSF    2C.3
01AF:  MOVF   2C,W
01B0:  BSF    03.5
01B1:  MOVWF  07
01B2:  BCF    03.5
01B3:  BTFSS  07.3
01B4:  GOTO   1B3
01B5:  CLRF   78
01B6:  NOP
01B7:  BTFSC  07.4
01B8:  BSF    78.0
01B9:  BCF    07.3
01BA:  BCF    2C.3
01BB:  MOVF   2C,W
01BC:  BSF    03.5
01BD:  MOVWF  07
01BE:  BCF    03.5
01BF:  BCF    07.4
01C0:  BCF    2C.4
01C1:  MOVF   2C,W
01C2:  BSF    03.5
01C3:  MOVWF  07
01C4:  BCF    03.5
01C5:  RETURN
*
02DD:  MOVLW  08
02DE:  MOVWF  6F
02DF:  MOVF   77,W
02E0:  MOVWF  70
02E1:  BSF    2C.4
02E2:  MOVF   2C,W
02E3:  BSF    03.5
02E4:  MOVWF  07
02E5:  NOP
02E6:  BCF    03.5
02E7:  BSF    2C.3
02E8:  MOVF   2C,W
02E9:  BSF    03.5
02EA:  MOVWF  07
02EB:  BCF    03.5
02EC:  BTFSS  07.3
02ED:  GOTO   2EC
02EE:  BTFSC  07.4
02EF:  BSF    03.0
02F0:  BTFSS  07.4
02F1:  BCF    03.0
02F2:  RLF    78,F
02F3:  NOP
02F4:  BCF    2C.3
02F5:  MOVF   2C,W
02F6:  BSF    03.5
02F7:  MOVWF  07
02F8:  BCF    03.5
02F9:  BCF    07.3
02FA:  DECFSZ 6F,F
02FB:  GOTO   2E1
02FC:  BSF    2C.4
02FD:  MOVF   2C,W
02FE:  BSF    03.5
02FF:  MOVWF  07
0300:  NOP
0301:  BCF    03.5
0302:  BCF    07.4
0303:  MOVF   70,W
0304:  BTFSC  03.2
0305:  GOTO   30B
0306:  BCF    2C.4
0307:  MOVF   2C,W
0308:  BSF    03.5
0309:  MOVWF  07
030A:  BCF    03.5
030B:  NOP
030C:  BSF    2C.3
030D:  MOVF   2C,W
030E:  BSF    03.5
030F:  MOVWF  07
0310:  BCF    03.5
0311:  BTFSS  07.3
0312:  GOTO   311
0313:  NOP
0314:  BCF    07.3
0315:  BCF    2C.3
0316:  MOVF   2C,W
0317:  BSF    03.5
0318:  MOVWF  07
0319:  NOP
031A:  BCF    03.5
031B:  BCF    07.4
031C:  BCF    2C.4
031D:  MOVF   2C,W
031E:  BSF    03.5
031F:  MOVWF  07
*
0369:  MOVLW  08
036A:  MOVWF  6F
036B:  MOVF   77,W
036C:  MOVWF  70
036D:  BSF    2C.4
036E:  MOVF   2C,W
036F:  BSF    03.5
0370:  MOVWF  07
0371:  NOP
0372:  BCF    03.5
0373:  BSF    2C.3
0374:  MOVF   2C,W
0375:  BSF    03.5
0376:  MOVWF  07
0377:  BCF    03.5
0378:  BTFSS  07.3
0379:  GOTO   378
037A:  BTFSC  07.4
037B:  BSF    03.0
037C:  BTFSS  07.4
037D:  BCF    03.0
037E:  RLF    78,F
037F:  NOP
0380:  BCF    2C.3
0381:  MOVF   2C,W
0382:  BSF    03.5
0383:  MOVWF  07
0384:  BCF    03.5
0385:  BCF    07.3
0386:  DECFSZ 6F,F
0387:  GOTO   36D
0388:  BSF    2C.4
0389:  MOVF   2C,W
038A:  BSF    03.5
038B:  MOVWF  07
038C:  NOP
038D:  BCF    03.5
038E:  BCF    07.4
038F:  MOVF   70,W
0390:  BTFSC  03.2
0391:  GOTO   397
0392:  BCF    2C.4
0393:  MOVF   2C,W
0394:  BSF    03.5
0395:  MOVWF  07
0396:  BCF    03.5
0397:  NOP
0398:  BSF    2C.3
0399:  MOVF   2C,W
039A:  BSF    03.5
039B:  MOVWF  07
039C:  BCF    03.5
039D:  BTFSS  07.3
039E:  GOTO   39D
039F:  NOP
03A0:  BCF    07.3
03A1:  BCF    2C.3
03A2:  MOVF   2C,W
03A3:  BSF    03.5
03A4:  MOVWF  07
03A5:  NOP
03A6:  BCF    03.5
03A7:  BCF    07.4
03A8:  BCF    2C.4
03A9:  MOVF   2C,W
03AA:  BSF    03.5
03AB:  MOVWF  07
....................  
.................... #define PCF8574A       // Comment for modules using PCF8574 
.................... #define A2_A1_A0 0B111 // Address pin states (A2 A1 A0) of PCF8574A/PCF8574. 
.................... #define LCD16X2        // Comment this line to use 16x2 LCD 
....................  
.................... #include <global_variables.h> 
.................... #ifndef VAR_H 
.................... #define VAR_H 
....................  
.................... #include <lcd_i2c.c> 
.................... #define RIGHT 0x1C 
.................... #define LEFT 0x18 
....................  
.................... #define CURSOR_ON 2 
.................... #define CURSOR_OFF 0 
....................  
.................... #define BLINK_ON 1 
.................... #define BLINK_OFF 0 
....................  
.................... #define BL_ON 0x08 
.................... #define BL_OFF 0x00 
....................  
.................... #ifdef PCF8574A 
.................... #define pcf_address_write 0x70 | (A2_A1_A0 << 1) 
.................... #define pcf_address_read 0x71 | (A2_A1_A0 << 1) 
.................... #else // PCF8574 
.................... #define pcf_address_write 0x40 | (A2_A1_A0 << 1) 
.................... #define pcf_address_read 0x41 | (A2_A1_A0 << 1) 
.................... #endif 
....................  
.................... #ifdef LCD20X4 
.................... #define line1_start 0x00 
.................... #define line1_end 0x13 
....................  
.................... #define line2_start 0x40 
.................... #define line2_end 0x53 
....................  
.................... #define line3_start 0x14 
.................... #define line3_end 0x27 
....................  
.................... #define line4_start 0x54 
.................... #define line4_end 0x67 
....................  
.................... #define line1_start_command 0x80 
.................... #define line2_start_command 0xC0 
.................... #define line3_start_command 0x94 
.................... #define line4_start_command 0xD4 
.................... #else LCD16X2 
.................... #define line1_start 0x00 
.................... #define line1_end 0x27 
....................  
.................... #define line2_start 0x40 
.................... #define line2_end 0x67 
....................  
.................... #define line1_start_command 0x80 
.................... #define line2_start_command 0xC0 
.................... #endif 
....................  
.................... int backlight_lcd_i2c = 0x08, lcd_i2c_line = 1; 
....................  
.................... void initialize_lcd_i2c() 
.................... { 
....................     i2c_start();                  // Start communication 
*
068A:  BSF    2C.4
068B:  MOVF   2C,W
068C:  BSF    03.5
068D:  MOVWF  07
068E:  NOP
068F:  BCF    03.5
0690:  BSF    2C.3
0691:  MOVF   2C,W
0692:  BSF    03.5
0693:  MOVWF  07
0694:  NOP
0695:  BCF    03.5
0696:  BCF    07.4
0697:  BCF    2C.4
0698:  MOVF   2C,W
0699:  BSF    03.5
069A:  MOVWF  07
069B:  NOP
069C:  BCF    03.5
069D:  BCF    07.3
069E:  BCF    2C.3
069F:  MOVF   2C,W
06A0:  BSF    03.5
06A1:  MOVWF  07
06A2:  BCF    03.5
06A3:  CLRF   2B
06A4:  BTFSC  0B.7
06A5:  BSF    2B.7
06A6:  BCF    0B.7
....................     i2c_write(pcf_address_write); // Send PCF address + WRITE bit 
06A7:  MOVLW  7E
06A8:  MOVWF  70
06A9:  CALL   17C
06AA:  BTFSC  2B.7
06AB:  BSF    0B.7
06AC:  CLRF   2B
06AD:  BTFSC  0B.7
06AE:  BSF    2B.7
06AF:  BCF    0B.7
....................     i2c_write(0x2C);              // Configure LCD for 4 bits/BL ON/En 1 
06B0:  MOVLW  2C
06B1:  MOVWF  70
06B2:  CALL   17C
06B3:  BTFSC  2B.7
06B4:  BSF    0B.7
06B5:  CLRF   2B
06B6:  BTFSC  0B.7
06B7:  BSF    2B.7
06B8:  BCF    0B.7
....................     i2c_write(0x28);              // En 0 to execute instruction 
06B9:  MOVLW  28
06BA:  MOVWF  70
06BB:  CALL   17C
06BC:  BTFSC  2B.7
06BD:  BSF    0B.7
....................  
....................     delay_us(40);    // Verify the delay for bits to be sent 
06BE:  MOVLW  27
06BF:  MOVWF  77
06C0:  DECFSZ 77,F
06C1:  GOTO   6C0
06C2:  GOTO   6C3
06C3:  CLRF   2B
06C4:  BTFSC  0B.7
06C5:  BSF    2B.7
06C6:  BCF    0B.7
....................     i2c_write(0x2C); // Send first nibble of 
06C7:  MOVLW  2C
06C8:  MOVWF  70
06C9:  CALL   17C
06CA:  BTFSC  2B.7
06CB:  BSF    0B.7
06CC:  CLRF   2B
06CD:  BTFSC  0B.7
06CE:  BSF    2B.7
06CF:  BCF    0B.7
....................     i2c_write(0x28); // the "Function Set" instruction. 
06D0:  MOVLW  28
06D1:  MOVWF  70
06D2:  CALL   17C
06D3:  BTFSC  2B.7
06D4:  BSF    0B.7
06D5:  CLRF   2B
06D6:  BTFSC  0B.7
06D7:  BSF    2B.7
06D8:  BCF    0B.7
....................     i2c_write(0x8C); // Send second nibble of the instruction. 
06D9:  MOVLW  8C
06DA:  MOVWF  70
06DB:  CALL   17C
06DC:  BTFSC  2B.7
06DD:  BSF    0B.7
06DE:  CLRF   2B
06DF:  BTFSC  0B.7
06E0:  BSF    2B.7
06E1:  BCF    0B.7
....................     i2c_write(0x88); // 4 bits, 2 lines, font 5*8. 
06E2:  MOVLW  88
06E3:  MOVWF  70
06E4:  CALL   17C
06E5:  BTFSC  2B.7
06E6:  BSF    0B.7
....................  
....................     delay_us(40); 
06E7:  MOVLW  27
06E8:  MOVWF  77
06E9:  DECFSZ 77,F
06EA:  GOTO   6E9
06EB:  GOTO   6EC
06EC:  CLRF   2B
06ED:  BTFSC  0B.7
06EE:  BSF    2B.7
06EF:  BCF    0B.7
....................  
....................     i2c_write(0x0C); // Send first nibble of 
06F0:  MOVLW  0C
06F1:  MOVWF  70
06F2:  CALL   17C
06F3:  BTFSC  2B.7
06F4:  BSF    0B.7
06F5:  CLRF   2B
06F6:  BTFSC  0B.7
06F7:  BSF    2B.7
06F8:  BCF    0B.7
....................     i2c_write(0x08); // "Display ON/OFF control" instruction. 
06F9:  MOVLW  08
06FA:  MOVWF  70
06FB:  CALL   17C
06FC:  BTFSC  2B.7
06FD:  BSF    0B.7
06FE:  CLRF   2B
06FF:  BTFSC  0B.7
0700:  BSF    2B.7
0701:  BCF    0B.7
....................     i2c_write(0xCC); // Send second nibble of the instruction. 
0702:  MOVLW  CC
0703:  MOVWF  70
0704:  CALL   17C
0705:  BTFSC  2B.7
0706:  BSF    0B.7
0707:  CLRF   2B
0708:  BTFSC  0B.7
0709:  BSF    2B.7
070A:  BCF    0B.7
....................     i2c_write(0xC8); // Display on, cursor off, blink off. 
070B:  MOVLW  C8
070C:  MOVWF  70
070D:  CALL   17C
070E:  BTFSC  2B.7
070F:  BSF    0B.7
....................     delay_us(1); 
0710:  GOTO   711
0711:  NOP
0712:  CLRF   2B
0713:  BTFSC  0B.7
0714:  BSF    2B.7
0715:  BCF    0B.7
....................  
....................     i2c_write(0x0C); // Send first nibble of 
0716:  MOVLW  0C
0717:  MOVWF  70
0718:  CALL   17C
0719:  BTFSC  2B.7
071A:  BSF    0B.7
071B:  CLRF   2B
071C:  BTFSC  0B.7
071D:  BSF    2B.7
071E:  BCF    0B.7
....................     i2c_write(0x08); // "Entry Mode Set" instruction. 
071F:  MOVLW  08
0720:  MOVWF  70
0721:  CALL   17C
0722:  BTFSC  2B.7
0723:  BSF    0B.7
0724:  CLRF   2B
0725:  BTFSC  0B.7
0726:  BSF    2B.7
0727:  BCF    0B.7
....................     i2c_write(0x6C); // Send second nibble of the instruction. 
0728:  MOVLW  6C
0729:  MOVWF  70
072A:  CALL   17C
072B:  BTFSC  2B.7
072C:  BSF    0B.7
072D:  CLRF   2B
072E:  BTFSC  0B.7
072F:  BSF    2B.7
0730:  BCF    0B.7
....................     i2c_write(0x68); // Increment cursor with each write 
0731:  MOVLW  68
0732:  MOVWF  70
0733:  CALL   17C
0734:  BTFSC  2B.7
0735:  BSF    0B.7
....................                      // (position+=1), LCD scroll disabled; 
....................                      // if enabled, display scrolls with each character. 
....................     delay_us(40); 
0736:  MOVLW  27
0737:  MOVWF  77
0738:  DECFSZ 77,F
0739:  GOTO   738
073A:  GOTO   73B
....................  
....................     i2c_stop(); 
073B:  BCF    2C.4
073C:  MOVF   2C,W
073D:  BSF    03.5
073E:  MOVWF  07
073F:  NOP
0740:  BCF    03.5
0741:  BSF    2C.3
0742:  MOVF   2C,W
0743:  BSF    03.5
0744:  MOVWF  07
0745:  BCF    03.5
0746:  BTFSS  07.3
0747:  GOTO   746
0748:  NOP
0749:  GOTO   74A
074A:  NOP
074B:  BSF    2C.4
074C:  MOVF   2C,W
074D:  BSF    03.5
074E:  MOVWF  07
074F:  NOP
0750:  BCF    03.5
0751:  BSF    0A.3
0752:  BCF    0A.4
0753:  GOTO   030 (RETURN)
.................... } 
.................... void send_lcd_i2c_command(char character) 
.................... { 
....................     int ms_nibble_e, ls_nibble_e, ms_nibble, ls_nibble; 
....................  
....................     ms_nibble = character & 0xF0;   // Most significant nibble of the character. 
*
01C6:  MOVF   6B,W
01C7:  ANDLW  F0
01C8:  MOVWF  6E
....................     ls_nibble = character & 0x0F;   // Least significant nibble of the character. 
01C9:  MOVF   6B,W
01CA:  ANDLW  0F
01CB:  MOVWF  6F
....................     swap(ls_nibble);                // Swap as the most significant bits are used (D7: D4). 
01CC:  SWAPF  6F,F
....................     ms_nibble |= backlight_lcd_i2c; // Add BL to the most significant nibble 
01CD:  MOVF   2D,W
01CE:  IORWF  6E,F
....................     ls_nibble |= backlight_lcd_i2c; // Add BL to the least significant nibble 
01CF:  MOVF   2D,W
01D0:  IORWF  6F,F
....................  
....................     ms_nibble_e = ms_nibble | 0x04; // Most significant nibble En 1 
01D1:  MOVF   6E,W
01D2:  IORLW  04
01D3:  MOVWF  6C
....................     ls_nibble_e = ls_nibble | 0x04; // Least significant nibble En 1 
01D4:  MOVF   6F,W
01D5:  IORLW  04
01D6:  MOVWF  6D
....................  
....................     i2c_start(); 
01D7:  BSF    2C.4
01D8:  MOVF   2C,W
01D9:  BSF    03.5
01DA:  MOVWF  07
01DB:  NOP
01DC:  BCF    03.5
01DD:  BSF    2C.3
01DE:  MOVF   2C,W
01DF:  BSF    03.5
01E0:  MOVWF  07
01E1:  NOP
01E2:  BCF    03.5
01E3:  BCF    07.4
01E4:  BCF    2C.4
01E5:  MOVF   2C,W
01E6:  BSF    03.5
01E7:  MOVWF  07
01E8:  NOP
01E9:  BCF    03.5
01EA:  BCF    07.3
01EB:  BCF    2C.3
01EC:  MOVF   2C,W
01ED:  BSF    03.5
01EE:  MOVWF  07
....................     i2c_write(pcf_address_write); 
01EF:  MOVLW  7E
01F0:  MOVWF  70
01F1:  BCF    03.5
01F2:  CALL   17C
....................  
....................     i2c_write(ms_nibble_e); // Send 1st nibble with "E" set 
01F3:  MOVF   6C,W
01F4:  MOVWF  70
01F5:  CALL   17C
....................     i2c_write(ms_nibble);   // Send 1st nibble with "E" cleared 
01F6:  MOVF   6E,W
01F7:  MOVWF  70
01F8:  CALL   17C
....................  
....................     i2c_write(ls_nibble_e); // Send 2nd nibble with "E" set 
01F9:  MOVF   6D,W
01FA:  MOVWF  70
01FB:  CALL   17C
....................     i2c_write(ls_nibble);   // Send 2nd nibble with "E" cleared 
01FC:  MOVF   6F,W
01FD:  MOVWF  70
01FE:  CALL   17C
....................  
....................     i2c_stop(); 
01FF:  BCF    2C.4
0200:  MOVF   2C,W
0201:  BSF    03.5
0202:  MOVWF  07
0203:  NOP
0204:  BCF    03.5
0205:  BSF    2C.3
0206:  MOVF   2C,W
0207:  BSF    03.5
0208:  MOVWF  07
0209:  BCF    03.5
020A:  BTFSS  07.3
020B:  GOTO   20A
020C:  NOP
020D:  GOTO   20E
020E:  NOP
020F:  BSF    2C.4
0210:  MOVF   2C,W
0211:  BSF    03.5
0212:  MOVWF  07
0213:  NOP
....................     delay_us(44); 
0214:  MOVLW  2B
0215:  MOVWF  77
0216:  DECFSZ 77,F
0217:  GOTO   216
0218:  GOTO   219
0219:  BCF    03.5
021A:  RETURN
.................... } 
.................... void send_lcd_i2c_character(int character) 
.................... { 
....................     int ms_nibble_e, ls_nibble_e, ms_nibble, ls_nibble; 
....................  
....................     ms_nibble = character & 0xF0; // Most significant nibble of the character. 
*
03FA:  MOVF   6B,W
03FB:  ANDLW  F0
03FC:  MOVWF  6E
....................     ls_nibble = character & 0x0F; // Least significant nibble of the character. 
03FD:  MOVF   6B,W
03FE:  ANDLW  0F
03FF:  MOVWF  6F
....................     swap(ls_nibble);              // Swap as the most significant bits are used (D7: D4). 
0400:  SWAPF  6F,F
....................  
....................     ms_nibble |= backlight_lcd_i2c; // Add BL to the most significant nibble 
0401:  MOVF   2D,W
0402:  IORWF  6E,F
....................     ls_nibble |= backlight_lcd_i2c; // Add BL to the least significant nibble 
0403:  MOVF   2D,W
0404:  IORWF  6F,F
....................     ms_nibble++;                    // Set RS bit 
0405:  INCF   6E,F
....................     ls_nibble++;                    // Set RS bit 
0406:  INCF   6F,F
....................  
....................     ms_nibble_e = ms_nibble | 0x05; // Most significant nibble En and RS = 1 
0407:  MOVF   6E,W
0408:  IORLW  05
0409:  MOVWF  6C
....................     ls_nibble_e = ls_nibble | 0x05; // Least significant nibble En and RS = 1 
040A:  MOVF   6F,W
040B:  IORLW  05
040C:  MOVWF  6D
....................  
....................     i2c_start(); 
040D:  BSF    2C.4
040E:  MOVF   2C,W
040F:  BSF    03.5
0410:  MOVWF  07
0411:  NOP
0412:  BCF    03.5
0413:  BSF    2C.3
0414:  MOVF   2C,W
0415:  BSF    03.5
0416:  MOVWF  07
0417:  NOP
0418:  BCF    03.5
0419:  BCF    07.4
041A:  BCF    2C.4
041B:  MOVF   2C,W
041C:  BSF    03.5
041D:  MOVWF  07
041E:  NOP
041F:  BCF    03.5
0420:  BCF    07.3
0421:  BCF    2C.3
0422:  MOVF   2C,W
0423:  BSF    03.5
0424:  MOVWF  07
....................     i2c_write(pcf_address_write); 
0425:  MOVLW  7E
0426:  MOVWF  70
0427:  BCF    03.5
0428:  CALL   17C
....................  
....................     i2c_write(ms_nibble_e); // Send 1st nibble with RS and En 1 
0429:  MOVF   6C,W
042A:  MOVWF  70
042B:  CALL   17C
....................     i2c_write(ms_nibble);   // Send 1st nibble with RS 1 and E 0 
042C:  MOVF   6E,W
042D:  MOVWF  70
042E:  CALL   17C
....................  
....................     i2c_write(ls_nibble_e); // Send 2nd nibble with RS and E 1 
042F:  MOVF   6D,W
0430:  MOVWF  70
0431:  CALL   17C
....................     i2c_write(ls_nibble);   // Send 2nd nibble with RS 0 and E 0 
0432:  MOVF   6F,W
0433:  MOVWF  70
0434:  CALL   17C
....................  
....................     i2c_stop(); 
0435:  BCF    2C.4
0436:  MOVF   2C,W
0437:  BSF    03.5
0438:  MOVWF  07
0439:  NOP
043A:  BCF    03.5
043B:  BSF    2C.3
043C:  MOVF   2C,W
043D:  BSF    03.5
043E:  MOVWF  07
043F:  BCF    03.5
0440:  BTFSS  07.3
0441:  GOTO   440
0442:  NOP
0443:  GOTO   444
0444:  NOP
0445:  BSF    2C.4
0446:  MOVF   2C,W
0447:  BSF    03.5
0448:  MOVWF  07
0449:  NOP
....................     delay_us(44); 
044A:  MOVLW  2B
044B:  MOVWF  77
044C:  DECFSZ 77,F
044D:  GOTO   44C
044E:  GOTO   44F
.................... } 
.................... void clear_lcd_i2c() 
.................... { 
....................     send_lcd_i2c_command(0x01); 
*
0230:  MOVLW  01
0231:  MOVWF  6B
0232:  CALL   1C6
....................     delay_ms(2); 
0233:  MOVLW  02
0234:  MOVWF  67
0235:  CALL   21B
0236:  RETURN
.................... } 
.................... int read_cursor_address() 
.................... { 
....................     int aux, aux2, address; 
....................  
....................     aux = 0xF2 | backlight_lcd_i2c; // Set PCF pins for D7:D4 of LCD E=0 | RW=1 | RS=0. 
*
0295:  MOVF   2D,W
0296:  IORLW  F2
0297:  MOVWF  6B
....................     aux2 = aux;                     // Copy aux value 
0298:  MOVF   6B,W
0299:  MOVWF  6C
....................  
....................     i2c_start(); 
029A:  BSF    2C.4
029B:  MOVF   2C,W
029C:  BSF    03.5
029D:  MOVWF  07
029E:  NOP
029F:  BCF    03.5
02A0:  BSF    2C.3
02A1:  MOVF   2C,W
02A2:  BSF    03.5
02A3:  MOVWF  07
02A4:  NOP
02A5:  BCF    03.5
02A6:  BCF    07.4
02A7:  BCF    2C.4
02A8:  MOVF   2C,W
02A9:  BSF    03.5
02AA:  MOVWF  07
02AB:  NOP
02AC:  BCF    03.5
02AD:  BCF    07.3
02AE:  BCF    2C.3
02AF:  MOVF   2C,W
02B0:  BSF    03.5
02B1:  MOVWF  07
....................     i2c_write(pcf_address_write); 
02B2:  MOVLW  7E
02B3:  MOVWF  70
02B4:  BCF    03.5
02B5:  CALL   17C
....................     i2c_write(aux);        // Set PCF pins for D7:D4 of LCD E=0 | RW=1 | RS=0. 
02B6:  MOVF   6B,W
02B7:  MOVWF  70
02B8:  CALL   17C
....................     i2c_write(aux | 0x04); // En=1 for LCD to provide most significant nibble. 
02B9:  MOVF   6B,W
02BA:  IORLW  04
02BB:  MOVWF  6E
02BC:  MOVWF  70
02BD:  CALL   17C
....................     i2c_start(); 
02BE:  BSF    2C.4
02BF:  MOVF   2C,W
02C0:  BSF    03.5
02C1:  MOVWF  07
02C2:  NOP
02C3:  BCF    03.5
02C4:  BSF    2C.3
02C5:  MOVF   2C,W
02C6:  BSF    03.5
02C7:  MOVWF  07
02C8:  NOP
02C9:  BCF    03.5
02CA:  BTFSS  07.3
02CB:  GOTO   2CA
02CC:  BCF    07.4
02CD:  BCF    2C.4
02CE:  MOVF   2C,W
02CF:  BSF    03.5
02D0:  MOVWF  07
02D1:  NOP
02D2:  BCF    03.5
02D3:  BCF    07.3
02D4:  BCF    2C.3
02D5:  MOVF   2C,W
02D6:  BSF    03.5
02D7:  MOVWF  07
....................     i2c_write(pcf_address_read); 
02D8:  MOVLW  7F
02D9:  MOVWF  70
02DA:  BCF    03.5
02DB:  CALL   17C
....................     address = 0x70 & i2c_read(0); // Read most significant nibble with mask 0x70. 
02DC:  CLRF   77
*
0320:  MOVF   78,W
0321:  ANDLW  70
0322:  BCF    03.5
0323:  MOVWF  6D
....................     i2c_start(); 
0324:  BSF    2C.4
0325:  MOVF   2C,W
0326:  BSF    03.5
0327:  MOVWF  07
0328:  NOP
0329:  BCF    03.5
032A:  BSF    2C.3
032B:  MOVF   2C,W
032C:  BSF    03.5
032D:  MOVWF  07
032E:  NOP
032F:  BCF    03.5
0330:  BTFSS  07.3
0331:  GOTO   330
0332:  BCF    07.4
0333:  BCF    2C.4
0334:  MOVF   2C,W
0335:  BSF    03.5
0336:  MOVWF  07
0337:  NOP
0338:  BCF    03.5
0339:  BCF    07.3
033A:  BCF    2C.3
033B:  MOVF   2C,W
033C:  BSF    03.5
033D:  MOVWF  07
....................     i2c_write(pcf_address_write); 
033E:  MOVLW  7E
033F:  MOVWF  70
0340:  BCF    03.5
0341:  CALL   17C
....................     i2c_write(aux);        // Clear Enable pin of LCD 
0342:  MOVF   6B,W
0343:  MOVWF  70
0344:  CALL   17C
....................     i2c_write(aux | 0x04); // Set Enable pin of LCD to provide least significant nibble. 
0345:  MOVF   6B,W
0346:  IORLW  04
0347:  MOVWF  6E
0348:  MOVWF  70
0349:  CALL   17C
....................     i2c_start(); 
034A:  BSF    2C.4
034B:  MOVF   2C,W
034C:  BSF    03.5
034D:  MOVWF  07
034E:  NOP
034F:  BCF    03.5
0350:  BSF    2C.3
0351:  MOVF   2C,W
0352:  BSF    03.5
0353:  MOVWF  07
0354:  NOP
0355:  BCF    03.5
0356:  BTFSS  07.3
0357:  GOTO   356
0358:  BCF    07.4
0359:  BCF    2C.4
035A:  MOVF   2C,W
035B:  BSF    03.5
035C:  MOVWF  07
035D:  NOP
035E:  BCF    03.5
035F:  BCF    07.3
0360:  BCF    2C.3
0361:  MOVF   2C,W
0362:  BSF    03.5
0363:  MOVWF  07
....................     i2c_write(pcf_address_read); 
0364:  MOVLW  7F
0365:  MOVWF  70
0366:  BCF    03.5
0367:  CALL   17C
....................     aux = 0xF0 & i2c_read(0); // Read least significant nibble with mask 0xF0. 
0368:  CLRF   77
*
03AC:  MOVF   78,W
03AD:  ANDLW  F0
03AE:  BCF    03.5
03AF:  MOVWF  6B
....................     i2c_start(); 
03B0:  BSF    2C.4
03B1:  MOVF   2C,W
03B2:  BSF    03.5
03B3:  MOVWF  07
03B4:  NOP
03B5:  BCF    03.5
03B6:  BSF    2C.3
03B7:  MOVF   2C,W
03B8:  BSF    03.5
03B9:  MOVWF  07
03BA:  NOP
03BB:  BCF    03.5
03BC:  BTFSS  07.3
03BD:  GOTO   3BC
03BE:  BCF    07.4
03BF:  BCF    2C.4
03C0:  MOVF   2C,W
03C1:  BSF    03.5
03C2:  MOVWF  07
03C3:  NOP
03C4:  BCF    03.5
03C5:  BCF    07.3
03C6:  BCF    2C.3
03C7:  MOVF   2C,W
03C8:  BSF    03.5
03C9:  MOVWF  07
....................     i2c_write(pcf_address_write); 
03CA:  MOVLW  7E
03CB:  MOVWF  70
03CC:  BCF    03.5
03CD:  CALL   17C
....................     i2c_write(aux2); // Clear Enable pin first 
03CE:  MOVF   6C,W
03CF:  MOVWF  70
03D0:  CALL   17C
....................     aux2 &= 0xF8; 
03D1:  MOVLW  F8
03D2:  ANDWF  6C,F
....................     i2c_write(aux2); // Clear RW pin to exit read mode. 
03D3:  MOVF   6C,W
03D4:  MOVWF  70
03D5:  CALL   17C
....................     i2c_stop(); 
03D6:  BCF    2C.4
03D7:  MOVF   2C,W
03D8:  BSF    03.5
03D9:  MOVWF  07
03DA:  NOP
03DB:  BCF    03.5
03DC:  BSF    2C.3
03DD:  MOVF   2C,W
03DE:  BSF    03.5
03DF:  MOVWF  07
03E0:  BCF    03.5
03E1:  BTFSS  07.3
03E2:  GOTO   3E1
03E3:  NOP
03E4:  GOTO   3E5
03E5:  NOP
03E6:  BSF    2C.4
03E7:  MOVF   2C,W
03E8:  BSF    03.5
03E9:  MOVWF  07
03EA:  NOP
....................  
....................     swap(aux);      // Position least significant nibble correctly. 
03EB:  BCF    03.5
03EC:  SWAPF  6B,F
....................     address |= aux; // OR operation between least and most significant nibble. 
03ED:  MOVF   6B,W
03EE:  IORWF  6D,F
....................     delay_us(45); 
03EF:  MOVLW  2C
03F0:  MOVWF  77
03F1:  DECFSZ 77,F
03F2:  GOTO   3F1
03F3:  GOTO   3F4
....................     return (address); // Return current cursor address. 
03F4:  MOVF   6D,W
03F5:  MOVWF  78
.................... } 
.................... void write_lcd_i2c(char character) 
.................... { 
....................     int cursor_address; 
....................  
....................     if (character == '\n') 
*
027D:  MOVF   69,W
027E:  SUBLW  0A
027F:  BTFSS  03.2
0280:  GOTO   295
....................     {          // Position cursor at the start of the next line. 
.................... #ifdef LCD20X4 // Using LCD 20 x 4 
....................         switch (lcd_i2c_line) 
....................         { 
....................         case 1: 
....................             send_lcd_i2c_command(line2_start_command); 
....................             lcd_i2c_line = 2; 
....................             break; 
....................         case 2: 
....................             send_lcd_i2c_command(line3_start_command); 
....................             lcd_i2c_line = 3; 
....................             break; 
....................         case 3: 
....................             send_lcd_i2c_command(line4_start_command); 
....................             lcd_i2c_line = 4; 
....................             break; 
....................         case 4: 
....................             send_lcd_i2c_command(line1_start_command); 
....................             lcd_i2c_line = 1; 
....................             break; 
....................         } 
.................... #else // Using LCD 16 x 2 
....................         switch (lcd_i2c_line) 
0281:  MOVF   2E,W
0282:  XORLW  01
0283:  BTFSC  03.2
0284:  GOTO   289
0285:  XORLW  03
0286:  BTFSC  03.2
0287:  GOTO   28F
0288:  GOTO   294
....................         { 
....................         case 1: 
....................             send_lcd_i2c_command(line2_start_command); 
0289:  MOVLW  C0
028A:  MOVWF  6B
028B:  CALL   1C6
....................             lcd_i2c_line = 2; 
028C:  MOVLW  02
028D:  MOVWF  2E
....................             break; 
028E:  GOTO   294
....................         case 2: 
....................             send_lcd_i2c_command(line1_start_command); 
028F:  MOVLW  80
0290:  MOVWF  6B
0291:  CALL   1C6
....................             lcd_i2c_line = 1; 
0292:  MOVLW  01
0293:  MOVWF  2E
....................             break; 
....................         } 
.................... #endif 
....................     } 
0294:  GOTO   46B
....................     else 
....................     { 
....................         cursor_address = read_cursor_address(); 
*
03F6:  MOVF   78,W
03F7:  MOVWF  6A
....................         send_lcd_i2c_character(character); 
03F8:  MOVF   69,W
03F9:  MOVWF  6B
.................... #ifdef LCD20X4 // Using LCD 20 x 4 
....................         switch (lcd_i2c_line) 
....................         { 
....................         case 1: 
....................             if (cursor_address == line1_end) 
....................             { 
....................                 send_lcd_i2c_command(line2_start_command); 
....................                 lcd_i2c_line = 2; 
....................             } 
....................             break; 
....................         case 2: 
....................             if (cursor_address == line2_end) 
....................             { 
....................                 send_lcd_i2c_command(line3_start_command); 
....................                 lcd_i2c_line = 3; 
....................             } 
....................             break; 
....................         case 3: 
....................             if (cursor_address == line3_end) 
....................             { 
....................                 send_lcd_i2c_command(line4_start_command); 
....................                 lcd_i2c_line = 4; 
....................             } 
....................             break; 
....................         case 4: 
....................             if (cursor_address == line4_end) 
....................             { 
....................                 send_lcd_i2c_command(line1_start_command); 
....................                 lcd_i2c_line = 1; 
....................             } 
....................             break; 
....................         } 
.................... #else // Using LCD 16 x 2 
....................         switch (lcd_i2c_line) 
*
044F:  BCF    03.5
0450:  MOVF   2E,W
0451:  XORLW  01
0452:  BTFSC  03.2
0453:  GOTO   458
0454:  XORLW  03
0455:  BTFSC  03.2
0456:  GOTO   462
0457:  GOTO   46B
....................         { 
....................         case 1: 
....................             if (cursor_address == line1_end) 
0458:  MOVF   6A,W
0459:  SUBLW  27
045A:  BTFSS  03.2
045B:  GOTO   461
....................             { 
....................                 send_lcd_i2c_command(line2_start_command); 
045C:  MOVLW  C0
045D:  MOVWF  6B
045E:  CALL   1C6
....................                 lcd_i2c_line = 2; 
045F:  MOVLW  02
0460:  MOVWF  2E
....................             } 
....................             break; 
0461:  GOTO   46B
....................         case 2: 
....................             if (cursor_address == line2_end) 
0462:  MOVF   6A,W
0463:  SUBLW  67
0464:  BTFSS  03.2
0465:  GOTO   46B
....................             { 
....................                 send_lcd_i2c_command(line1_start_command); 
0466:  MOVLW  80
0467:  MOVWF  6B
0468:  CALL   1C6
....................                 lcd_i2c_line = 1; 
0469:  MOVLW  01
046A:  MOVWF  2E
....................             } 
....................             break; 
....................         } 
.................... #endif 
....................     } 
046B:  RETURN
.................... } 
.................... void send_lcd_i2c_string(char *string) 
.................... { 
....................     while (*string) 
....................         write_lcd_i2c(*string++); 
.................... } 
.................... void set_lcd_i2c_cursor_position(char x, char y) 
.................... { 
....................     switch (x) 
*
0265:  MOVF   66,W
0266:  XORLW  01
0267:  BTFSC  03.2
0268:  GOTO   26D
0269:  XORLW  03
026A:  BTFSC  03.2
026B:  GOTO   275
026C:  GOTO   27C
....................     { 
....................     case 1:                                            // Line 1 
....................         send_lcd_i2c_command(line1_start_command + y); // Position command. 
026D:  MOVLW  80
026E:  ADDWF  67,W
026F:  MOVWF  68
0270:  MOVWF  6B
0271:  CALL   1C6
....................         lcd_i2c_line = 1;                              // Assign current line for write control. 
0272:  MOVLW  01
0273:  MOVWF  2E
....................         break; 
0274:  GOTO   27C
....................     case 2:                                            // Line 2 
....................         send_lcd_i2c_command(line2_start_command + y); // Position command. 
0275:  MOVLW  C0
0276:  ADDWF  67,W
0277:  MOVWF  68
0278:  MOVWF  6B
0279:  CALL   1C6
....................         lcd_i2c_line = 2;                              // Assign current line for write control. 
027A:  MOVLW  02
027B:  MOVWF  2E
....................         break; 
.................... #ifdef LCD20X4                                 // Using LCD 20 x 4 
....................     case 3:                                    // Line 3 
....................         send_lcd_i2c_command(line3_start + y); // Position command. 
....................         lcd_i2c_line = 3;                      // Assign current line for write control. 
....................         break; 
....................     case 4:                                    // Line 4 
....................         send_lcd_i2c_command(line4_start + y); // Position command. 
....................         lcd_i2c_line = 4;                      // Assign current line for write control. 
....................         break; 
.................... #endif 
....................     } 
027C:  RETURN
.................... } 
.................... void configure_lcd_i2c(int cursor, int blink, int backlight) 
.................... { 
....................     int aux; 
....................     backlight_lcd_i2c = 0x08 * backlight; // Set backlight status. 
....................  
....................     aux = 0x08 | (cursor << 1) | blink; // Combine bits to form the control byte 
....................     send_lcd_i2c_command(aux);          // Send control command to the LCD 
.................... } 
....................  
....................  
.................... const unsigned int16 DOT_DURATION = 200; 
.................... const unsigned int16 DASH_DURATION = 600; 
....................  
.................... const int8 SW_Pin[] = {Pin_B0, Pin_B1, Pin_B2, Pin_B3, Pin_B4}; 
.................... // int8 SW_Pin = Pin_B0; // Assuming only one button for Morse code input 
....................  
.................... const int8 LED_Pin = Pin_D0; 
.................... const int8 Buzzer_Pin = Pin_D1; 
....................  
.................... unsigned int16 elapsedTime = 0; 
....................  
.................... unsigned int8 morseCodeBufferString[6]; 
.................... unsigned int8 morseCodeBufferIndex = 0; 
....................  
.................... unsigned int8 morseCodeString[16]; 
.................... unsigned int8 morseCodeStringIndex = 0; 
....................  
.................... typedef struct 
.................... { 
....................     char morseCode[6]; 
....................     char character; 
.................... } MorseCode; 
....................  
.................... const MorseCode morseCodeTable[] = { 
....................     {".-", 'A'}, // 
....................     {"-...", 'B'}, 
....................     {"-.-.", 'C'}, 
....................     {"-..", 'D'}, 
....................     {".", 'E'}, 
....................     {"..-.", 'F'}, 
....................     {"--.", 'G'}, 
....................     {"....", 'H'}, 
....................     {"..", 'I'}, 
....................     {".---", 'J'}, 
....................     {"-.-", 'K'}, 
....................     {".-..", 'L'}, 
....................     {"--", 'M'}, 
....................     {"-.", 'N'}, 
....................     {"---", 'O'}, 
....................     {".--.", 'P'}, 
....................     {"--.-", 'Q'}, 
....................     {".-.", 'R'}, 
....................     {"...", 'S'}, 
....................     {"-", 'T'}, 
....................     {"..-", 'U'}, 
....................     {"...-", 'V'}, 
....................     {".--", 'W'}, 
....................     {"-..-", 'X'}, 
....................     {"-.--", 'Y'}, 
....................     {"--..", 'Z'}, 
....................     {"-----", '0'}, 
....................     {".----", '1'}, 
....................     {"..---", '2'}, 
....................     {"...--", '3'}, 
....................     {"....-", '4'}, 
....................     {".....", '5'}, 
....................     {"-....", '6'}, 
....................     {"--...", '7'}, 
....................     {"---..", '8'}, 
....................     {"----.", '9'}}; 
....................  
.................... typedef enum 
.................... { 
....................     BUTTON_MODE, 
....................     UART_MODE 
.................... } Mode; 
....................  
.................... Mode inputMode = BUTTON_MODE; 
....................  
.................... #INT_TIMER1 
.................... void An389_Interrupt() 
.................... { 
....................     elapsedTime++; 
*
015D:  INCF   2F,F
015E:  BTFSC  03.2
015F:  INCF   30,F
....................     set_timer1(65036); 
0160:  CLRF   0E
0161:  MOVLW  FE
0162:  MOVWF  0F
0163:  MOVLW  0C
0164:  MOVWF  0E
....................     clear_interrupt(INT_TIMER1); 
0165:  BCF    0C.0
0166:  BCF    0C.0
0167:  BCF    0A.3
0168:  BCF    0A.4
0169:  GOTO   033
.................... } 
....................  
.................... void startTimer() 
.................... { 
....................     elapsedTime = 0; 
*
08AA:  CLRF   30
08AB:  CLRF   2F
*
0C2A:  CLRF   30
0C2B:  CLRF   2F
....................  
....................     // setup timer1, 1ms interrupt, 16MHz, timer1 16 bit, prescaler 1:8 
....................     // 16MHz / 4 = 4MHz 
....................     // 4MHz / 8 = 500KHz 
....................     // 1 / 500KHz = 2us 
....................     // 1ms / 2us = 500 
....................     // 65536 - 500 = 65036 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
*
08AC:  MOVLW  35
08AD:  MOVWF  10
*
0C2C:  MOVLW  35
0C2D:  MOVWF  10
....................     set_timer1(65036); 
*
08AE:  CLRF   0E
08AF:  MOVLW  FE
08B0:  MOVWF  0F
08B1:  MOVLW  0C
08B2:  MOVWF  0E
*
0C2E:  CLRF   0E
0C2F:  MOVLW  FE
0C30:  MOVWF  0F
0C31:  MOVLW  0C
0C32:  MOVWF  0E
....................     enable_interrupts(INT_TIMER1); 
*
08B3:  BSF    03.5
08B4:  BSF    0C.0
*
0C33:  BSF    03.5
0C34:  BSF    0C.0
....................     enable_interrupts(GLOBAL); 
*
08B5:  MOVLW  C0
08B6:  BCF    03.5
08B7:  IORWF  0B,F
08B8:  CLRF   2B
08B9:  BTFSC  0B.7
08BA:  BSF    2B.7
08BB:  BCF    0B.7
*
0C35:  MOVLW  C0
0C36:  BCF    03.5
0C37:  IORWF  0B,F
0C38:  CLRF   2B
0C39:  BTFSC  0B.7
0C3A:  BSF    2B.7
0C3B:  BCF    0B.7
.................... } 
....................  
.................... unsigned int16 getTimerValue() 
.................... { 
....................     return elapsedTime; 
*
0C48:  MOVF   2F,W
0C49:  MOVWF  78
0C4A:  MOVF   30,W
0C4B:  MOVWF  79
.................... } 
....................  
.................... unsigned int16 stopAndReadTimer() 
.................... { 
....................     disable_interrupts(INT_TIMER1); 
*
08EC:  BSF    03.5
08ED:  BCF    0C.0
*
0C5A:  BSF    03.5
0C5B:  BCF    0C.0
....................     disable_interrupts(GLOBAL); 
*
08EE:  BCF    03.5
08EF:  BCF    0B.6
08F0:  BCF    0B.7
08F1:  BTFSC  0B.7
08F2:  GOTO   0F0
*
0C5C:  BCF    03.5
0C5D:  BCF    0B.6
0C5E:  BCF    0B.7
0C5F:  BTFSC  0B.7
0C60:  GOTO   45E
....................     return elapsedTime; 
*
08F3:  MOVF   2F,W
08F4:  MOVWF  78
08F5:  MOVF   30,W
08F6:  MOVWF  79
*
0C61:  MOVF   2F,W
0C62:  MOVWF  78
0C63:  MOVF   30,W
0C64:  MOVWF  79
.................... } 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0987:  MOVF   56,W
0988:  MOVWF  7A
0989:  MOVF   55,W
098A:  MOVWF  04
098B:  BCF    03.7
098C:  BTFSC  7A.0
098D:  BSF    03.7
098E:  MOVF   00,W
098F:  MOVWF  59
0990:  MOVF   58,W
0991:  MOVWF  7A
0992:  MOVF   57,W
0993:  MOVWF  04
0994:  BCF    03.7
0995:  BTFSC  7A.0
0996:  BSF    03.7
0997:  MOVF   00,W
0998:  SUBWF  59,W
0999:  BTFSS  03.2
099A:  GOTO   1B2
....................       if (*s1 == '\0') 
099B:  MOVF   56,W
099C:  MOVWF  7A
099D:  MOVF   55,W
099E:  MOVWF  04
099F:  BCF    03.7
09A0:  BTFSC  7A.0
09A1:  BSF    03.7
09A2:  MOVF   00,F
09A3:  BTFSS  03.2
09A4:  GOTO   1A8
....................          return(0); 
09A5:  MOVLW  00
09A6:  MOVWF  78
09A7:  GOTO   1CA
09A8:  MOVF   56,W
09A9:  MOVWF  7A
09AA:  MOVF   55,W
09AB:  INCF   55,F
09AC:  BTFSC  03.2
09AD:  INCF   56,F
09AE:  INCF   57,F
09AF:  BTFSC  03.2
09B0:  INCF   58,F
09B1:  GOTO   187
....................    return((*s1 < *s2) ? -1: 1); 
09B2:  MOVF   56,W
09B3:  MOVWF  7A
09B4:  MOVF   55,W
09B5:  MOVWF  04
09B6:  BCF    03.7
09B7:  BTFSC  56.0
09B8:  BSF    03.7
09B9:  MOVF   00,W
09BA:  MOVWF  59
09BB:  MOVF   58,W
09BC:  MOVWF  7A
09BD:  MOVF   57,W
09BE:  MOVWF  04
09BF:  BCF    03.7
09C0:  BTFSC  58.0
09C1:  BSF    03.7
09C2:  MOVF   00,W
09C3:  SUBWF  59,W
09C4:  BTFSC  03.0
09C5:  GOTO   1C8
09C6:  MOVLW  FF
09C7:  GOTO   1C9
09C8:  MOVLW  01
09C9:  MOVWF  78
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
082B:  BCF    03.6
082C:  CLRF   4A
082D:  CLRF   4B
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <morseCodeReader.c> 
.................... #include <global_variables.h> 
.................... #ifndef VAR_H 
.................... #define VAR_H 
....................  
.................... #include <lcd_i2c.c> 
....................  
.................... const unsigned int16 DOT_DURATION = 200; 
.................... const unsigned int16 DASH_DURATION = 600; 
....................  
.................... const int8 SW_Pin[] = {Pin_B0, Pin_B1, Pin_B2, Pin_B3, Pin_B4}; 
.................... // int8 SW_Pin = Pin_B0; // Assuming only one button for Morse code input 
....................  
.................... const int8 LED_Pin = Pin_D0; 
.................... const int8 Buzzer_Pin = Pin_D1; 
....................  
.................... unsigned int16 elapsedTime = 0; 
....................  
.................... unsigned int8 morseCodeBufferString[6]; 
.................... unsigned int8 morseCodeBufferIndex = 0; 
....................  
.................... unsigned int8 morseCodeString[16]; 
.................... unsigned int8 morseCodeStringIndex = 0; 
....................  
.................... typedef struct 
.................... { 
....................     char morseCode[6]; 
....................     char character; 
.................... } MorseCode; 
....................  
.................... const MorseCode morseCodeTable[] = { 
....................     {".-", 'A'}, // 
....................     {"-...", 'B'}, 
....................     {"-.-.", 'C'}, 
....................     {"-..", 'D'}, 
....................     {".", 'E'}, 
....................     {"..-.", 'F'}, 
....................     {"--.", 'G'}, 
....................     {"....", 'H'}, 
....................     {"..", 'I'}, 
....................     {".---", 'J'}, 
....................     {"-.-", 'K'}, 
....................     {".-..", 'L'}, 
....................     {"--", 'M'}, 
....................     {"-.", 'N'}, 
....................     {"---", 'O'}, 
....................     {".--.", 'P'}, 
....................     {"--.-", 'Q'}, 
....................     {".-.", 'R'}, 
....................     {"...", 'S'}, 
....................     {"-", 'T'}, 
....................     {"..-", 'U'}, 
....................     {"...-", 'V'}, 
....................     {".--", 'W'}, 
....................     {"-..-", 'X'}, 
....................     {"-.--", 'Y'}, 
....................     {"--..", 'Z'}, 
....................     {"-----", '0'}, 
....................     {".----", '1'}, 
....................     {"..---", '2'}, 
....................     {"...--", '3'}, 
....................     {"....-", '4'}, 
....................     {".....", '5'}, 
....................     {"-....", '6'}, 
....................     {"--...", '7'}, 
....................     {"---..", '8'}, 
....................     {"----.", '9'}}; 
....................  
.................... typedef enum 
.................... { 
....................     BUTTON_MODE, 
....................     UART_MODE 
.................... } Mode; 
....................  
.................... Mode inputMode = BUTTON_MODE; 
....................  
.................... #INT_TIMER1 
.................... void An389_Interrupt() 
.................... { 
....................     elapsedTime++; 
....................     set_timer1(65036); 
....................     clear_interrupt(INT_TIMER1); 
.................... } 
....................  
.................... void startTimer() 
.................... { 
....................     elapsedTime = 0; 
....................  
....................     // setup timer1, 1ms interrupt, 16MHz, timer1 16 bit, prescaler 1:8 
....................     // 16MHz / 4 = 4MHz 
....................     // 4MHz / 8 = 500KHz 
....................     // 1 / 500KHz = 2us 
....................     // 1ms / 2us = 500 
....................     // 65536 - 500 = 65036 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
....................     set_timer1(65036); 
....................     enable_interrupts(INT_TIMER1); 
....................     enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... unsigned int16 getTimerValue() 
.................... { 
....................     return elapsedTime; 
.................... } 
....................  
.................... unsigned int16 stopAndReadTimer() 
.................... { 
....................     disable_interrupts(INT_TIMER1); 
....................     disable_interrupts(GLOBAL); 
....................     return elapsedTime; 
.................... } 
....................  
.................... #endif 
....................  
.................... // #include <lcd_i2c.c> 
....................  
....................  
.................... void appendMorseCode(char morseChar) 
.................... { 
....................    morseCodeBufferString[morseCodeBufferIndex++] = morseChar; 
*
090C:  MOVF   37,W
090D:  INCF   37,F
090E:  ADDLW  31
090F:  MOVWF  04
0910:  BCF    03.7
0911:  MOVF   51,W
0912:  MOVWF  00
....................    morseCodeBufferString[morseCodeBufferIndex] = '\0'; // Null-terminate the string 
0913:  MOVLW  31
0914:  ADDWF  37,W
0915:  MOVWF  04
0916:  BCF    03.7
0917:  CLRF   00
0918:  CLRF   2B
0919:  BTFSC  0B.7
091A:  BSF    2B.7
091B:  BCF    0B.7
.................... } 
....................  
.................... void clearMorseCodeBuffer() 
.................... { 
....................    memset(morseCodeBufferString, 0, sizeof(morseCodeBufferString)); 
*
04D2:  MOVLW  31
04D3:  MOVWF  04
04D4:  BCF    03.7
04D5:  CLRF   77
04D6:  MOVLW  06
04D7:  MOVWF  78
04D8:  CALL   237
*
09E6:  MOVLW  31
09E7:  MOVWF  04
09E8:  BCF    03.7
09E9:  CLRF   77
09EA:  MOVLW  06
09EB:  MOVWF  78
09EC:  BCF    0A.3
09ED:  CALL   237
09EE:  BSF    0A.3
*
09FA:  MOVLW  31
09FB:  MOVWF  04
09FC:  BCF    03.7
09FD:  CLRF   77
09FE:  MOVLW  06
09FF:  MOVWF  78
0A00:  BCF    0A.3
0A01:  CALL   237
0A02:  BSF    0A.3
*
0C79:  MOVLW  31
0C7A:  MOVWF  04
0C7B:  BCF    03.7
0C7C:  CLRF   77
0C7D:  MOVLW  06
0C7E:  MOVWF  78
0C7F:  BCF    0A.3
0C80:  CALL   237
0C81:  BSF    0A.3
*
0CF7:  MOVLW  31
0CF8:  MOVWF  04
0CF9:  BCF    03.7
0CFA:  CLRF   77
0CFB:  MOVLW  06
0CFC:  MOVWF  78
0CFD:  BCF    0A.3
0CFE:  CALL   237
0CFF:  BSF    0A.3
....................    morseCodeBufferIndex = 0; 
*
04D9:  CLRF   37
*
09EF:  CLRF   37
*
0A03:  CLRF   37
0A04:  CLRF   2B
0A05:  BTFSC  0B.7
0A06:  BSF    2B.7
0A07:  BCF    0B.7
*
0C82:  CLRF   37
*
0D00:  CLRF   37
.................... } 
....................  
.................... void clearMorseCodeString() 
.................... { 
....................    memset(morseCodeString, 0, sizeof(morseCodeString)); 
*
04DA:  MOVLW  38
04DB:  MOVWF  04
04DC:  BCF    03.7
04DD:  CLRF   77
04DE:  MOVLW  10
04DF:  MOVWF  78
04E0:  CALL   237
*
0C83:  MOVLW  38
0C84:  MOVWF  04
0C85:  BCF    03.7
0C86:  CLRF   77
0C87:  MOVLW  10
0C88:  MOVWF  78
0C89:  BCF    0A.3
0C8A:  CALL   237
0C8B:  BSF    0A.3
*
0D01:  MOVLW  38
0D02:  MOVWF  04
0D03:  BCF    03.7
0D04:  CLRF   77
0D05:  MOVLW  10
0D06:  MOVWF  78
0D07:  BCF    0A.3
0D08:  CALL   237
0D09:  BSF    0A.3
....................    morseCodeStringIndex = 0; 
*
04E1:  CLRF   48
*
0C8C:  CLRF   48
0C8D:  CLRF   2B
0C8E:  BTFSC  0B.7
0C8F:  BSF    2B.7
0C90:  BCF    0B.7
*
0D0A:  CLRF   48
.................... } 
....................  
.................... void clearAll() 
.................... { 
....................    clear_lcd_i2c(); 
*
04D1:  CALL   230
*
0C76:  BCF    0A.3
0C77:  CALL   230
0C78:  BSF    0A.3
*
0CF4:  BCF    0A.3
0CF5:  CALL   230
0CF6:  BSF    0A.3
....................    clearMorseCodeBuffer(); 
....................    clearMorseCodeString(); 
.................... } 
....................  
.................... void translateMorseCode() 
.................... { 
....................    for (int i = 0; i < sizeof(morseCodeTable) / sizeof(MorseCode); ++i) 
*
095A:  CLRF   4E
095B:  MOVF   4E,W
095C:  SUBLW  23
095D:  BTFSS  03.0
095E:  GOTO   1F3
095F:  CLRF   2B
0960:  BTFSC  0B.7
0961:  BSF    2B.7
0962:  BCF    0B.7
....................    { 
....................       char temp[6]; 
....................       strcpy(temp, morseCodeTable[i].morseCode); 
0963:  MOVF   4E,W
0964:  MOVWF  66
0965:  MOVLW  07
0966:  MOVWF  67
0967:  BCF    0A.3
0968:  CALL   240
0969:  BSF    0A.3
096A:  BTFSC  2B.7
096B:  BSF    0B.7
096C:  MOVF   78,W
096D:  MOVWF  55
096E:  CLRF   56
096F:  MOVF   55,W
0970:  MOVWF  57
0971:  MOVLW  4F
0972:  MOVWF  04
0973:  BCF    03.7
0974:  MOVF   56,W
0975:  ADDWF  04,F
0976:  MOVF   57,W
0977:  BCF    0A.3
0978:  CALL   05A
0979:  BSF    0A.3
097A:  MOVWF  00
097B:  IORLW  00
097C:  BTFSC  03.2
097D:  GOTO   181
097E:  INCF   57,F
097F:  INCF   56,F
0980:  GOTO   171
....................  
....................       if (strcmp(morseCodeBufferString, temp) == 0) 
0981:  CLRF   56
0982:  MOVLW  31
0983:  MOVWF  55
0984:  CLRF   58
0985:  MOVLW  4F
0986:  MOVWF  57
*
09CA:  MOVF   78,F
09CB:  BTFSS  03.2
09CC:  GOTO   1F1
....................       { 
....................          morseCodeString[morseCodeStringIndex++] = morseCodeTable[i].character; 
09CD:  MOVF   48,W
09CE:  INCF   48,F
09CF:  ADDLW  38
09D0:  MOVWF  04
09D1:  BCF    03.7
09D2:  CLRF   2B
09D3:  BTFSC  0B.7
09D4:  BSF    2B.7
09D5:  BCF    0B.7
09D6:  MOVF   4E,W
09D7:  MOVWF  66
09D8:  MOVLW  07
09D9:  MOVWF  67
09DA:  BCF    0A.3
09DB:  CALL   240
09DC:  BSF    0A.3
09DD:  BTFSC  2B.7
09DE:  BSF    0B.7
09DF:  MOVLW  06
09E0:  ADDWF  78,W
09E1:  BCF    0A.3
09E2:  CALL   05A
09E3:  BSF    0A.3
09E4:  MOVWF  78
09E5:  MOVWF  00
....................          clearMorseCodeBuffer(); 
....................          return; 
*
09F0:  GOTO   204
....................       } 
09F1:  INCF   4E,F
09F2:  GOTO   15B
....................    } 
....................    morseCodeString[morseCodeStringIndex++] = '?'; 
09F3:  MOVF   48,W
09F4:  INCF   48,F
09F5:  ADDLW  38
09F6:  MOVWF  04
09F7:  BCF    03.7
09F8:  MOVLW  3F
09F9:  MOVWF  00
....................    clearMorseCodeBuffer(); 
.................... } 
....................  
.................... void recordMorseCode() 
.................... { 
....................    startTimer(); 
....................    delay_ms(50);           // Debounce 
*
08BC:  MOVLW  32
08BD:  MOVWF  67
08BE:  BCF    0A.3
08BF:  CALL   21B
08C0:  BSF    0A.3
08C1:  BTFSC  2B.7
08C2:  BSF    0B.7
....................    output_high(LED_Pin);   // Turn on LED 
08C3:  BSF    03.5
08C4:  BCF    08.0
08C5:  BCF    03.5
08C6:  BSF    08.0
....................    output_low(Buzzer_Pin); // Turn on buzzer 
08C7:  BSF    03.5
08C8:  BCF    08.1
08C9:  BCF    03.5
08CA:  BCF    08.1
....................  
....................    while (input(SW_Pin[0]) == 0) 
08CB:  BSF    03.5
08CC:  BSF    06.0
08CD:  BCF    03.5
08CE:  BTFSC  06.0
08CF:  GOTO   0E4
....................    { 
....................       if (elapsedTime > DASH_DURATION) 
08D0:  MOVF   30,W
08D1:  SUBLW  01
08D2:  BTFSC  03.0
08D3:  GOTO   0E3
08D4:  XORLW  FF
08D5:  BTFSS  03.2
08D6:  GOTO   0DB
08D7:  MOVF   2F,W
08D8:  SUBLW  58
08D9:  BTFSC  03.0
08DA:  GOTO   0E3
....................       { 
....................          output_low(LED_Pin);     // Turn off led 
08DB:  BSF    03.5
08DC:  BCF    08.0
08DD:  BCF    03.5
08DE:  BCF    08.0
....................          output_high(Buzzer_Pin); // Turn off buzzer 
08DF:  BSF    03.5
08E0:  BCF    08.1
08E1:  BCF    03.5
08E2:  BSF    08.1
....................       } 
08E3:  GOTO   0CB
....................    } 
....................  
....................    output_low(LED_Pin);     // Turn off LED 
08E4:  BSF    03.5
08E5:  BCF    08.0
08E6:  BCF    03.5
08E7:  BCF    08.0
....................    output_high(Buzzer_Pin); // Turn off buzzer 
08E8:  BSF    03.5
08E9:  BCF    08.1
08EA:  BCF    03.5
08EB:  BSF    08.1
....................  
....................    unsigned int16 duration = stopAndReadTimer(); 
*
08F7:  MOVF   79,W
08F8:  MOVWF  4F
08F9:  MOVF   78,W
08FA:  MOVWF  4E
....................    appendMorseCode(duration > DASH_DURATION ? '-' : '.'); 
08FB:  MOVF   4F,W
08FC:  SUBLW  01
08FD:  BTFSC  03.0
08FE:  GOTO   108
08FF:  XORLW  FF
0900:  BTFSS  03.2
0901:  GOTO   106
0902:  MOVF   4E,W
0903:  SUBLW  58
0904:  BTFSC  03.0
0905:  GOTO   108
0906:  MOVLW  2D
0907:  GOTO   109
0908:  MOVLW  2E
0909:  MOVWF  50
090A:  MOVF   50,W
090B:  MOVWF  51
....................  
....................    set_lcd_i2c_cursor_position(2, 0); 
*
091C:  MOVLW  02
091D:  MOVWF  66
091E:  CLRF   67
091F:  BCF    0A.3
0920:  CALL   265
0921:  BSF    0A.3
0922:  BTFSC  2B.7
0923:  BSF    0B.7
....................    printf(write_lcd_i2c, "%s", morseCodeBufferString); 
0924:  MOVLW  31
0925:  MOVWF  04
0926:  BCF    03.7
.................... } 
....................  
.................... void completeMorseCode() 
.................... { 
....................    if (morseCodeBufferIndex > 0) 
*
0957:  MOVF   37,F
0958:  BTFSC  03.2
0959:  GOTO   239
....................    { 
....................       translateMorseCode(); 
....................       clear_lcd_i2c(); 
*
0A08:  BCF    0A.3
0A09:  CALL   230
0A0A:  BSF    0A.3
0A0B:  BTFSC  2B.7
0A0C:  BSF    0B.7
0A0D:  CLRF   2B
0A0E:  BTFSC  0B.7
0A0F:  BSF    2B.7
0A10:  BCF    0B.7
....................       set_lcd_i2c_cursor_position(1, 0); 
0A11:  MOVLW  01
0A12:  MOVWF  66
0A13:  CLRF   67
0A14:  BCF    0A.3
0A15:  CALL   265
0A16:  BSF    0A.3
0A17:  BTFSC  2B.7
0A18:  BSF    0B.7
....................       printf(write_lcd_i2c, "%s", morseCodeString); 
0A19:  MOVLW  38
0A1A:  MOVWF  04
0A1B:  BCF    03.7
....................    } 
.................... } 
....................  
.................... #include <morseCodeSpeaker.c> 
.................... #include <global_variables.h> 
.................... #ifndef VAR_H 
.................... #define VAR_H 
....................  
.................... #include <lcd_i2c.c> 
....................  
.................... const unsigned int16 DOT_DURATION = 200; 
.................... const unsigned int16 DASH_DURATION = 600; 
....................  
.................... const int8 SW_Pin[] = {Pin_B0, Pin_B1, Pin_B2, Pin_B3, Pin_B4}; 
.................... // int8 SW_Pin = Pin_B0; // Assuming only one button for Morse code input 
....................  
.................... const int8 LED_Pin = Pin_D0; 
.................... const int8 Buzzer_Pin = Pin_D1; 
....................  
.................... unsigned int16 elapsedTime = 0; 
....................  
.................... unsigned int8 morseCodeBufferString[6]; 
.................... unsigned int8 morseCodeBufferIndex = 0; 
....................  
.................... unsigned int8 morseCodeString[16]; 
.................... unsigned int8 morseCodeStringIndex = 0; 
....................  
.................... typedef struct 
.................... { 
....................     char morseCode[6]; 
....................     char character; 
.................... } MorseCode; 
....................  
.................... const MorseCode morseCodeTable[] = { 
....................     {".-", 'A'}, // 
....................     {"-...", 'B'}, 
....................     {"-.-.", 'C'}, 
....................     {"-..", 'D'}, 
....................     {".", 'E'}, 
....................     {"..-.", 'F'}, 
....................     {"--.", 'G'}, 
....................     {"....", 'H'}, 
....................     {"..", 'I'}, 
....................     {".---", 'J'}, 
....................     {"-.-", 'K'}, 
....................     {".-..", 'L'}, 
....................     {"--", 'M'}, 
....................     {"-.", 'N'}, 
....................     {"---", 'O'}, 
....................     {".--.", 'P'}, 
....................     {"--.-", 'Q'}, 
....................     {".-.", 'R'}, 
....................     {"...", 'S'}, 
....................     {"-", 'T'}, 
....................     {"..-", 'U'}, 
....................     {"...-", 'V'}, 
....................     {".--", 'W'}, 
....................     {"-..-", 'X'}, 
....................     {"-.--", 'Y'}, 
....................     {"--..", 'Z'}, 
....................     {"-----", '0'}, 
....................     {".----", '1'}, 
....................     {"..---", '2'}, 
....................     {"...--", '3'}, 
....................     {"....-", '4'}, 
....................     {".....", '5'}, 
....................     {"-....", '6'}, 
....................     {"--...", '7'}, 
....................     {"---..", '8'}, 
....................     {"----.", '9'}}; 
....................  
.................... typedef enum 
.................... { 
....................     BUTTON_MODE, 
....................     UART_MODE 
.................... } Mode; 
....................  
.................... Mode inputMode = BUTTON_MODE; 
....................  
.................... #INT_TIMER1 
.................... void An389_Interrupt() 
.................... { 
....................     elapsedTime++; 
....................     set_timer1(65036); 
....................     clear_interrupt(INT_TIMER1); 
.................... } 
....................  
.................... void startTimer() 
.................... { 
....................     elapsedTime = 0; 
....................  
....................     // setup timer1, 1ms interrupt, 16MHz, timer1 16 bit, prescaler 1:8 
....................     // 16MHz / 4 = 4MHz 
....................     // 4MHz / 8 = 500KHz 
....................     // 1 / 500KHz = 2us 
....................     // 1ms / 2us = 500 
....................     // 65536 - 500 = 65036 
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
....................     set_timer1(65036); 
....................     enable_interrupts(INT_TIMER1); 
....................     enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... unsigned int16 getTimerValue() 
.................... { 
....................     return elapsedTime; 
.................... } 
....................  
.................... unsigned int16 stopAndReadTimer() 
.................... { 
....................     disable_interrupts(INT_TIMER1); 
....................     disable_interrupts(GLOBAL); 
....................     return elapsedTime; 
.................... } 
....................  
.................... #endif 
....................  
.................... // #include <lcd_i2c.c> 
....................  
.................... void playMorseCodeWithBuzzer() 
.................... { 
....................     for (int i = 0; i < morseCodeStringIndex; ++i) 
*
04E3:  CLRF   60
04E4:  MOVF   48,W
04E5:  SUBWF  60,W
04E6:  BTFSC  03.0
04E7:  GOTO   59C
*
0A4F:  CLRF   60
0A50:  MOVF   48,W
0A51:  SUBWF  60,W
0A52:  BTFSC  03.0
0A53:  GOTO   32C
....................     { 
....................         char c = morseCodeString[i]; 
*
04E8:  MOVLW  38
04E9:  ADDWF  60,W
04EA:  MOVWF  04
04EB:  BCF    03.7
04EC:  MOVF   00,W
04ED:  MOVWF  61
*
0A54:  MOVLW  38
0A55:  ADDWF  60,W
0A56:  MOVWF  04
0A57:  BCF    03.7
0A58:  MOVF   00,W
0A59:  MOVWF  61
....................         for (int j = 0; j < sizeof(morseCodeTable) / sizeof(MorseCode); ++j) 
*
04EE:  CLRF   62
04EF:  MOVF   62,W
04F0:  SUBLW  23
04F1:  BTFSS  03.0
04F2:  GOTO   59A
*
0A5A:  CLRF   62
0A5B:  MOVF   62,W
0A5C:  SUBLW  23
0A5D:  BTFSS  03.0
0A5E:  GOTO   32A
....................         { 
....................             if (c == morseCodeTable[j].character) 
*
04F3:  MOVF   62,W
04F4:  MOVWF  66
04F5:  MOVLW  07
04F6:  MOVWF  67
04F7:  CALL   240
04F8:  MOVLW  06
04F9:  ADDWF  78,W
04FA:  CALL   05A
04FB:  MOVWF  78
04FC:  SUBWF  61,W
04FD:  BTFSS  03.2
04FE:  GOTO   598
*
0A5F:  MOVF   62,W
0A60:  MOVWF  66
0A61:  MOVLW  07
0A62:  MOVWF  67
0A63:  BCF    0A.3
0A64:  CALL   240
0A65:  BSF    0A.3
0A66:  MOVLW  06
0A67:  ADDWF  78,W
0A68:  BCF    0A.3
0A69:  CALL   05A
0A6A:  BSF    0A.3
0A6B:  MOVWF  78
0A6C:  SUBWF  61,W
0A6D:  BTFSS  03.2
0A6E:  GOTO   328
....................             { 
....................                 set_lcd_i2c_cursor_position(2, 0); 
*
04FF:  MOVLW  02
0500:  MOVWF  66
0501:  CLRF   67
0502:  CALL   265
*
0A6F:  MOVLW  02
0A70:  MOVWF  66
0A71:  CLRF   67
0A72:  BCF    0A.3
0A73:  CALL   265
0A74:  BSF    0A.3
....................                 printf(write_lcd_i2c, "%c: %s", c, morseCodeTable[j].morseCode); 
*
0503:  MOVF   62,W
0504:  MOVWF  66
0505:  MOVLW  07
0506:  MOVWF  67
0507:  CALL   240
0508:  MOVF   78,W
0509:  MOVWF  66
050A:  MOVF   61,W
050B:  MOVWF  69
050C:  CALL   27D
050D:  MOVLW  3A
050E:  MOVWF  69
050F:  CALL   27D
0510:  MOVLW  20
0511:  MOVWF  69
0512:  CALL   27D
0513:  MOVLW  61
0514:  BSF    03.6
0515:  MOVWF  0D
0516:  MOVLW  00
0517:  MOVWF  0F
0518:  BCF    03.6
0519:  MOVF   66,W
051A:  BSF    03.6
051B:  ADDWF  0D,F
051C:  BTFSC  03.0
051D:  INCF   0F,F
*
0A75:  MOVF   62,W
0A76:  MOVWF  66
0A77:  MOVLW  07
0A78:  MOVWF  67
0A79:  BCF    0A.3
0A7A:  CALL   240
0A7B:  BSF    0A.3
0A7C:  MOVF   78,W
0A7D:  MOVWF  66
0A7E:  MOVF   61,W
0A7F:  MOVWF  69
0A80:  BCF    0A.3
0A81:  CALL   27D
0A82:  BSF    0A.3
0A83:  MOVLW  3A
0A84:  MOVWF  69
0A85:  BCF    0A.3
0A86:  CALL   27D
0A87:  BSF    0A.3
0A88:  MOVLW  20
0A89:  MOVWF  69
0A8A:  BCF    0A.3
0A8B:  CALL   27D
0A8C:  BSF    0A.3
0A8D:  MOVLW  61
0A8E:  BSF    03.6
0A8F:  MOVWF  0D
0A90:  MOVLW  00
0A91:  MOVWF  0F
0A92:  BCF    03.6
0A93:  MOVF   66,W
0A94:  BSF    03.6
0A95:  ADDWF  0D,F
0A96:  BTFSC  03.0
0A97:  INCF   0F,F
....................  
....................                 unsigned int8 k = 0; 
*
0547:  BCF    03.6
0548:  CLRF   63
*
0AC3:  BCF    03.6
0AC4:  CLRF   63
....................                 while (morseCodeTable[j].morseCode[k] != '\0') 
*
0549:  MOVF   62,W
054A:  MOVWF  66
054B:  MOVLW  07
054C:  MOVWF  67
054D:  CALL   240
054E:  MOVF   63,W
054F:  ADDWF  78,W
0550:  CALL   05A
0551:  XORLW  00
0552:  BTFSC  03.2
0553:  GOTO   586
*
0AC5:  MOVF   62,W
0AC6:  MOVWF  66
0AC7:  MOVLW  07
0AC8:  MOVWF  67
0AC9:  BCF    0A.3
0ACA:  CALL   240
0ACB:  BSF    0A.3
0ACC:  MOVF   63,W
0ACD:  ADDWF  78,W
0ACE:  BCF    0A.3
0ACF:  CALL   05A
0AD0:  BSF    0A.3
0AD1:  XORLW  00
0AD2:  BTFSC  03.2
0AD3:  GOTO   310
....................                 { 
....................                     output_low(Buzzer_Pin); 
*
0554:  BSF    03.5
0555:  BCF    08.1
0556:  BCF    03.5
0557:  BCF    08.1
*
0AD4:  BSF    03.5
0AD5:  BCF    08.1
0AD6:  BCF    03.5
0AD7:  BCF    08.1
....................                     unsigned int16 duration = morseCodeTable[j].morseCode[k] == '-' ? DASH_DURATION : DOT_DURATION; 
*
0558:  MOVF   62,W
0559:  MOVWF  66
055A:  MOVLW  07
055B:  MOVWF  67
055C:  CALL   240
055D:  MOVF   63,W
055E:  ADDWF  78,W
055F:  CALL   05A
0560:  SUBLW  2D
0561:  BTFSS  03.2
0562:  GOTO   567
0563:  MOVLW  02
0564:  MOVWF  7A
0565:  MOVLW  58
0566:  GOTO   569
0567:  CLRF   7A
0568:  MOVLW  C8
0569:  MOVWF  64
056A:  MOVF   7A,W
056B:  MOVWF  65
*
0AD8:  MOVF   62,W
0AD9:  MOVWF  66
0ADA:  MOVLW  07
0ADB:  MOVWF  67
0ADC:  BCF    0A.3
0ADD:  CALL   240
0ADE:  BSF    0A.3
0ADF:  MOVF   63,W
0AE0:  ADDWF  78,W
0AE1:  BCF    0A.3
0AE2:  CALL   05A
0AE3:  BSF    0A.3
0AE4:  SUBLW  2D
0AE5:  BTFSS  03.2
0AE6:  GOTO   2EB
0AE7:  MOVLW  02
0AE8:  MOVWF  7A
0AE9:  MOVLW  58
0AEA:  GOTO   2ED
0AEB:  CLRF   7A
0AEC:  MOVLW  C8
0AED:  MOVWF  64
0AEE:  MOVF   7A,W
0AEF:  MOVWF  65
....................                     delay_ms(duration); 
*
056C:  MOVF   65,W
056D:  MOVWF  66
056E:  INCF   66,F
056F:  DECF   66,F
0570:  BTFSC  03.2
0571:  GOTO   576
0572:  MOVLW  FF
0573:  MOVWF  67
0574:  CALL   21B
0575:  GOTO   56F
0576:  MOVF   64,W
0577:  MOVWF  67
0578:  CALL   21B
*
0AF0:  MOVF   65,W
0AF1:  MOVWF  66
0AF2:  INCF   66,F
0AF3:  DECF   66,F
0AF4:  BTFSC  03.2
0AF5:  GOTO   2FC
0AF6:  MOVLW  FF
0AF7:  MOVWF  67
0AF8:  BCF    0A.3
0AF9:  CALL   21B
0AFA:  BSF    0A.3
0AFB:  GOTO   2F3
0AFC:  MOVF   64,W
0AFD:  MOVWF  67
0AFE:  BCF    0A.3
0AFF:  CALL   21B
0B00:  BSF    0A.3
....................                     output_high(Buzzer_Pin); 
*
0579:  BSF    03.5
057A:  BCF    08.1
057B:  BCF    03.5
057C:  BSF    08.1
*
0B01:  BSF    03.5
0B02:  BCF    08.1
0B03:  BCF    03.5
0B04:  BSF    08.1
....................  
....................                     delay_ms(400); 
*
057D:  MOVLW  02
057E:  MOVWF  66
057F:  MOVLW  C8
0580:  MOVWF  67
0581:  CALL   21B
0582:  DECFSZ 66,F
0583:  GOTO   57F
*
0B05:  MOVLW  02
0B06:  MOVWF  66
0B07:  MOVLW  C8
0B08:  MOVWF  67
0B09:  BCF    0A.3
0B0A:  CALL   21B
0B0B:  BSF    0A.3
0B0C:  DECFSZ 66,F
0B0D:  GOTO   307
....................  
....................                     k++; 
*
0584:  INCF   63,F
0585:  GOTO   549
*
0B0E:  INCF   63,F
0B0F:  GOTO   2C5
....................                 } 
....................  
....................                 set_lcd_i2c_cursor_position(2, 0); 
*
0586:  MOVLW  02
0587:  MOVWF  66
0588:  CLRF   67
0589:  CALL   265
*
0B10:  MOVLW  02
0B11:  MOVWF  66
0B12:  CLRF   67
0B13:  BCF    0A.3
0B14:  CALL   265
0B15:  BSF    0A.3
....................                 printf(write_lcd_i2c, "                "); 
*
058A:  MOVLW  6A
058B:  BSF    03.6
058C:  MOVWF  0D
058D:  MOVLW  01
058E:  MOVWF  0F
058F:  BCF    03.6
0590:  CALL   46C
*
0B16:  MOVLW  6A
0B17:  BSF    03.6
0B18:  MOVWF  0D
0B19:  MOVLW  01
0B1A:  MOVWF  0F
0B1B:  BCF    0A.3
0B1C:  BCF    03.6
0B1D:  CALL   46C
0B1E:  BSF    0A.3
....................  
....................                 delay_ms(800); 
*
0591:  MOVLW  04
0592:  MOVWF  66
0593:  MOVLW  C8
0594:  MOVWF  67
0595:  CALL   21B
0596:  DECFSZ 66,F
0597:  GOTO   593
*
0B1F:  MOVLW  04
0B20:  MOVWF  66
0B21:  MOVLW  C8
0B22:  MOVWF  67
0B23:  BCF    0A.3
0B24:  CALL   21B
0B25:  BSF    0A.3
0B26:  DECFSZ 66,F
0B27:  GOTO   321
....................             } 
*
0598:  INCF   62,F
0599:  GOTO   4EF
*
0B28:  INCF   62,F
0B29:  GOTO   25B
....................         } 
*
059A:  INCF   60,F
059B:  GOTO   4E4
*
0B2A:  INCF   60,F
0B2B:  GOTO   250
....................     } 
.................... } 
....................  
.................... void playMorseCodeWithLED() 
.................... { 
....................     for (int i = 0; i < morseCodeStringIndex; ++i) 
*
059D:  CLRF   60
059E:  MOVF   48,W
059F:  SUBWF  60,W
05A0:  BTFSC  03.0
05A1:  GOTO   656
*
0B42:  CLRF   60
0B43:  MOVF   48,W
0B44:  SUBWF  60,W
0B45:  BTFSC  03.0
0B46:  GOTO   41F
....................     { 
....................         char c = morseCodeString[i]; 
*
05A2:  MOVLW  38
05A3:  ADDWF  60,W
05A4:  MOVWF  04
05A5:  BCF    03.7
05A6:  MOVF   00,W
05A7:  MOVWF  61
*
0B47:  MOVLW  38
0B48:  ADDWF  60,W
0B49:  MOVWF  04
0B4A:  BCF    03.7
0B4B:  MOVF   00,W
0B4C:  MOVWF  61
....................         for (int j = 0; j < sizeof(morseCodeTable) / sizeof(MorseCode); ++j) 
*
05A8:  CLRF   62
05A9:  MOVF   62,W
05AA:  SUBLW  23
05AB:  BTFSS  03.0
05AC:  GOTO   654
*
0B4D:  CLRF   62
0B4E:  MOVF   62,W
0B4F:  SUBLW  23
0B50:  BTFSS  03.0
0B51:  GOTO   41D
....................         { 
....................             if (c == morseCodeTable[j].character) 
*
05AD:  MOVF   62,W
05AE:  MOVWF  66
05AF:  MOVLW  07
05B0:  MOVWF  67
05B1:  CALL   240
05B2:  MOVLW  06
05B3:  ADDWF  78,W
05B4:  CALL   05A
05B5:  MOVWF  78
05B6:  SUBWF  61,W
05B7:  BTFSS  03.2
05B8:  GOTO   652
*
0B52:  MOVF   62,W
0B53:  MOVWF  66
0B54:  MOVLW  07
0B55:  MOVWF  67
0B56:  BCF    0A.3
0B57:  CALL   240
0B58:  BSF    0A.3
0B59:  MOVLW  06
0B5A:  ADDWF  78,W
0B5B:  BCF    0A.3
0B5C:  CALL   05A
0B5D:  BSF    0A.3
0B5E:  MOVWF  78
0B5F:  SUBWF  61,W
0B60:  BTFSS  03.2
0B61:  GOTO   41B
....................             { 
....................                 set_lcd_i2c_cursor_position(2, 0); 
*
05B9:  MOVLW  02
05BA:  MOVWF  66
05BB:  CLRF   67
05BC:  CALL   265
*
0B62:  MOVLW  02
0B63:  MOVWF  66
0B64:  CLRF   67
0B65:  BCF    0A.3
0B66:  CALL   265
0B67:  BSF    0A.3
....................                 printf(write_lcd_i2c, "%c: %s", c, morseCodeTable[j].morseCode); 
*
05BD:  MOVF   62,W
05BE:  MOVWF  66
05BF:  MOVLW  07
05C0:  MOVWF  67
05C1:  CALL   240
05C2:  MOVF   78,W
05C3:  MOVWF  66
05C4:  MOVF   61,W
05C5:  MOVWF  69
05C6:  CALL   27D
05C7:  MOVLW  3A
05C8:  MOVWF  69
05C9:  CALL   27D
05CA:  MOVLW  20
05CB:  MOVWF  69
05CC:  CALL   27D
05CD:  MOVLW  61
05CE:  BSF    03.6
05CF:  MOVWF  0D
05D0:  MOVLW  00
05D1:  MOVWF  0F
05D2:  BCF    03.6
05D3:  MOVF   66,W
05D4:  BSF    03.6
05D5:  ADDWF  0D,F
05D6:  BTFSC  03.0
05D7:  INCF   0F,F
*
0B68:  MOVF   62,W
0B69:  MOVWF  66
0B6A:  MOVLW  07
0B6B:  MOVWF  67
0B6C:  BCF    0A.3
0B6D:  CALL   240
0B6E:  BSF    0A.3
0B6F:  MOVF   78,W
0B70:  MOVWF  66
0B71:  MOVF   61,W
0B72:  MOVWF  69
0B73:  BCF    0A.3
0B74:  CALL   27D
0B75:  BSF    0A.3
0B76:  MOVLW  3A
0B77:  MOVWF  69
0B78:  BCF    0A.3
0B79:  CALL   27D
0B7A:  BSF    0A.3
0B7B:  MOVLW  20
0B7C:  MOVWF  69
0B7D:  BCF    0A.3
0B7E:  CALL   27D
0B7F:  BSF    0A.3
0B80:  MOVLW  61
0B81:  BSF    03.6
0B82:  MOVWF  0D
0B83:  MOVLW  00
0B84:  MOVWF  0F
0B85:  BCF    03.6
0B86:  MOVF   66,W
0B87:  BSF    03.6
0B88:  ADDWF  0D,F
0B89:  BTFSC  03.0
0B8A:  INCF   0F,F
....................  
....................                 unsigned int8 k = 0; 
*
0601:  BCF    03.6
0602:  CLRF   63
*
0BB6:  BCF    03.6
0BB7:  CLRF   63
....................                 while (morseCodeTable[j].morseCode[k] != '\0') 
*
0603:  MOVF   62,W
0604:  MOVWF  66
0605:  MOVLW  07
0606:  MOVWF  67
0607:  CALL   240
0608:  MOVF   63,W
0609:  ADDWF  78,W
060A:  CALL   05A
060B:  XORLW  00
060C:  BTFSC  03.2
060D:  GOTO   640
*
0BB8:  MOVF   62,W
0BB9:  MOVWF  66
0BBA:  MOVLW  07
0BBB:  MOVWF  67
0BBC:  BCF    0A.3
0BBD:  CALL   240
0BBE:  BSF    0A.3
0BBF:  MOVF   63,W
0BC0:  ADDWF  78,W
0BC1:  BCF    0A.3
0BC2:  CALL   05A
0BC3:  BSF    0A.3
0BC4:  XORLW  00
0BC5:  BTFSC  03.2
0BC6:  GOTO   403
....................                 { 
....................                     output_high(LED_Pin); 
*
060E:  BSF    03.5
060F:  BCF    08.0
0610:  BCF    03.5
0611:  BSF    08.0
*
0BC7:  BSF    03.5
0BC8:  BCF    08.0
0BC9:  BCF    03.5
0BCA:  BSF    08.0
....................                     unsigned int16 duration = morseCodeTable[j].morseCode[k] == '-' ? DASH_DURATION : DOT_DURATION; 
*
0612:  MOVF   62,W
0613:  MOVWF  66
0614:  MOVLW  07
0615:  MOVWF  67
0616:  CALL   240
0617:  MOVF   63,W
0618:  ADDWF  78,W
0619:  CALL   05A
061A:  SUBLW  2D
061B:  BTFSS  03.2
061C:  GOTO   621
061D:  MOVLW  02
061E:  MOVWF  7A
061F:  MOVLW  58
0620:  GOTO   623
0621:  CLRF   7A
0622:  MOVLW  C8
0623:  MOVWF  64
0624:  MOVF   7A,W
0625:  MOVWF  65
*
0BCB:  MOVF   62,W
0BCC:  MOVWF  66
0BCD:  MOVLW  07
0BCE:  MOVWF  67
0BCF:  BCF    0A.3
0BD0:  CALL   240
0BD1:  BSF    0A.3
0BD2:  MOVF   63,W
0BD3:  ADDWF  78,W
0BD4:  BCF    0A.3
0BD5:  CALL   05A
0BD6:  BSF    0A.3
0BD7:  SUBLW  2D
0BD8:  BTFSS  03.2
0BD9:  GOTO   3DE
0BDA:  MOVLW  02
0BDB:  MOVWF  7A
0BDC:  MOVLW  58
0BDD:  GOTO   3E0
0BDE:  CLRF   7A
0BDF:  MOVLW  C8
0BE0:  MOVWF  64
0BE1:  MOVF   7A,W
0BE2:  MOVWF  65
....................                     delay_ms(duration); 
*
0626:  MOVF   65,W
0627:  MOVWF  66
0628:  INCF   66,F
0629:  DECF   66,F
062A:  BTFSC  03.2
062B:  GOTO   630
062C:  MOVLW  FF
062D:  MOVWF  67
062E:  CALL   21B
062F:  GOTO   629
0630:  MOVF   64,W
0631:  MOVWF  67
0632:  CALL   21B
*
0BE3:  MOVF   65,W
0BE4:  MOVWF  66
0BE5:  INCF   66,F
0BE6:  DECF   66,F
0BE7:  BTFSC  03.2
0BE8:  GOTO   3EF
0BE9:  MOVLW  FF
0BEA:  MOVWF  67
0BEB:  BCF    0A.3
0BEC:  CALL   21B
0BED:  BSF    0A.3
0BEE:  GOTO   3E6
0BEF:  MOVF   64,W
0BF0:  MOVWF  67
0BF1:  BCF    0A.3
0BF2:  CALL   21B
0BF3:  BSF    0A.3
....................                     output_low(LED_Pin); 
*
0633:  BSF    03.5
0634:  BCF    08.0
0635:  BCF    03.5
0636:  BCF    08.0
*
0BF4:  BSF    03.5
0BF5:  BCF    08.0
0BF6:  BCF    03.5
0BF7:  BCF    08.0
....................  
....................                     delay_ms(400); 
*
0637:  MOVLW  02
0638:  MOVWF  66
0639:  MOVLW  C8
063A:  MOVWF  67
063B:  CALL   21B
063C:  DECFSZ 66,F
063D:  GOTO   639
*
0BF8:  MOVLW  02
0BF9:  MOVWF  66
0BFA:  MOVLW  C8
0BFB:  MOVWF  67
0BFC:  BCF    0A.3
0BFD:  CALL   21B
0BFE:  BSF    0A.3
0BFF:  DECFSZ 66,F
0C00:  GOTO   3FA
....................  
....................                     k++; 
*
063E:  INCF   63,F
063F:  GOTO   603
*
0C01:  INCF   63,F
0C02:  GOTO   3B8
....................                 } 
....................  
....................                 set_lcd_i2c_cursor_position(2, 0); 
*
0640:  MOVLW  02
0641:  MOVWF  66
0642:  CLRF   67
0643:  CALL   265
*
0C03:  MOVLW  02
0C04:  MOVWF  66
0C05:  CLRF   67
0C06:  BCF    0A.3
0C07:  CALL   265
0C08:  BSF    0A.3
....................                 printf(write_lcd_i2c, "                "); 
*
0644:  MOVLW  73
0645:  BSF    03.6
0646:  MOVWF  0D
0647:  MOVLW  01
0648:  MOVWF  0F
0649:  BCF    03.6
064A:  CALL   46C
*
0C09:  MOVLW  73
0C0A:  BSF    03.6
0C0B:  MOVWF  0D
0C0C:  MOVLW  01
0C0D:  MOVWF  0F
0C0E:  BCF    0A.3
0C0F:  BCF    03.6
0C10:  CALL   46C
0C11:  BSF    0A.3
....................  
....................                 delay_ms(800); 
*
064B:  MOVLW  04
064C:  MOVWF  66
064D:  MOVLW  C8
064E:  MOVWF  67
064F:  CALL   21B
0650:  DECFSZ 66,F
0651:  GOTO   64D
*
0C12:  MOVLW  04
0C13:  MOVWF  66
0C14:  MOVLW  C8
0C15:  MOVWF  67
0C16:  BCF    0A.3
0C17:  CALL   21B
0C18:  BSF    0A.3
0C19:  DECFSZ 66,F
0C1A:  GOTO   414
....................             } 
*
0652:  INCF   62,F
0653:  GOTO   5A9
*
0C1B:  INCF   62,F
0C1C:  GOTO   34E
....................         } 
*
0654:  INCF   60,F
0655:  GOTO   59E
*
0C1D:  INCF   60,F
0C1E:  GOTO   343
....................     } 
.................... } 
....................  
....................  
....................  
....................  
.................... // interrupt for uart receive 
....................  
.................... #INT_RDA 
.................... void UartReceive() 
*
04C2:  BTFSS  0C.5
04C3:  GOTO   4C2
04C4:  MOVF   1A,W
04C5:  MOVWF  5F
.................... { 
....................     char c = getc(PORT1); 
....................  
....................     switch (c) 
04C6:  MOVF   5F,W
04C7:  XORLW  63
04C8:  BTFSC  03.2
04C9:  GOTO   4D1
04CA:  XORLW  01
04CB:  BTFSC  03.2
04CC:  GOTO   4E3
04CD:  XORLW  0E
04CE:  BTFSC  03.2
04CF:  GOTO   59D
04D0:  GOTO   657
....................     { 
....................     case 'c': 
....................         clearAll(); 
....................         break; 
*
04E2:  GOTO   669
....................  
....................     case 'b': 
....................         playMorseCodeWithBuzzer(); 
....................         break; 
*
059C:  GOTO   669
....................  
....................     case 'l': 
....................         playMorseCodeWithLED(); 
....................         break; 
*
0656:  GOTO   669
....................  
....................     default: 
....................         morseCodeString[morseCodeStringIndex++] = c; 
0657:  MOVF   48,W
0658:  INCF   48,F
0659:  ADDLW  38
065A:  MOVWF  04
065B:  BCF    03.7
065C:  MOVF   5F,W
065D:  MOVWF  00
....................         set_lcd_i2c_cursor_position(1, morseCodeStringIndex - 1); 
065E:  MOVLW  01
065F:  SUBWF  48,W
0660:  MOVWF  60
0661:  MOVLW  01
0662:  MOVWF  66
0663:  MOVF   60,W
0664:  MOVWF  67
0665:  CALL   265
....................         printf(write_lcd_i2c, "%c", c); 
0666:  MOVF   5F,W
0667:  MOVWF  69
0668:  CALL   27D
....................         break; 
....................     } 
0669:  BCF    0C.5
066A:  BCF    0A.3
066B:  BCF    0A.4
066C:  GOTO   033
.................... } 
....................  
.................... void switchMode() 
.................... { 
....................     inputMode = !inputMode; 
*
0C74:  MOVLW  01
0C75:  XORWF  49,F
....................  
....................     clearAll(); 
....................  
....................     clear_lcd_i2c(); 
*
0C91:  BCF    0A.3
0C92:  CALL   230
0C93:  BSF    0A.3
0C94:  BTFSC  2B.7
0C95:  BSF    0B.7
....................  
....................     if (inputMode == BUTTON_MODE) 
0C96:  BTFSC  49.0
0C97:  GOTO   4BB
0C98:  CLRF   2B
0C99:  BTFSC  0B.7
0C9A:  BSF    2B.7
0C9B:  BCF    0B.7
....................     { 
....................         set_lcd_i2c_cursor_position(1, 0); 
0C9C:  MOVLW  01
0C9D:  MOVWF  66
0C9E:  CLRF   67
0C9F:  BCF    0A.3
0CA0:  CALL   265
0CA1:  BSF    0A.3
0CA2:  BTFSC  2B.7
0CA3:  BSF    0B.7
....................         printf(write_lcd_i2c, "INPUT: BUTTON"); 
0CA4:  MOVLW  6D
0CA5:  BSF    03.6
0CA6:  MOVWF  0D
0CA7:  MOVLW  06
0CA8:  MOVWF  0F
0CA9:  BCF    03.6
0CAA:  CLRF   2B
0CAB:  BTFSC  0B.7
0CAC:  BSF    2B.7
0CAD:  BCF    0B.7
0CAE:  BCF    0A.3
0CAF:  CALL   46C
0CB0:  BSF    0A.3
0CB1:  BTFSC  2B.7
0CB2:  BSF    0B.7
....................  
....................         disable_interrupts(INT_RDA); 
0CB3:  BSF    03.5
0CB4:  BCF    0C.5
....................         disable_interrupts(GLOBAL); 
0CB5:  BCF    03.5
0CB6:  BCF    0B.6
0CB7:  BCF    0B.7
0CB8:  BTFSC  0B.7
0CB9:  GOTO   4B7
....................     } 
0CBA:  GOTO   4DB
0CBB:  CLRF   2B
0CBC:  BTFSC  0B.7
0CBD:  BSF    2B.7
0CBE:  BCF    0B.7
....................     else 
....................     { 
....................         set_lcd_i2c_cursor_position(1, 0); 
0CBF:  MOVLW  01
0CC0:  MOVWF  66
0CC1:  CLRF   67
0CC2:  BCF    0A.3
0CC3:  CALL   265
0CC4:  BSF    0A.3
0CC5:  BTFSC  2B.7
0CC6:  BSF    0B.7
....................         printf(write_lcd_i2c, "INPUT: UART"); 
0CC7:  MOVLW  74
0CC8:  BSF    03.6
0CC9:  MOVWF  0D
0CCA:  MOVLW  06
0CCB:  MOVWF  0F
0CCC:  BCF    03.6
0CCD:  CLRF   2B
0CCE:  BTFSC  0B.7
0CCF:  BSF    2B.7
0CD0:  BCF    0B.7
0CD1:  BCF    0A.3
0CD2:  CALL   46C
0CD3:  BSF    0A.3
0CD4:  BTFSC  2B.7
0CD5:  BSF    0B.7
....................  
....................         enable_interrupts(INT_RDA); 
0CD6:  BSF    03.5
0CD7:  BSF    0C.5
....................         enable_interrupts(GLOBAL); 
0CD8:  MOVLW  C0
0CD9:  BCF    03.5
0CDA:  IORWF  0B,F
....................     } 
....................  
....................     delay_ms(1500); 
0CDB:  MOVLW  06
0CDC:  MOVWF  4E
0CDD:  CLRF   2B
0CDE:  BTFSC  0B.7
0CDF:  BSF    2B.7
0CE0:  BCF    0B.7
0CE1:  MOVLW  FA
0CE2:  MOVWF  67
0CE3:  BCF    0A.3
0CE4:  CALL   21B
0CE5:  BSF    0A.3
0CE6:  BTFSC  2B.7
0CE7:  BSF    0B.7
0CE8:  DECFSZ 4E,F
0CE9:  GOTO   4DD
0CEA:  CLRF   2B
0CEB:  BTFSC  0B.7
0CEC:  BSF    2B.7
0CED:  BCF    0B.7
....................     clear_lcd_i2c(); 
0CEE:  BCF    0A.3
0CEF:  CALL   230
0CF0:  BSF    0A.3
0CF1:  BTFSC  2B.7
0CF2:  BSF    0B.7
.................... } 
....................  
.................... void handleButtonPress() 
.................... { 
....................     if (input(SW_Pin[0]) == 0 && inputMode == BUTTON_MODE) // create morse code character 
*
08A3:  BSF    03.5
08A4:  BSF    06.0
08A5:  BCF    03.5
08A6:  BTFSC  06.0
08A7:  GOTO   145
08A8:  BTFSC  49.0
08A9:  GOTO   145
....................     { 
....................         recordMorseCode(); 
....................     } 
*
0944:  GOTO   50B
....................  
....................     else if (input(SW_Pin[1]) == 0 && inputMode == BUTTON_MODE) // append character to string and lcd 
0945:  BSF    03.5
0946:  BSF    06.1
0947:  BCF    03.5
0948:  BTFSC  06.1
0949:  GOTO   23F
094A:  BTFSC  49.0
094B:  GOTO   23F
094C:  CLRF   2B
094D:  BTFSC  0B.7
094E:  BSF    2B.7
094F:  BCF    0B.7
....................     { 
....................         delay_ms(100); // Debounce 
0950:  MOVLW  64
0951:  MOVWF  67
0952:  BCF    0A.3
0953:  CALL   21B
0954:  BSF    0A.3
0955:  BTFSC  2B.7
0956:  BSF    0B.7
....................  
....................         completeMorseCode(); 
....................  
....................         while (input(SW_Pin[1]) == 0) 
*
0A39:  BSF    03.5
0A3A:  BSF    06.1
0A3B:  BCF    03.5
0A3C:  BTFSS  06.1
0A3D:  GOTO   239
....................             ; // Wait for button release 
....................     } 
0A3E:  GOTO   50B
....................  
....................     else if (input(SW_Pin[2]) == 0) // play morse code with buzzer 
0A3F:  BSF    03.5
0A40:  BSF    06.2
0A41:  BCF    03.5
0A42:  BTFSC  06.2
0A43:  GOTO   332
0A44:  CLRF   2B
0A45:  BTFSC  0B.7
0A46:  BSF    2B.7
0A47:  BCF    0B.7
....................     { 
....................         delay_ms(50); // Debounce 
0A48:  MOVLW  32
0A49:  MOVWF  67
0A4A:  BCF    0A.3
0A4B:  CALL   21B
0A4C:  BSF    0A.3
0A4D:  BTFSC  2B.7
0A4E:  BSF    0B.7
....................  
....................         playMorseCodeWithBuzzer(); 
....................  
....................         while (input(SW_Pin[2]) == 0) 
*
0B2C:  BSF    03.5
0B2D:  BSF    06.2
0B2E:  BCF    03.5
0B2F:  BTFSS  06.2
0B30:  GOTO   32C
....................             ; // Wait for button release 
....................     } 
0B31:  GOTO   50B
....................  
....................     else if (input(SW_Pin[3]) == 0) // play morse code with LED 
0B32:  BSF    03.5
0B33:  BSF    06.3
0B34:  BCF    03.5
0B35:  BTFSC  06.3
0B36:  GOTO   425
0B37:  CLRF   2B
0B38:  BTFSC  0B.7
0B39:  BSF    2B.7
0B3A:  BCF    0B.7
....................     { 
....................         delay_ms(50); // Debounce 
0B3B:  MOVLW  32
0B3C:  MOVWF  67
0B3D:  BCF    0A.3
0B3E:  CALL   21B
0B3F:  BSF    0A.3
0B40:  BTFSC  2B.7
0B41:  BSF    0B.7
....................  
....................         playMorseCodeWithLED(); 
....................  
....................         while (input(SW_Pin[3]) == 0) 
*
0C1F:  BSF    03.5
0C20:  BSF    06.3
0C21:  BCF    03.5
0C22:  BTFSS  06.3
0C23:  GOTO   41F
....................             ; // Wait for button release 
....................     } 
0C24:  GOTO   50B
....................  
....................     else if (input(SW_Pin[4]) == 0) // clear all 
0C25:  BSF    03.5
0C26:  BSF    06.4
0C27:  BCF    03.5
0C28:  BTFSC  06.4
0C29:  GOTO   50B
....................     { 
....................         startTimer(); 
....................  
....................         delay_ms(50); // Debounce 
*
0C3C:  MOVLW  32
0C3D:  MOVWF  67
0C3E:  BCF    0A.3
0C3F:  CALL   21B
0C40:  BSF    0A.3
0C41:  BTFSC  2B.7
0C42:  BSF    0B.7
....................  
....................         while (input(SW_Pin[4]) == 0 && getTimerValue() < 1000) 
0C43:  BSF    03.5
0C44:  BSF    06.4
0C45:  BCF    03.5
0C46:  BTFSC  06.4
0C47:  GOTO   45A
*
0C4C:  MOVF   79,W
0C4D:  MOVWF  50
0C4E:  MOVF   78,W
0C4F:  MOVWF  4F
0C50:  MOVF   50,W
0C51:  SUBLW  03
0C52:  BTFSS  03.0
0C53:  GOTO   45A
0C54:  BTFSS  03.2
0C55:  GOTO   443
0C56:  MOVF   4F,W
0C57:  SUBLW  E7
0C58:  BTFSC  03.0
0C59:  GOTO   443
....................             ; // Wait for button release 
....................  
....................         unsigned int16 duration = stopAndReadTimer(); 
*
0C65:  MOVF   79,W
0C66:  MOVWF  4D
0C67:  MOVF   78,W
0C68:  MOVWF  4C
....................  
....................         if (duration >= 1000) 
0C69:  MOVF   4D,W
0C6A:  SUBLW  02
0C6B:  BTFSC  03.0
0C6C:  GOTO   4F4
0C6D:  XORLW  FF
0C6E:  BTFSS  03.2
0C6F:  GOTO   474
0C70:  MOVF   4C,W
0C71:  SUBLW  E7
0C72:  BTFSC  03.0
0C73:  GOTO   4F4
....................         { 
....................             switchMode(); 
....................         } 
*
0CF3:  GOTO   50B
....................         else 
....................         { 
....................             clearAll(); 
....................         } 
....................     } 
.................... } 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  BSF    03.5
0804:  BSF    03.6
0805:  BSF    07.3
0806:  MOVLW  70
0807:  BCF    03.6
0808:  MOVWF  19
0809:  MOVLW  02
080A:  MOVWF  1A
080B:  MOVLW  A6
080C:  MOVWF  18
080D:  MOVLW  90
080E:  BCF    03.5
080F:  MOVWF  18
0810:  MOVLW  FF
0811:  MOVWF  2C
0812:  MOVLW  08
0813:  MOVWF  2D
0814:  MOVLW  01
0815:  MOVWF  2E
0816:  CLRF   30
0817:  CLRF   2F
0818:  CLRF   37
0819:  CLRF   48
081A:  BCF    49.0
081B:  BSF    03.5
081C:  BSF    03.6
081D:  MOVF   09,W
081E:  ANDLW  C0
081F:  MOVWF  09
0820:  BCF    03.6
0821:  BCF    1F.4
0822:  BCF    1F.5
0823:  MOVLW  00
0824:  BSF    03.6
0825:  MOVWF  08
0826:  BCF    03.5
0827:  CLRF   07
0828:  CLRF   08
0829:  CLRF   09
082A:  BCF    03.7
.................... { 
....................     initialize_lcd_i2c(); // Initialize the LCD 
*
082E:  BCF    0A.3
082F:  GOTO   68A
0830:  BSF    0A.3
....................  
....................     set_tris_d(0x00); // Set LED and buzzer pins as output 
0831:  MOVLW  00
0832:  BSF    03.5
0833:  MOVWF  08
....................     set_tris_b(0x1F); // Set SW pins as input 
0834:  MOVLW  1F
0835:  MOVWF  06
....................     output_d(0x02);   // Turn off LED and Buzzer 
0836:  CLRF   08
0837:  MOVLW  02
0838:  BCF    03.5
0839:  MOVWF  08
....................  
....................     memset(morseCodeBufferString, 0, sizeof(morseCodeBufferString)); 
083A:  MOVLW  31
083B:  MOVWF  04
083C:  BCF    03.7
083D:  CLRF   77
083E:  MOVLW  06
083F:  MOVWF  78
0840:  BCF    0A.3
0841:  CALL   237
0842:  BSF    0A.3
....................     memset(morseCodeString, 0, sizeof(morseCodeString)); 
0843:  MOVLW  38
0844:  MOVWF  04
0845:  BCF    03.7
0846:  CLRF   77
0847:  MOVLW  10
0848:  MOVWF  78
0849:  BCF    0A.3
084A:  CALL   237
084B:  BSF    0A.3
084C:  CLRF   2B
084D:  BTFSC  0B.7
084E:  BSF    2B.7
084F:  BCF    0B.7
....................     clear_lcd_i2c(); 
0850:  BCF    0A.3
0851:  CALL   230
0852:  BSF    0A.3
0853:  BTFSC  2B.7
0854:  BSF    0B.7
0855:  CLRF   2B
0856:  BTFSC  0B.7
0857:  BSF    2B.7
0858:  BCF    0B.7
....................  
....................     set_lcd_i2c_cursor_position(1, 0); 
0859:  MOVLW  01
085A:  MOVWF  66
085B:  CLRF   67
085C:  BCF    0A.3
085D:  CALL   265
085E:  BSF    0A.3
085F:  BTFSC  2B.7
0860:  BSF    0B.7
....................     printf(write_lcd_i2c, "1. LE TRONG AN"); 
0861:  MOVLW  7A
0862:  BSF    03.6
0863:  MOVWF  0D
0864:  MOVLW  06
0865:  MOVWF  0F
0866:  BCF    03.6
0867:  CLRF   2B
0868:  BTFSC  0B.7
0869:  BSF    2B.7
086A:  BCF    0B.7
086B:  BCF    0A.3
086C:  CALL   46C
086D:  BSF    0A.3
086E:  BTFSC  2B.7
086F:  BSF    0B.7
0870:  CLRF   2B
0871:  BTFSC  0B.7
0872:  BSF    2B.7
0873:  BCF    0B.7
....................     set_lcd_i2c_cursor_position(2, 0); 
0874:  MOVLW  02
0875:  MOVWF  66
0876:  CLRF   67
0877:  BCF    0A.3
0878:  CALL   265
0879:  BSF    0A.3
087A:  BTFSC  2B.7
087B:  BSF    0B.7
....................     printf(write_lcd_i2c, "2. N.H VIET ANH"); 
087C:  MOVLW  82
087D:  BSF    03.6
087E:  MOVWF  0D
087F:  MOVLW  06
0880:  MOVWF  0F
0881:  BCF    03.6
0882:  CLRF   2B
0883:  BTFSC  0B.7
0884:  BSF    2B.7
0885:  BCF    0B.7
0886:  BCF    0A.3
0887:  CALL   46C
0888:  BSF    0A.3
0889:  BTFSC  2B.7
088A:  BSF    0B.7
....................  
....................     delay_ms(1500); 
088B:  MOVLW  06
088C:  MOVWF  4C
088D:  CLRF   2B
088E:  BTFSC  0B.7
088F:  BSF    2B.7
0890:  BCF    0B.7
0891:  MOVLW  FA
0892:  MOVWF  67
0893:  BCF    0A.3
0894:  CALL   21B
0895:  BSF    0A.3
0896:  BTFSC  2B.7
0897:  BSF    0B.7
0898:  DECFSZ 4C,F
0899:  GOTO   08D
089A:  CLRF   2B
089B:  BTFSC  0B.7
089C:  BSF    2B.7
089D:  BCF    0B.7
....................     clear_lcd_i2c(); 
089E:  BCF    0A.3
089F:  CALL   230
08A0:  BSF    0A.3
08A1:  BTFSC  2B.7
08A2:  BSF    0B.7
....................  
....................     while (TRUE) 
....................     { 
....................         handleButtonPress(); 
*
0D0B:  GOTO   0A3
....................     } 
.................... } 
0D0C:  SLEEP

Configuration Fuses:
   Word  1: 2CE2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
